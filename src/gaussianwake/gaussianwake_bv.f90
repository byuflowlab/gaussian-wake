!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7259) - 18 Jan 2019 09:31
!
!  Differentiation of porteagel_analyze in reverse (adjoint) mode (with options multiDirectional i4 dr8 r4):
!   gradient     of useful results: wtvelocity
!   with respect to varying inputs: rotordiameter turbinez turbinexw
!                wtvelocity turbineyw yawdeg ct
!   RW status of diff variables: rotordiameter:out turbinez:out
!                turbinexw:out wtvelocity:in-zero turbineyw:out
!                yawdeg:out ct:out
! Implementation of the Bastankhah and Porte Agel gaussian-shaped wind turbine wake 
! model (2016) with various farm modeling (TI and wake combination) methods included
! Created by Jared J. Thomas, 2017-2019.
! FLight Optimization and Wind Laboratory (FLOW Lab)
! Brigham Young University
! implementation of the Bastankhah and Porte Agel (BPA) wake model for analysis
SUBROUTINE PORTEAGEL_ANALYZE_BV(nturbines, nrotorpoints, nctpoints, &
& nfieldpoints, turbinexw, turbinexwb, sorted_x_idx, turbineyw, &
& turbineywb, turbinez, turbinezb, rotordiameter, rotordiameterb, ct, &
& ctb, wind_speed, yawdeg, yawdegb, ky, kz, alpha, beta, ti, &
& rotorpointsy, rotorpointsz, fieldpointsx, fieldpointsy, fieldpointsz, &
& z_ref, z_0, shear_exp, wake_combination_method, ti_calculation_method&
& , calc_k_star, wec_factor, print_ti, wake_model_version, interp_type, &
& use_ct_curve, ct_curve_wind_speed, ct_curve_ct, sm_smoothing, &
& wec_spreading_angle, calculateflowfield, wech, wtvelocityb, nbdirs)
 !!  USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  INTEGER, INTENT(IN) :: nturbines, nrotorpoints, nctpoints, &
& nfieldpoints
  INTEGER, INTENT(IN) :: wake_combination_method, ti_calculation_method&
& , wake_model_version, interp_type, wech
  LOGICAL, INTENT(IN) :: calc_k_star, print_ti, use_ct_curve, &
& calculateflowfield
  REAL(dp), DIMENSION(nturbines), INTENT(IN) :: turbinexw, turbineyw, &
& turbinez
  REAL(dp), DIMENSION(nbdirs, nturbines), intent(out) :: turbinexwb, turbineywb, &
& turbinezb
  INTEGER, DIMENSION(nturbines), INTENT(IN) :: sorted_x_idx
  REAL(dp), DIMENSION(nturbines), INTENT(IN) :: rotordiameter, yawdeg
  REAL(dp), DIMENSION(nbdirs, nturbines), intent(out) :: rotordiameterb, yawdegb
  REAL(dp), DIMENSION(nturbines) :: ct
  REAL(dp), DIMENSION(nbdirs, nturbines), intent(out) :: ctb
  REAL(dp), INTENT(IN) :: ky, kz, alpha, beta, ti, wind_speed, z_ref, &
& z_0, shear_exp, wec_factor
  REAL(dp), DIMENSION(nrotorpoints), INTENT(IN) :: rotorpointsy, &
& rotorpointsz
  REAL(dp), DIMENSION(nctpoints), INTENT(IN) :: ct_curve_wind_speed, &
& ct_curve_ct
  REAL(dp), INTENT(IN) :: sm_smoothing, wec_spreading_angle
  REAL(dp), DIMENSION(nfieldpoints), INTENT(IN) :: fieldpointsx, &
& fieldpointsy, fieldpointsz
! local (General)
  REAL(dp), DIMENSION(nturbines) :: yaw, titurbs, ct_local, ky_local, &
& kz_local
  REAL(dp), DIMENSION(nbdirs, nturbines) :: yawb, titurbsb, ct_localb&
& , ky_localb, kz_localb
  REAL(dp) :: k_star
  REAL(dp), DIMENSION(nbdirs) :: k_starb
  REAL(dp) :: tol, ti_area_ratio
  REAL(dp), DIMENSION(nbdirs) :: ti_area_ratiob
  REAL(dp) :: ti_area_ratio_tmp, ti_dst_tmp, ti_ust_tmp, rpts
  REAL(dp), DIMENSION(nbdirs) :: ti_area_ratio_tmpb, ti_dst_tmpb, &
& ti_ust_tmpb
  REAL(dp) :: localrotorpointy, localrotorpointz
  REAL(dp), DIMENSION(nbdirs) :: localrotorpointyb, localrotorpointzb
  REAL(dp) :: pointx, pointy, pointz, point_velocity_with_shear
  REAL(dp), DIMENSION(nbdirs) :: pointxb, pointyb, pointzb, &
& point_velocity_with_shearb
  REAL(dp) :: x, x0, theta_c_0, deltay, deltax0, sigmay, sigmaz, &
& wake_offset
  REAL(dp), DIMENSION(nbdirs) :: xb, x0b, theta_c_0b, deltayb, &
& sigmayb, sigmazb, wake_offsetb
  INTEGER :: d, u, turbi, p, turb
  REAL(dp), PARAMETER :: pi=3.141592653589793_dp
! model out
  REAL(dp), DIMENSION(nturbines) :: wtvelocity
  REAL(dp), DIMENSION(nbdirs, nturbines) :: wtvelocityb
  REAL(dp), DIMENSION(nfieldpoints) :: fieldvelocity
! initialize intrinsic functions
  INTRINSIC SIN, COS, ATAN, MAX, SQRT, LOG
  INTRINSIC REAL
  INTEGER :: nd
  INTEGER :: branch
  INTEGER :: nbdirs
! bastankhah and porte agel 2016 defines yaw to be positive clockwise, this is 
! reversed from the convention used in plant energy and from typical convention
  yaw = -(yawdeg*pi/180.0_dp)
! set tolerance for location checks
  tol = 0.1_dp
! initialize wind turbine velocities to 0.0
  wtvelocity = 0.0_dp
! initialize local TI of all turbines to free-stream value
  titurbs(:) = ti
! initialize the local wake factors
  IF (calc_k_star .EQV. .true.) THEN
    CALL K_STAR_FUNC(ti, k_star)
    ky_local(:) = k_star
    kz_local(:) = k_star
  ELSE
    ky_local(:) = ky
    kz_local(:) = kz
  END IF
  ct_local(:) = ct
  DO d=1,nturbines
! get index of downstream turbine
    CALL PUSHINTEGER4(turbi)
    turbi = sorted_x_idx(d) + 1
    DO p=1,nrotorpoints
! scale rotor sample point coordinate by rotor diameter (in rotor hub ref. frame)
      localrotorpointy = rotorpointsy(p)*0.5_dp*rotordiameter(turbi)
      localrotorpointz = rotorpointsz(p)*0.5_dp*rotordiameter(turbi)
      CALL PUSHREAL8(pointx)
      pointx = turbinexw(turbi) + localrotorpointy*SIN(yaw(turbi))
      CALL PUSHREAL8(pointy)
      pointy = turbineyw(turbi) + localrotorpointy*COS(yaw(turbi))
      pointz = turbinez(turbi) + localrotorpointz
! calculate the velocity at given point
      CALL POINT_VELOCITY_WITH_SHEAR_FUNC(nturbines, turbi, &
&                                   wake_combination_method, &
&                                   wake_model_version, sorted_x_idx, &
&                                   pointx, pointy, pointz, tol, alpha, &
&                                   beta, wec_spreading_angle, &
&                                   wec_factor, wind_speed, z_ref, z_0, &
&                                   shear_exp, turbinexw, turbineyw, &
&                                   turbinez, rotordiameter, yaw, &
&                                   wtvelocity, ct_local, titurbs, &
&                                   ky_local, kz_local, wech, &
&                                   point_velocity_with_shear)
! add sample point velocity to turbine velocity to be averaged later
      CALL PUSHREAL8(wtvelocity(turbi))
      wtvelocity(turbi) = wtvelocity(turbi) + point_velocity_with_shear
    END DO
! final velocity calculation for turbine turbI (average equally across all points)
    CALL PUSHREAL8(rpts)
    rpts = REAL(nrotorpoints, dp)
    CALL PUSHREAL8(wtvelocity(turbi))
    wtvelocity(turbi) = wtvelocity(turbi)/rpts
! update thrust coefficient for turbI
    IF (use_ct_curve) THEN
      CALL PUSHREAL8(ct_local(turbi))
      CALL INTERPOLATION(nctpoints, interp_type, ct_curve_wind_speed, &
&                  ct_curve_ct, wtvelocity(turbi), ct_local(turbi), &
&                  0.0_dp, 0.0_dp, .false.)
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
! calculate local turbulence intensity at turbI
    IF (ti_calculation_method .GT. 0) THEN
! initialize the TI_area_ratio to 0.0 for each turbine
      ti_area_ratio = 0.0_dp
! initialize local ti tmp
! loop over upstream turbines
      DO u=1,nturbines
! get index of upstream turbine
        CALL PUSHINTEGER4(turb)
        turb = sorted_x_idx(u) + 1
! skip turbine's influence on itself
        IF (turb .EQ. turbi) THEN
          CALL PUSHCONTROL2B(0)
        ELSE
! calculate downstream distance between wind turbines
          x = turbinexw(turbi) - turbinexw(turb)
          IF (x .GT. tol) THEN
! determine the far-wake onset location 
            CALL PUSHREAL8(x0)
            CALL X0_FUNC(rotordiameter(turb), yaw(turb), ct_local(turb)&
&                  , alpha, titurbs(turb), beta, x0)
! calculate the distance from the onset of far-wake
! horizontal spread 
            CALL PUSHREAL8(sigmay)
            CALL SIGMAY_FUNC(x, x0, ky_local(turb), rotordiameter(turb)&
&                      , yaw(turb), sigmay)
! vertical spread 
            CALL PUSHREAL8(sigmaz)
            CALL SIGMAZ_FUNC(x, x0, kz_local(turb), rotordiameter(turb)&
&                      , sigmaz)
! determine the initial wake angle at the onset of far wake
            CALL PUSHREAL8(theta_c_0)
            CALL THETA_C_0_FUNC(yaw(turb), ct_local(turb), theta_c_0)
! horizontal cross-wind wake displacement from hub
            CALL WAKE_OFFSET_FUNC(x, rotordiameter(turb), theta_c_0, x0&
&                           , yaw(turb), ky_local(turb), kz_local(turb)&
&                           , ct_local(turb), sigmay, sigmaz, &
&                           wake_offset)
! cross wind distance from point location to upstream turbine wake center
            CALL PUSHREAL8(deltay)
            deltay = turbineyw(turbi) - (turbineyw(turb)+wake_offset)
! save ti_area_ratio and ti_dst to new memory locations to avoid 
! aliasing during differentiation
            CALL PUSHREAL8(ti_area_ratio_tmp)
            ti_area_ratio_tmp = ti_area_ratio
            CALL PUSHREAL8(ti_dst_tmp)
            ti_dst_tmp = titurbs(turbi)
            CALL PUSHREAL8(ti_ust_tmp)
            ti_ust_tmp = titurbs(turb)
! update local turbulence intensity
            CALL PUSHREAL8(titurbs(turbi))
            CALL ADDED_TI_FUNC(ti, ct_local(turb), x, ky_local(turb), &
&                        rotordiameter(turb), rotordiameter(turbi), &
&                        deltay, turbinez(turb), turbinez(turbi), &
&                        sm_smoothing, ti_ust_tmp, ti_calculation_method&
&                        , ti_area_ratio_tmp, ti_dst_tmp, ti_area_ratio&
&                        , titurbs(turbi))
            CALL PUSHCONTROL2B(2)
          ELSE
            CALL PUSHCONTROL2B(1)
          END IF
        END IF
      END DO
! calculate wake spreading parameter at turbI based on local turbulence intensity
      IF (calc_k_star .EQV. .true.) THEN
        CALL K_STAR_FUNC(titurbs(turbi), k_star)
        CALL PUSHREAL8(ky_local(turbi))
        ky_local(turbi) = k_star
        CALL PUSHREAL8(kz_local(turbi))
        kz_local(turbi) = k_star
        CALL PUSHCONTROL2B(2)
      ELSE
        CALL PUSHCONTROL2B(1)
      END IF
    ELSE
      CALL PUSHCONTROL2B(0)
    END IF
  END DO
  rotordiameterb(:, :) = 0.0_8
  turbinezb(:, :) = 0.0_8
  turbinexwb(:, :) = 0.0_8
  turbineywb(:, :) = 0.0_8
  yawb(:, :) = 0.0_8
  titurbsb(:, :) = 0.0_8
  kz_localb(:, :) = 0.0_8
  ct_localb(:, :) = 0.0_8
  ky_localb(:, :) = 0.0_8
  DO d=nturbines,1,-1
    CALL POPCONTROL2B(branch)
    IF (branch .NE. 0) THEN
      IF (branch .NE. 1) THEN
        turbi = sorted_x_idx(d) + 1
        CALL POPREAL8(kz_local(turbi))
        CALL POPREAL8(ky_local(turbi))
        DO nd=1,nbdirs
          k_starb(nd) = ky_localb(nd, turbi) + kz_localb(nd, turbi)
          kz_localb(nd, turbi) = 0.0_8
          ky_localb(nd, turbi) = 0.0_8
        END DO
        CALL K_STAR_FUNC_BV(titurbs(turbi), titurbsb(1, turbi), k_star, &
&                     k_starb, nbdirs)
      END IF
      ti_area_ratiob(:) = 0.0_8
      DO u=nturbines,1,-1
        CALL POPCONTROL2B(branch)
        IF (branch .NE. 0) THEN
          IF (branch .EQ. 1) THEN
            xb(:) = 0.0_8
          ELSE
            turb = sorted_x_idx(u) + 1
            x = turbinexw(turbi) - turbinexw(turb)
            CALL POPREAL8(titurbs(turbi))
            CALL ADDED_TI_FUNC_BV(ti, ct_local(turb), ct_localb(1, turb)&
&                           , x, xb, ky_local(turb), ky_localb(1, turb)&
&                           , rotordiameter(turb), rotordiameterb(1, &
&                           turb), rotordiameter(turbi), rotordiameterb(&
&                           1, turbi), deltay, deltayb, turbinez(turb), &
&                           turbinezb(1, turb), turbinez(turbi), &
&                           turbinezb(1, turbi), sm_smoothing, &
&                           ti_ust_tmp, ti_ust_tmpb, &
&                           ti_calculation_method, ti_area_ratio_tmp, &
&                           ti_area_ratio_tmpb, ti_dst_tmp, ti_dst_tmpb&
&                           , ti_area_ratio, ti_area_ratiob, titurbs(&
&                           turbi), titurbsb(1, turbi), nbdirs)
            titurbsb(:, turbi) = 0.0_8
            CALL POPREAL8(ti_ust_tmp)
            CALL POPREAL8(ti_dst_tmp)
            CALL POPREAL8(ti_area_ratio_tmp)
            CALL POPREAL8(deltay)
            x0b(:) = 0.0_8
            sigmayb(:) = 0.0_8
            sigmazb(:) = 0.0_8
            DO nd=1,nbdirs
              titurbsb(nd, turb) = titurbsb(nd, turb) + ti_ust_tmpb(nd)
              titurbsb(nd, turbi) = titurbsb(nd, turbi) + ti_dst_tmpb(nd&
&               )
              ti_area_ratiob(nd) = ti_area_ratio_tmpb(nd)
              turbineywb(nd, turbi) = turbineywb(nd, turbi) + deltayb(nd&
&               )
              turbineywb(nd, turb) = turbineywb(nd, turb) - deltayb(nd)
              wake_offsetb(nd) = -deltayb(nd)
            END DO
            CALL WAKE_OFFSET_FUNC_BV(x, xb, rotordiameter(turb), &
&                              rotordiameterb(1, turb), theta_c_0, &
&                              theta_c_0b, x0, x0b, yaw(turb), yawb(1, &
&                              turb), ky_local(turb), ky_localb(1, turb)&
&                              , kz_local(turb), kz_localb(1, turb), &
&                              ct_local(turb), ct_localb(1, turb), &
&                              sigmay, sigmayb, sigmaz, sigmazb, &
&                              wake_offset, wake_offsetb, nbdirs)
            CALL POPREAL8(theta_c_0)
            CALL THETA_C_0_FUNC_BV(yaw(turb), yawb(1, turb), ct_local(&
&                            turb), ct_localb(1, turb), theta_c_0, &
&                            theta_c_0b, nbdirs)
            CALL POPREAL8(sigmaz)
            CALL SIGMAZ_FUNC_BV(x, xb, x0, x0b, kz_local(turb), &
&                         kz_localb(1, turb), rotordiameter(turb), &
&                         rotordiameterb(1, turb), sigmaz, sigmazb, &
&                         nbdirs)
            CALL POPREAL8(sigmay)
            CALL SIGMAY_FUNC_BV(x, xb, x0, x0b, ky_local(turb), &
&                         ky_localb(1, turb), rotordiameter(turb), &
&                         rotordiameterb(1, turb), yaw(turb), yawb(1, &
&                         turb), sigmay, sigmayb, nbdirs)
            CALL POPREAL8(x0)
            CALL X0_FUNC_BV(rotordiameter(turb), rotordiameterb(1, turb)&
&                     , yaw(turb), yawb(1, turb), ct_local(turb), &
&                     ct_localb(1, turb), alpha, titurbs(turb), titurbsb&
&                     (1, turb), beta, x0, x0b, nbdirs)
          END IF
          DO nd=1,nbdirs
            turbinexwb(nd, turbi) = turbinexwb(nd, turbi) + xb(nd)
            turbinexwb(nd, turb) = turbinexwb(nd, turb) - xb(nd)
          END DO
        END IF
        CALL POPINTEGER4(turb)
      END DO
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8(ct_local(turbi))
      CALL INTERPOLATION_BV(nctpoints, interp_type, ct_curve_wind_speed&
&                     , ct_curve_ct, wtvelocity(turbi), wtvelocityb(1, &
&                     turbi), ct_local(turbi), ct_localb(1, turbi), &
&                     0.0_dp, 0.0_dp, .false., nbdirs)
    END IF
    DO nd=1,nbdirs
      wtvelocityb(nd, turbi) = wtvelocityb(nd, turbi)/rpts
    END DO
    CALL POPREAL8(wtvelocity(turbi))
    CALL POPREAL8(rpts)
    DO p=nrotorpoints,1,-1
      DO nd=1,nbdirs
        point_velocity_with_shearb(nd) = wtvelocityb(nd, turbi)
      END DO
      CALL POPREAL8(wtvelocity(turbi))
      localrotorpointz = rotorpointsz(p)*0.5_dp*rotordiameter(turbi)
      pointz = turbinez(turbi) + localrotorpointz
      CALL POINT_VELOCITY_WITH_SHEAR_FUNC_BV(nturbines, turbi, &
&                                      wake_combination_method, &
&                                      wake_model_version, sorted_x_idx&
&                                      , pointx, pointxb, pointy, &
&                                      pointyb, pointz, pointzb, tol, &
&                                      alpha, beta, wec_spreading_angle&
&                                      , wec_factor, wind_speed, z_ref, &
&                                      z_0, shear_exp, turbinexw, &
&                                      turbinexwb, turbineyw, turbineywb&
&                                      , turbinez, turbinezb, &
&                                      rotordiameter, rotordiameterb, &
&                                      yaw, yawb, wtvelocity, &
&                                      wtvelocityb, ct_local, ct_localb&
&                                      , titurbs, titurbsb, ky_local, &
&                                      ky_localb, kz_local, kz_localb, &
&                                      wech, point_velocity_with_shear, &
&                                      point_velocity_with_shearb, &
&                                      nbdirs)
      localrotorpointy = rotorpointsy(p)*0.5_dp*rotordiameter(turbi)
      CALL POPREAL8(pointy)
      CALL POPREAL8(pointx)
      DO nd=1,nbdirs
        turbinezb(nd, turbi) = turbinezb(nd, turbi) + pointzb(nd)
        localrotorpointzb(nd) = pointzb(nd)
        turbineywb(nd, turbi) = turbineywb(nd, turbi) + pointyb(nd)
        localrotorpointyb(nd) = SIN(yaw(turbi))*pointxb(nd) + COS(yaw(&
&         turbi))*pointyb(nd)
        yawb(nd, turbi) = yawb(nd, turbi) + localrotorpointy*COS(yaw(&
&         turbi))*pointxb(nd) - localrotorpointy*SIN(yaw(turbi))*pointyb&
&         (nd)
        turbinexwb(nd, turbi) = turbinexwb(nd, turbi) + pointxb(nd)
        rotordiameterb(nd, turbi) = rotordiameterb(nd, turbi) + &
&         rotorpointsy(p)*0.5_dp*localrotorpointyb(nd) + rotorpointsz(p)&
&         *0.5_dp*localrotorpointzb(nd)
      END DO
    END DO
    CALL POPINTEGER4(turbi)
  END DO
  ctb(:, :) = 0.0_8
  DO nd=1,nbdirs
    ctb(nd, :) = ct_localb(nd, :)
  END DO
  yawdegb(:, :) = 0.0_8
  DO nd=1,nbdirs
    yawdegb(nd, :) = -(pi*yawb(nd, :)/180.0_dp)
  END DO
  wtvelocityb(:, :) = 0.0_8
END SUBROUTINE PORTEAGEL_ANALYZE_BV

!  Differentiation of point_velocity_with_shear_func in reverse (adjoint) mode (with options multiDirectional i4 dr8 r4):
!   gradient     of useful results: yaw rotordiameter turbinez
!                turbinexw wtvelocity point_velocity_with_shear
!                titurbs turbineyw kz_local ct_local ky_local
!   with respect to varying inputs: yaw rotordiameter turbinez
!                turbinexw pointx pointy pointz wtvelocity titurbs
!                turbineyw kz_local ct_local ky_local
SUBROUTINE POINT_VELOCITY_WITH_SHEAR_FUNC_BV(nturbines, turbi, &
& wake_combination_method, wake_model_version, sorted_x_idx, pointx, &
& pointxb, pointy, pointyb, pointz, pointzb, tol, alpha, beta, &
& wec_spreading_angle, wec_factor, wind_speed, z_ref, z_0, shear_exp, &
& turbinexw, turbinexwb, turbineyw, turbineywb, turbinez, turbinezb, &
& rotordiameter, rotordiameterb, yaw, yawb, wtvelocity, wtvelocityb, &
& ct_local, ct_localb, titurbs, titurbsb, ky_local, ky_localb, kz_local&
& , kz_localb, wech, point_velocity_with_shear, &
& point_velocity_with_shearb, nbdirs)
 !!  USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  INTEGER, INTENT(IN) :: nturbines, turbi, wake_combination_method, &
& wake_model_version, wech
  INTEGER, DIMENSION(nturbines), INTENT(IN) :: sorted_x_idx
  REAL(dp), INTENT(IN) :: pointx, pointy, pointz
  REAL(dp), DIMENSION(nbdirs) :: pointxb, pointyb, pointzb
  REAL(dp), INTENT(IN) :: tol, alpha, beta, wec_spreading_angle, &
& wec_factor
  REAL(dp), INTENT(IN) :: wind_speed
  REAL(dp), INTENT(IN) :: z_ref, z_0, shear_exp
  REAL(dp), DIMENSION(nturbines), INTENT(IN) :: turbinexw, turbineyw, &
& turbinez
  REAL(dp), DIMENSION(nbdirs, nturbines) :: turbinexwb, turbineywb, &
& turbinezb
  REAL(dp), DIMENSION(nturbines), INTENT(IN) :: rotordiameter, yaw, &
& wtvelocity
  REAL(dp), DIMENSION(nbdirs, nturbines) :: rotordiameterb, yawb, &
& wtvelocityb
  REAL(dp), DIMENSION(nturbines), INTENT(IN) :: ct_local, titurbs, &
& ky_local, kz_local
  REAL(dp), DIMENSION(nbdirs, nturbines) :: ct_localb, titurbsb, &
& ky_localb, kz_localb
! out
  REAL(dp) :: point_velocity_with_shear
  REAL(dp), DIMENSION(nbdirs) :: point_velocity_with_shearb
  REAL(dp) :: wake_offset
  REAL(dp), DIMENSION(nbdirs) :: wake_offsetb
! local
  REAL(dp) :: old_deficit_sum, deficit_sum
  REAL(dp), DIMENSION(nbdirs) :: old_deficit_sumb, deficit_sumb
  REAL(dp) :: x, deltav, x0, theta_c_0, sigmay, sigmaz
  REAL(dp), DIMENSION(nbdirs) :: xb, deltavb, x0b, theta_c_0b, &
& sigmayb, sigmazb
  REAL(dp) :: discontinuity_point, sigmay_d, sigmaz_d
  REAL(dp), DIMENSION(nbdirs) :: discontinuity_pointb, sigmay_db, &
& sigmaz_db
  REAL(dp) :: sigmay_0, sigmaz_0, deltay, deltaz, point_velocity
  REAL(dp), DIMENSION(nbdirs) :: sigmay_0b, sigmaz_0b, deltayb, &
& deltazb, point_velocityb
  REAL(dp) :: sigmay_spread, sigmaz_spread, sigmay_0_spread, &
& sigmaz_0_spread
  REAL(dp), DIMENSION(nbdirs) :: sigmay_spreadb, sigmaz_spreadb, &
& sigmay_0_spreadb, sigmaz_0_spreadb
  INTEGER :: u, turb
  INTEGER :: nd
  INTEGER :: branch
  INTEGER :: nbdirs
! initialize deficit summation term to zero
  deficit_sum = 0.0_dp
! loop through all turbines
! at turbineX-locations
  DO u=1,nturbines
! get index of upstream turbine
    CALL PUSHINTEGER4(turb)
    turb = sorted_x_idx(u) + 1
! skip this loop if turb = turbI (turbines impact on itself)
    IF (turb .EQ. turbi) THEN
      CALL PUSHCONTROL2B(0)
    ELSE
! downstream distance between upstream turbine and point
      x = pointx - turbinexw(turb)
! set this iterations velocity deficit to 0
! check turbine relative locations
      IF (x .GT. tol) THEN
! determine the onset location of far wake
        CALL PUSHREAL8(x0)
        CALL X0_FUNC(rotordiameter(turb), yaw(turb), ct_local(turb), &
&              alpha, titurbs(turb), beta, x0)
! find the final point where the original model is undefined
        CALL PUSHREAL8(discontinuity_point)
        CALL DISCONTINUITY_POINT_FUNC(x0, rotordiameter(turb), ky_local(&
&                               turb), kz_local(turb), yaw(turb), &
&                               ct_local(turb), discontinuity_point)
! horizontal spread at discontinuity point
        CALL PUSHREAL8(sigmay_d)
        CALL SIGMAY_FUNC(discontinuity_point, x0, ky_local(turb), &
&                  rotordiameter(turb), yaw(turb), sigmay_d)
! vertical spread at discontinuity point
        CALL PUSHREAL8(sigmaz_d)
        CALL SIGMAZ_FUNC(discontinuity_point, x0, kz_local(turb), &
&                  rotordiameter(turb), sigmaz_d)
! horizontal spread at far wake onset point
        CALL PUSHREAL8(sigmay_0)
        CALL SIGMAY_FUNC(x0, x0, ky_local(turb), rotordiameter(turb), &
&                  yaw(turb), sigmay_0)
! vertical spread at at far wake onset point
        CALL PUSHREAL8(sigmaz_0)
        CALL SIGMAZ_FUNC(x0, x0, kz_local(turb), rotordiameter(turb), &
&                  sigmaz_0)
! calculate wake spread in horizontal at point of interest
        CALL PUSHREAL8(sigmay)
        CALL SIGMA_SPREAD_FUNC(x, x0, ky_local(turb), sigmay_0, sigmay_d&
&                        , 0.0_dp, 1.0_dp, sigmay)
! calculate wake spread in vertical at point of interest
        CALL PUSHREAL8(sigmaz)
        CALL SIGMA_SPREAD_FUNC(x, x0, kz_local(turb), sigmaz_0, sigmaz_d&
&                        , 0.0_dp, 1.0_dp, sigmaz)
! calculate new spread for WEC in y (horizontal)
        CALL PUSHREAL8(sigmay_spread)
        CALL SIGMA_SPREAD_FUNC(x, x0, ky_local(turb), sigmay_0, sigmay_d&
&                        , wec_spreading_angle, wec_factor, &
&                        sigmay_spread)
! calculate new spread for WEC in z (horizontal)
        CALL PUSHREAL8(sigmaz_spread)
        CALL SIGMA_SPREAD_FUNC(x, x0, kz_local(turb), sigmaz_0, sigmaz_d&
&                        , wec_spreading_angle, wec_factor, &
&                        sigmaz_spread)
! calculate new spread for WEC in y (horizontal) at onset of far wake
        CALL PUSHREAL8(sigmay_0_spread)
        CALL SIGMA_SPREAD_FUNC(x0, x0, ky_local(turb), sigmay_0, &
&                        sigmay_d, wec_spreading_angle, wec_factor, &
&                        sigmay_0_spread)
! calculate new spread for WEC in z (horizontal) at onset of far wake
        CALL PUSHREAL8(sigmaz_0_spread)
        CALL SIGMA_SPREAD_FUNC(x0, x0, kz_local(turb), sigmaz_0, &
&                        sigmaz_d, wec_spreading_angle, wec_factor, &
&                        sigmaz_0_spread)
! determine the initial wake angle at the onset of far wake
        CALL PUSHREAL8(theta_c_0)
        CALL THETA_C_0_FUNC(yaw(turb), ct_local(turb), theta_c_0)
! horizontal cross-wind wake displacement from hub
        CALL WAKE_OFFSET_FUNC(x, rotordiameter(turb), theta_c_0, x0, yaw&
&                       (turb), ky_local(turb), kz_local(turb), ct_local&
&                       (turb), sigmay, sigmaz, wake_offset)
! print *, x
! cross wind distance from point location to upstream turbine wake center
        CALL PUSHREAL8(deltay)
        deltay = pointy - (turbineyw(turb)+wake_offset)
! vertical distance from upstream hub height to height of point of interest
        deltaz = pointz - turbinez(turb)
        IF (x .GT. x0) THEN
! velocity difference in the wake
          CALL PUSHREAL8(deltav)
          CALL DELTAV_FUNC(deltay, deltaz, ct_local(turb), yaw(turb), &
&                    sigmay, sigmaz, rotordiameter(turb), &
&                    wake_model_version, kz_local(turb), x, wec_factor, &
&                    sigmay_spread, sigmaz_spread, deltav)
          CALL PUSHCONTROL1B(0)
        ELSE
! velocity deficit in the nearwake (linear model)
          CALL PUSHREAL8(deltav)
          CALL DELTAV_NEAR_WAKE_LIN_FUNC(deltay, deltaz, ct_local(turb)&
&                                  , yaw(turb), sigmay_0, sigmaz_0, x0, &
&                                  rotordiameter(turb), x, &
&                                  discontinuity_point, sigmay_d, &
&                                  sigmaz_d, wake_model_version, &
&                                  kz_local(turb), x0, sigmay_spread, &
&                                  sigmaz_spread, sigmay_0_spread, &
&                                  sigmaz_0_spread, wec_factor, wech, &
&                                  deltav)
          CALL PUSHCONTROL1B(1)
        END IF
! save deficit sum in holder for AD purposes
        CALL PUSHREAL8(old_deficit_sum)
        old_deficit_sum = deficit_sum
! combine deficits according to selected wake combination method
        CALL WAKE_COMBINATION_FUNC(wind_speed, wtvelocity(turb), deltav&
&                            , wake_combination_method, old_deficit_sum&
&                            , deficit_sum)
        CALL PUSHCONTROL2B(2)
      ELSE
        CALL PUSHCONTROL2B(1)
      END IF
    END IF
  END DO
! find velocity at point without shear
  point_velocity = wind_speed - deficit_sum
! adjust sample point velocity for shear
  CALL WIND_SHEAR_FUNC_BV(pointz, pointzb, point_velocity, &
&                   point_velocityb, z_ref, z_0, shear_exp, &
&                   point_velocity_with_shear, &
&                   point_velocity_with_shearb, nbdirs)
  DO nd=1,nbdirs
    deficit_sumb(nd) = -point_velocityb(nd)
  END DO
  pointxb(:) = 0.0_8
  pointyb(:) = 0.0_8
  DO u=nturbines,1,-1
    CALL POPCONTROL2B(branch)
    IF (branch .NE. 0) THEN
      IF (branch .EQ. 1) THEN
        xb(:) = 0.0_8
      ELSE
        turb = sorted_x_idx(u) + 1
        CALL WAKE_COMBINATION_FUNC_BV(wind_speed, wtvelocity(turb), &
&                               wtvelocityb(1, turb), deltav, deltavb, &
&                               wake_combination_method, old_deficit_sum&
&                               , old_deficit_sumb, deficit_sum, &
&                               deficit_sumb, nbdirs)
        CALL POPREAL8(old_deficit_sum)
        DO nd=1,nbdirs
          deficit_sumb(nd) = old_deficit_sumb(nd)
        END DO
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          x = pointx - turbinexw(turb)
          deltaz = pointz - turbinez(turb)
          CALL POPREAL8(deltav)
          CALL DELTAV_FUNC_BV(deltay, deltayb, deltaz, deltazb, ct_local&
&                       (turb), ct_localb(1, turb), yaw(turb), yawb(1, &
&                       turb), sigmay, sigmayb, sigmaz, sigmazb, &
&                       rotordiameter(turb), rotordiameterb(1, turb), &
&                       wake_model_version, kz_local(turb), kz_localb(1&
&                       , turb), x, xb, wec_factor, sigmay_spread, &
&                       sigmay_spreadb, sigmaz_spread, sigmaz_spreadb, &
&                       deltav, deltavb, nbdirs)
          sigmay_db(:) = 0.0_8
          sigmaz_0b(:) = 0.0_8
          discontinuity_pointb(:) = 0.0_8
          sigmay_0b(:) = 0.0_8
          sigmaz_db(:) = 0.0_8
          x0b(:) = 0.0_8
          sigmaz_0_spreadb(:) = 0.0_8
          sigmay_0_spreadb(:) = 0.0_8
        ELSE
          x = pointx - turbinexw(turb)
          deltaz = pointz - turbinez(turb)
          CALL POPREAL8(deltav)
          CALL DELTAV_NEAR_WAKE_LIN_FUNC_BV(deltay, deltayb, deltaz, &
&                                     deltazb, ct_local(turb), ct_localb&
&                                     (1, turb), yaw(turb), yawb(1, turb&
&                                     ), sigmay_0, sigmay_0b, sigmaz_0, &
&                                     sigmaz_0b, x0, x0b, rotordiameter(&
&                                     turb), rotordiameterb(1, turb), x&
&                                     , xb, discontinuity_point, &
&                                     discontinuity_pointb, sigmay_d, &
&                                     sigmay_db, sigmaz_d, sigmaz_db, &
&                                     wake_model_version, kz_local(turb)&
&                                     , kz_localb(1, turb), x0, &
&                                     sigmay_spread, sigmay_spreadb, &
&                                     sigmaz_spread, sigmaz_spreadb, &
&                                     sigmay_0_spread, sigmay_0_spreadb&
&                                     , sigmaz_0_spread, &
&                                     sigmaz_0_spreadb, wec_factor, wech&
&                                     , deltav, deltavb, nbdirs)
          sigmayb(:) = 0.0_8
          sigmazb(:) = 0.0_8
        END IF
        DO nd=1,nbdirs
          pointzb(nd) = pointzb(nd) + deltazb(nd)
          turbinezb(nd, turb) = turbinezb(nd, turb) - deltazb(nd)
          pointyb(nd) = pointyb(nd) + deltayb(nd)
          turbineywb(nd, turb) = turbineywb(nd, turb) - deltayb(nd)
          wake_offsetb(nd) = -deltayb(nd)
        END DO
        CALL POPREAL8(deltay)
        CALL WAKE_OFFSET_FUNC_BV(x, xb, rotordiameter(turb), &
&                          rotordiameterb(1, turb), theta_c_0, &
&                          theta_c_0b, x0, x0b, yaw(turb), yawb(1, turb)&
&                          , ky_local(turb), ky_localb(1, turb), &
&                          kz_local(turb), kz_localb(1, turb), ct_local(&
&                          turb), ct_localb(1, turb), sigmay, sigmayb, &
&                          sigmaz, sigmazb, wake_offset, wake_offsetb, &
&                          nbdirs)
        CALL POPREAL8(theta_c_0)
        CALL THETA_C_0_FUNC_BV(yaw(turb), yawb(1, turb), ct_local(turb)&
&                        , ct_localb(1, turb), theta_c_0, theta_c_0b, &
&                        nbdirs)
        CALL POPREAL8(sigmaz_0_spread)
        CALL SIGMA_SPREAD_FUNC_BV(x0, x0b, x0, x0b, kz_local(turb), &
&                           kz_localb(1, turb), sigmaz_0, sigmaz_0b, &
&                           sigmaz_d, sigmaz_db, wec_spreading_angle, &
&                           wec_factor, sigmaz_0_spread, &
&                           sigmaz_0_spreadb, nbdirs)
        CALL POPREAL8(sigmay_0_spread)
        CALL SIGMA_SPREAD_FUNC_BV(x0, x0b, x0, x0b, ky_local(turb), &
&                           ky_localb(1, turb), sigmay_0, sigmay_0b, &
&                           sigmay_d, sigmay_db, wec_spreading_angle, &
&                           wec_factor, sigmay_0_spread, &
&                           sigmay_0_spreadb, nbdirs)
        CALL POPREAL8(sigmaz_spread)
        CALL SIGMA_SPREAD_FUNC_BV(x, xb, x0, x0b, kz_local(turb), &
&                           kz_localb(1, turb), sigmaz_0, sigmaz_0b, &
&                           sigmaz_d, sigmaz_db, wec_spreading_angle, &
&                           wec_factor, sigmaz_spread, sigmaz_spreadb, &
&                           nbdirs)
        CALL POPREAL8(sigmay_spread)
        CALL SIGMA_SPREAD_FUNC_BV(x, xb, x0, x0b, ky_local(turb), &
&                           ky_localb(1, turb), sigmay_0, sigmay_0b, &
&                           sigmay_d, sigmay_db, wec_spreading_angle, &
&                           wec_factor, sigmay_spread, sigmay_spreadb, &
&                           nbdirs)
        CALL POPREAL8(sigmaz)
        CALL SIGMA_SPREAD_FUNC_BV(x, xb, x0, x0b, kz_local(turb), &
&                           kz_localb(1, turb), sigmaz_0, sigmaz_0b, &
&                           sigmaz_d, sigmaz_db, 0.0_dp, 1.0_dp, sigmaz&
&                           , sigmazb, nbdirs)
        CALL POPREAL8(sigmay)
        CALL SIGMA_SPREAD_FUNC_BV(x, xb, x0, x0b, ky_local(turb), &
&                           ky_localb(1, turb), sigmay_0, sigmay_0b, &
&                           sigmay_d, sigmay_db, 0.0_dp, 1.0_dp, sigmay&
&                           , sigmayb, nbdirs)
        CALL POPREAL8(sigmaz_0)
        CALL SIGMAZ_FUNC_BV(x0, x0b, x0, x0b, kz_local(turb), kz_localb(&
&                     1, turb), rotordiameter(turb), rotordiameterb(1, &
&                     turb), sigmaz_0, sigmaz_0b, nbdirs)
        CALL POPREAL8(sigmay_0)
        CALL SIGMAY_FUNC_BV(x0, x0b, x0, x0b, ky_local(turb), ky_localb(&
&                     1, turb), rotordiameter(turb), rotordiameterb(1, &
&                     turb), yaw(turb), yawb(1, turb), sigmay_0, &
&                     sigmay_0b, nbdirs)
        CALL POPREAL8(sigmaz_d)
        CALL SIGMAZ_FUNC_BV(discontinuity_point, discontinuity_pointb, &
&                     x0, x0b, kz_local(turb), kz_localb(1, turb), &
&                     rotordiameter(turb), rotordiameterb(1, turb), &
&                     sigmaz_d, sigmaz_db, nbdirs)
        CALL POPREAL8(sigmay_d)
        CALL SIGMAY_FUNC_BV(discontinuity_point, discontinuity_pointb, &
&                     x0, x0b, ky_local(turb), ky_localb(1, turb), &
&                     rotordiameter(turb), rotordiameterb(1, turb), yaw(&
&                     turb), yawb(1, turb), sigmay_d, sigmay_db, nbdirs)
        CALL POPREAL8(discontinuity_point)
        CALL DISCONTINUITY_POINT_FUNC_BV(x0, x0b, rotordiameter(turb), &
&                                  rotordiameterb(1, turb), ky_local(&
&                                  turb), ky_localb(1, turb), kz_local(&
&                                  turb), kz_localb(1, turb), yaw(turb)&
&                                  , yawb(1, turb), ct_local(turb), &
&                                  ct_localb(1, turb), &
&                                  discontinuity_point, &
&                                  discontinuity_pointb, nbdirs)
        CALL POPREAL8(x0)
        CALL X0_FUNC_BV(rotordiameter(turb), rotordiameterb(1, turb), &
&                 yaw(turb), yawb(1, turb), ct_local(turb), ct_localb(1&
&                 , turb), alpha, titurbs(turb), titurbsb(1, turb), beta&
&                 , x0, x0b, nbdirs)
      END IF
      DO nd=1,nbdirs
        pointxb(nd) = pointxb(nd) + xb(nd)
        turbinexwb(nd, turb) = turbinexwb(nd, turb) - xb(nd)
      END DO
    END IF
    CALL POPINTEGER4(turb)
  END DO
END SUBROUTINE POINT_VELOCITY_WITH_SHEAR_FUNC_BV

!  Differentiation of x0_func in reverse (adjoint) mode (with options multiDirectional i4 dr8 r4):
!   gradient     of useful results: ti yaw rotor_diameter x0 ct
!   with respect to varying inputs: ti yaw rotor_diameter ct
! calculates the onset of far-wake conditions
SUBROUTINE X0_FUNC_BV(rotor_diameter, rotor_diameterb, yaw, yawb, ct, &
& ctb, alpha, ti, tib, beta, x0, x0b, nbdirs)
 !!  USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: rotor_diameter, yaw, ct, alpha, ti, beta
  REAL(dp), DIMENSION(nbdirs) :: rotor_diameterb, yawb, ctb, tib
! out
  REAL(dp) :: x0
  REAL(dp), DIMENSION(nbdirs) :: x0b
  INTRINSIC COS, SQRT
! determine the onset location of far wake
  REAL(dp) :: temp
  REAL(dp) :: temp0
  REAL(dp) :: temp1
  REAL(dp) :: temp2
  REAL(dp) :: temp3
  INTEGER :: nd
  REAL(dp), DIMENSION(nbdirs) :: tempb
  REAL(dp), DIMENSION(nbdirs) :: tempb0
  INTEGER :: nbdirs
  temp = SQRT(-ct + 1.0_dp)
  temp0 = SQRT(2.0_dp)
  temp1 = temp0*(alpha*ti+beta*(-temp+1.0_dp))
  temp2 = SQRT(-ct + 1.0_dp)
  temp3 = COS(yaw)
  DO nd=1,nbdirs
    tempb(nd) = x0b(nd)/temp1
    tempb0(nd) = -(rotor_diameter*temp3*(temp2+1.0_dp)*temp0*tempb(nd)/&
&     temp1)
    rotor_diameterb(nd) = rotor_diameterb(nd) + (temp2+1.0_dp)*temp3*&
&     tempb(nd)
    yawb(nd) = yawb(nd) - rotor_diameter*(temp2+1.0_dp)*SIN(yaw)*tempb(&
&     nd)
    IF (.NOT.1.0_dp - ct .EQ. 0.0) ctb(nd) = ctb(nd) + beta*tempb0(nd)/(&
&       2.0*temp) - rotor_diameter*temp3*tempb(nd)/(2.0*temp2)
    tib(nd) = tib(nd) + alpha*tempb0(nd)
  END DO
END SUBROUTINE X0_FUNC_BV

!  Differentiation of theta_c_0_func in reverse (adjoint) mode (with options multiDirectional i4 dr8 r4):
!   gradient     of useful results: theta_c_0 yaw ct
!   with respect to varying inputs: yaw ct
! calculates the wake angle at the onset of far wake conditions
SUBROUTINE THETA_C_0_FUNC_BV(yaw, yawb, ct, ctb, theta_c_0, theta_c_0b, &
& nbdirs)
 !!  USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: yaw, ct
  REAL(dp), DIMENSION(nbdirs) :: yawb, ctb
! out
  REAL(dp) :: theta_c_0
  REAL(dp), DIMENSION(nbdirs) :: theta_c_0b
  INTRINSIC COS, SQRT
! determine the initial wake angle at the onset of far wake
  REAL(dp) :: temp
  REAL(dp) :: temp0
  REAL(dp) :: temp1
  INTEGER :: nd
  REAL(dp), DIMENSION(nbdirs) :: tempb
  REAL(dp), DIMENSION(nbdirs) :: tempb0
  INTEGER :: nbdirs
  temp = COS(yaw)
  temp0 = COS(yaw)
  temp1 = SQRT(-(ct*temp0) + 1.0_dp)
  DO nd=1,nbdirs
    IF (1.0_dp - ct*temp0 .EQ. 0.0) THEN
      tempb(nd) = 0.0
    ELSE
      tempb(nd) = -(yaw*0.3_dp*theta_c_0b(nd)/(temp*2.0*temp1))
    END IF
    tempb0(nd) = (1.0_dp-temp1)*0.3_dp*theta_c_0b(nd)/temp
    ctb(nd) = ctb(nd) - temp0*tempb(nd)
    yawb(nd) = yawb(nd) + (yaw*SIN(yaw)/temp+1.0_8)*tempb0(nd) + ct*SIN(&
&     yaw)*tempb(nd)
  END DO
END SUBROUTINE THETA_C_0_FUNC_BV

!  Differentiation of sigmay_func in reverse (adjoint) mode (with options multiDirectional i4 dr8 r4):
!   gradient     of useful results: yaw x sigmay ky rotor_diameter
!                x0
!   with respect to varying inputs: yaw x ky rotor_diameter x0
! calculates the horizontal spread of the wake at a given distance from the onset of far 
! wake condition
SUBROUTINE SIGMAY_FUNC_BV(x, xb, x0, x0b, ky, kyb, rotor_diameter, &
& rotor_diameterb, yaw, yawb, sigmay, sigmayb, nbdirs)
 !!  USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: ky, x, x0, rotor_diameter, yaw
  REAL(dp), DIMENSION(nbdirs) :: kyb, xb, x0b, rotor_diameterb, yawb
! out
  REAL(dp) :: sigmay
  REAL(dp), DIMENSION(nbdirs) :: sigmayb
  INTRINSIC COS, SQRT
! horizontal spread
  REAL(dp) :: temp
  INTEGER :: nd
  INTEGER :: nbdirs
  temp = SQRT(8.0_dp)
  DO nd=1,nbdirs
    kyb(nd) = kyb(nd) + (x-x0)*sigmayb(nd)
    xb(nd) = xb(nd) + ky*sigmayb(nd)
    x0b(nd) = x0b(nd) - ky*sigmayb(nd)
    yawb(nd) = yawb(nd) - rotor_diameter*SIN(yaw)*sigmayb(nd)/temp
    rotor_diameterb(nd) = rotor_diameterb(nd) + COS(yaw)*sigmayb(nd)/&
&     temp
  END DO
END SUBROUTINE SIGMAY_FUNC_BV

!  Differentiation of sigmaz_func in reverse (adjoint) mode (with options multiDirectional i4 dr8 r4):
!   gradient     of useful results: x sigmaz kz rotor_diameter
!                x0
!   with respect to varying inputs: x kz rotor_diameter x0
! calculates the vertical spread of the wake at a given distance from the onset of far 
! wake condition
SUBROUTINE SIGMAZ_FUNC_BV(x, xb, x0, x0b, kz, kzb, rotor_diameter, &
& rotor_diameterb, sigmaz, sigmazb, nbdirs)
 !!  USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: kz, x, x0, rotor_diameter
  REAL(dp), DIMENSION(nbdirs) :: kzb, xb, x0b, rotor_diameterb
! out
  REAL(dp) :: sigmaz
  REAL(dp), DIMENSION(nbdirs) :: sigmazb
! load necessary intrinsic functions
  INTRINSIC SQRT
! vertical spread
  INTEGER :: nd
  INTEGER :: nbdirs
  DO nd=1,nbdirs
    kzb(nd) = kzb(nd) + (x-x0)*sigmazb(nd)
    xb(nd) = xb(nd) + kz*sigmazb(nd)
    x0b(nd) = x0b(nd) - kz*sigmazb(nd)
    rotor_diameterb(nd) = rotor_diameterb(nd) + sigmazb(nd)/SQRT(8.0_dp)
  END DO
END SUBROUTINE SIGMAZ_FUNC_BV

!  Differentiation of sigma_spread_func in reverse (adjoint) mode (with options multiDirectional i4 dr8 r4):
!   gradient     of useful results: k sigma_d x sigma_spread sigma_0
!                x0
!   with respect to varying inputs: k sigma_d x sigma_0 x0
SUBROUTINE SIGMA_SPREAD_FUNC_BV(x, xb, x0, x0b, k, kb, sigma_0, sigma_0b&
& , sigma_d, sigma_db, wec_spreading_angle, wec_factor, sigma_spread, &
& sigma_spreadb, nbdirs)
 !!  USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
!! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: x, x0, k, sigma_0, sigma_d, &
& wec_spreading_angle, wec_factor
  REAL(dp), DIMENSION(nbdirs) :: xb, x0b, kb, sigma_0b, sigma_db
! out
  REAL(dp) :: sigma_spread
  REAL(dp), DIMENSION(nbdirs) :: sigma_spreadb
! local
  REAL(dp) :: k_near_wake, sigma_0_new, k_spread
  REAL(dp), DIMENSION(nbdirs) :: k_near_wakeb, sigma_0_newb
  REAL(dp), PARAMETER :: pi=3.141592653589793_dp
  INTRINSIC TAN, ATAN
  INTEGER :: nd
  REAL(dp), DIMENSION(nbdirs) :: tempb
  REAL(dp), DIMENSION(nbdirs) :: tempb0
  REAL(dp), DIMENSION(nbdirs) :: tempb1
  INTEGER :: branch
  INTEGER :: nbdirs
! check if spreading angle is too high
  IF (wec_spreading_angle*pi/180.0_dp .GE. pi/2.0_dp) THEN
    STOP
  ELSE
! get slope of wake expansion in the near wake
    k_near_wake = (sigma_0-sigma_d)/x0
    k_spread = TAN(wec_spreading_angle*pi/180.0_dp)
    IF (k_spread .GT. k_near_wake) THEN
      k_near_wake = k_spread
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
! get new value for wake spread at the point of far wake onset
! get the wake spread at the point of interest
    IF (x .GE. x0 .AND. k .GT. k_near_wake) THEN
      DO nd=1,nbdirs
        tempb0(nd) = wec_factor*sigma_spreadb(nd)
        kb(nd) = kb(nd) + (x-x0)*tempb0(nd)
        xb(nd) = xb(nd) + k*tempb0(nd)
        x0b(nd) = x0b(nd) - k*tempb0(nd)
        sigma_0_newb(nd) = tempb0(nd)
      END DO
      k_near_wakeb(:) = 0.0_8
    ELSE
      IF (x .GE. 0.0_dp) THEN
        DO nd=1,nbdirs
          tempb1(nd) = wec_factor*sigma_spreadb(nd)
          k_near_wakeb(nd) = x*tempb1(nd)
          xb(nd) = xb(nd) + k_near_wake*tempb1(nd)
          sigma_db(nd) = sigma_db(nd) + tempb1(nd)
        END DO
      ELSE
        k_near_wakeb(:) = 0.0_8
      END IF
      sigma_0_newb(:) = 0.0_8
    END IF
    DO nd=1,nbdirs
      k_near_wakeb(nd) = k_near_wakeb(nd) + x0*sigma_0_newb(nd)
      x0b(nd) = x0b(nd) + k_near_wake*sigma_0_newb(nd)
      sigma_db(nd) = sigma_db(nd) + sigma_0_newb(nd)
    END DO
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) k_near_wakeb(:) = 0.0_8
    DO nd=1,nbdirs
      tempb(nd) = k_near_wakeb(nd)/x0
      sigma_0b(nd) = sigma_0b(nd) + tempb(nd)
      sigma_db(nd) = sigma_db(nd) - tempb(nd)
      x0b(nd) = x0b(nd) - (sigma_0-sigma_d)*tempb(nd)/x0
    END DO
  END IF
END SUBROUTINE SIGMA_SPREAD_FUNC_BV

!  Differentiation of wake_offset_func in reverse (adjoint) mode (with options multiDirectional i4 dr8 r4):
!   gradient     of useful results: yaw x sigmay sigmaz ky kz rotor_diameter
!                x0 wake_offset ct
!   with respect to varying inputs: theta_c_0 yaw x sigmay sigmaz
!                ky kz rotor_diameter x0 ct
! calculates the horizontal distance from the wake center to the hub of the turbine making
! the wake
SUBROUTINE WAKE_OFFSET_FUNC_BV(x, xb, rotor_diameter, rotor_diameterb, &
& theta_c_0, theta_c_0b, x0, x0b, yaw, yawb, ky, kyb, kz, kzb, ct, ctb, &
& sigmay, sigmayb, sigmaz, sigmazb, wake_offset, wake_offsetb, nbdirs)
 !!  USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: x, rotor_diameter, theta_c_0, x0, yaw, ky, kz&
& , ct, sigmay
  REAL(dp), DIMENSION(nbdirs) :: xb, rotor_diameterb, theta_c_0b, x0b&
& , yawb, kyb, kzb, ctb, sigmayb
  REAL(dp), INTENT(IN) :: sigmaz
  REAL(dp), DIMENSION(nbdirs) :: sigmazb
! local
  REAL(dp) :: a, b, c, d, e, f, g
  REAL(dp), DIMENSION(nbdirs) :: ab, bb, cb, db, eb, fb, gb
! out
  REAL(dp) :: wake_offset
  REAL(dp), DIMENSION(nbdirs) :: wake_offsetb
  INTRINSIC COS, SQRT, LOG
  INTEGER :: nd
  REAL(dp) :: temp
  REAL(dp) :: temp0
  REAL(dp) :: temp1
  REAL(dp) :: temp2
  REAL(dp) :: temp3
  REAL(dp) :: temp4
  REAL(dp) :: temp5
  REAL(dp) :: temp6
  REAL(dp) :: temp7
  REAL(dp) :: temp8
  REAL(dp) :: temp9
  REAL(dp), DIMENSION(nbdirs) :: tempb
  REAL(dp), DIMENSION(nbdirs) :: tempb0
  REAL(dp), DIMENSION(nbdirs) :: tempb1
  REAL(dp), DIMENSION(nbdirs) :: tempb2
  REAL(dp), DIMENSION(nbdirs) :: tempb3
  REAL(dp), DIMENSION(nbdirs) :: tempb4
  INTEGER :: nbdirs
  IF (x .LT. x0) THEN
    DO nd=1,nbdirs
      theta_c_0b(nd) = x*wake_offsetb(nd)
      xb(nd) = xb(nd) + theta_c_0*wake_offsetb(nd)
    END DO
  ELSE
    b = rotor_diameter*theta_c_0/14.7_dp
    c = SQRT(COS(yaw)/(ky*kz*ct))
    d = 2.9_dp + 1.3_dp*SQRT(1.0_dp-ct) - ct
    e = 1.6_dp*SQRT(8.0_dp*sigmay*sigmaz/(rotor_diameter**2*COS(yaw)))
    f = (1.6_dp+SQRT(ct))*(e-SQRT(ct))
    g = (1.6_dp-SQRT(ct))*(e+SQRT(ct))
    temp9 = f/g
    temp7 = SQRT(ct)
    temp8 = SQRT(ct)
    temp5 = SQRT(ct)
    temp6 = SQRT(ct)
    temp2 = COS(yaw)
    temp3 = rotor_diameter**2*temp2
    temp4 = sigmay*sigmaz/temp3
    temp = ky*kz*ct
    temp0 = COS(yaw)
    temp1 = temp0/temp
    DO nd=1,nbdirs
      tempb(nd) = LOG(temp9)*wake_offsetb(nd)
      tempb0(nd) = b*c*d*wake_offsetb(nd)/(temp9*g)
      ab(nd) = wake_offsetb(nd)
      bb(nd) = d*c*tempb(nd)
      cb(nd) = d*b*tempb(nd)
      db(nd) = b*c*tempb(nd)
      fb(nd) = tempb0(nd)
      gb(nd) = -(temp9*tempb0(nd))
      IF (.NOT.ct .EQ. 0.0) ctb(nd) = ctb(nd) + ((1.6_dp-temp8)/(2.0*&
&         temp7)-(e+temp7)/(2.0*temp8))*gb(nd)
      eb(nd) = (temp6+1.6_dp)*fb(nd) + (1.6_dp-temp8)*gb(nd)
      IF (.NOT.ct .EQ. 0.0) ctb(nd) = ctb(nd) + ((e-temp5)/(2.0*temp6)-(&
&         temp6+1.6_dp)/(2.0*temp5))*fb(nd)
      IF (8.0_dp*temp4 .EQ. 0.0) THEN
        tempb1(nd) = 0.0
      ELSE
        tempb1(nd) = 8.0_dp*1.6_dp*eb(nd)/(2.0*SQRT(8.0_dp*temp4)*temp3)
      END IF
      tempb2(nd) = -(temp4*tempb1(nd))
      sigmayb(nd) = sigmayb(nd) + sigmaz*tempb1(nd)
      sigmazb(nd) = sigmazb(nd) + sigmay*tempb1(nd)
      rotor_diameterb(nd) = rotor_diameterb(nd) + theta_c_0*bb(nd)/&
&       14.7_dp + temp2*2*rotor_diameter*tempb2(nd)
      IF (temp1 .EQ. 0.0) THEN
        tempb3(nd) = 0.0
      ELSE
        tempb3(nd) = cb(nd)/(2.0*SQRT(temp1)*temp)
      END IF
      yawb(nd) = yawb(nd) - SIN(yaw)*tempb3(nd) - rotor_diameter**2*SIN(&
&       yaw)*tempb2(nd)
      tempb4(nd) = -(temp1*tempb3(nd))
      IF (1.0_dp - ct .EQ. 0.0) THEN
        ctb(nd) = ctb(nd) + ky*kz*tempb4(nd) - db(nd)
      ELSE
        ctb(nd) = ctb(nd) + ky*kz*tempb4(nd) + ((-1.0)-1.3_dp/(2.0*SQRT(&
&         1.0_dp-ct)))*db(nd)
      END IF
      kyb(nd) = kyb(nd) + ct*kz*tempb4(nd)
      kzb(nd) = kzb(nd) + ct*ky*tempb4(nd)
      theta_c_0b(nd) = x0*ab(nd) + rotor_diameter*bb(nd)/14.7_dp
      x0b(nd) = x0b(nd) + theta_c_0*ab(nd)
    END DO
  END IF
END SUBROUTINE WAKE_OFFSET_FUNC_BV

!  Differentiation of deltav_func in reverse (adjoint) mode (with options multiDirectional i4 dr8 r4):
!   gradient     of useful results: k yaw rotor_diameter_ust deltav
!                ct
!   with respect to varying inputs: k yaw rotor_diameter_ust sigmay
!                sigmaz sigmay_spread deltax deltay deltaz sigmaz_spread
!                ct
! calculates the velocity difference between hub velocity and free stream for a given wake
! for use in the far wake region
SUBROUTINE DELTAV_FUNC_BV(deltay, deltayb, deltaz, deltazb, ct, ctb, yaw&
& , yawb, sigmay, sigmayb, sigmaz, sigmazb, rotor_diameter_ust, &
& rotor_diameter_ustb, version, k, kb, deltax, deltaxb, wec_factor, &
& sigmay_spread, sigmay_spreadb, sigmaz_spread, sigmaz_spreadb, deltav, &
& deltavb, nbdirs)
 !!  USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
!print *, "rotor_diameter in deltav exit", rotor_diameter_ust
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: deltay, deltaz, ct, yaw, sigmay
  REAL(dp), DIMENSION(nbdirs) :: deltayb, deltazb, ctb, yawb, sigmayb
  REAL(dp), INTENT(IN) :: sigmaz, rotor_diameter_ust, wec_factor, &
& sigmay_spread, sigmaz_spread
  REAL(dp), DIMENSION(nbdirs) :: sigmazb, rotor_diameter_ustb, &
& sigmay_spreadb, sigmaz_spreadb
! only for 2014 version
  REAL(dp), INTENT(IN) :: k, deltax
  REAL(dp), DIMENSION(nbdirs) :: kb, deltaxb
  INTEGER, INTENT(IN) :: version
! local
! only for 2014 version
  REAL(dp) :: beta_2014, epsilon_2014
  REAL(dp), DIMENSION(nbdirs) :: beta_2014b, epsilon_2014b
! out
  REAL(dp) :: deltav
  REAL(dp), DIMENSION(nbdirs) :: deltavb
! load intrinsic functions
  INTRINSIC COS, SQRT, EXP
  REAL(dp) :: temp
  REAL(dp) :: temp0
  REAL(dp) :: temp1
  REAL(dp) :: temp2
  REAL(dp) :: temp3
  REAL(dp) :: temp4
  REAL(dp) :: temp5
  REAL(dp) :: temp6
  REAL(dp) :: temp7
  REAL(dp) :: temp8
  REAL(dp) :: temp9
  REAL(dp) :: temp10
  REAL(dp) :: temp11
  REAL(dp) :: temp12
  INTEGER :: nd
  REAL(dp), DIMENSION(nbdirs) :: tempb
  REAL(dp), DIMENSION(nbdirs) :: tempb0
  REAL(dp), DIMENSION(nbdirs) :: tempb1
  REAL(dp), DIMENSION(nbdirs) :: tempb2
  REAL(dp), DIMENSION(nbdirs) :: tempb3
  REAL(dp), DIMENSION(nbdirs) :: tempb4
  REAL(dp), DIMENSION(nbdirs) :: tempb5
  REAL(dp), DIMENSION(nbdirs) :: tempb6
  REAL(dp), DIMENSION(nbdirs) :: tempb7
  REAL(dp) :: temp13
  REAL(dp) :: temp14
  REAL(dp) :: temp15
  REAL(dp) :: temp16
  REAL(dp) :: temp17
  REAL(dp) :: temp18
  REAL(dp) :: temp19
  REAL(dp) :: temp20
  REAL(dp) :: temp21
  REAL(dp) :: temp22
  REAL(dp) :: temp23
  REAL(dp), DIMENSION(nbdirs) :: tempb8
  REAL(dp), DIMENSION(nbdirs) :: tempb9
  REAL(dp), DIMENSION(nbdirs) :: tempb10
  REAL(dp), DIMENSION(nbdirs) :: tempb11
  REAL(dp), DIMENSION(nbdirs) :: tempb12
  INTEGER :: nbdirs
!print *, "rotor_diameter in deltav entry", rotor_diameter_ust
!     print *, 'wake model version in deltav: ', version
  IF (version .EQ. 2014) THEN
!print *, "in 2014 version"
    beta_2014 = 0.5_dp*(1.0_dp+SQRT(1.0_dp-ct))/SQRT(1.0_dp-ct)
    epsilon_2014 = 0.2_dp*SQRT(beta_2014)
! print *, "beta = ", beta_2014, "epsilon = ", epsilon_2014
! print *, "k, deltax: ", k, deltax
! print *, "term: ", Ct                                                   &
!                            / (8.0_dp * (k*deltax/rotor_diameter_ust+epsilon_2014)**2)
! print *, "deltav 2014 = ", deltav
    temp1 = k*deltax/rotor_diameter_ust
    temp2 = 2.0_dp*(temp1+epsilon_2014)**2
    temp3 = wec_factor*rotor_diameter_ust
    temp4 = deltay/temp3
    temp5 = wec_factor*rotor_diameter_ust
    temp6 = deltaz/temp5
    temp7 = temp6**2 + temp4**2
    temp8 = temp7/temp2
    temp9 = k*deltax/rotor_diameter_ust
    temp10 = 8.0_dp*(temp9+epsilon_2014)**2
    temp11 = ct/temp10
    temp12 = SQRT(-temp11 + 1.0_dp)
    temp = SQRT(-ct + 1.0_dp)
    temp0 = SQRT(-ct + 1.0_dp)
    DO nd=1,nbdirs
      IF (1.0_dp - temp11 .EQ. 0.0) THEN
        tempb(nd) = 0.0
      ELSE
        tempb(nd) = EXP(-temp8)*deltavb(nd)/(2.0*temp12*temp10)
      END IF
      tempb0(nd) = -(8.0_dp*temp11*2*(temp9+epsilon_2014)*tempb(nd))
      tempb1(nd) = tempb0(nd)/rotor_diameter_ust
      tempb2(nd) = -(EXP(-temp8)*(1.0_dp-temp12)*deltavb(nd)/temp2)
      tempb3(nd) = 2*temp6*tempb2(nd)/temp5
      tempb4(nd) = 2*temp4*tempb2(nd)/temp3
      tempb5(nd) = -(2.0_dp*temp8*2*(temp1+epsilon_2014)*tempb2(nd))
      tempb6(nd) = tempb5(nd)/rotor_diameter_ust
      ctb(nd) = ctb(nd) + tempb(nd)
      kb(nd) = kb(nd) + deltax*tempb6(nd) + deltax*tempb1(nd)
      deltaxb(nd) = k*tempb6(nd) + k*tempb1(nd)
      rotor_diameter_ustb(nd) = rotor_diameter_ustb(nd) - temp1*tempb6(&
&       nd) - temp4*wec_factor*tempb4(nd) - temp6*wec_factor*tempb3(nd) &
&       - temp9*tempb1(nd)
      epsilon_2014b(nd) = tempb5(nd) + tempb0(nd)
      deltazb(nd) = tempb3(nd)
      deltayb(nd) = tempb4(nd)
      IF (beta_2014 .EQ. 0.0) THEN
        beta_2014b(nd) = 0.0
      ELSE
        beta_2014b(nd) = 0.2_dp*epsilon_2014b(nd)/(2.0*SQRT(beta_2014))
      END IF
      tempb7(nd) = 0.5_dp*beta_2014b(nd)/temp
      IF (.NOT.1.0_dp - ct .EQ. 0.0) ctb(nd) = ctb(nd) + ((temp0+1.0_dp)&
&         /(2.0*temp**2)-1.0/(2.0*temp0))*tempb7(nd)
    END DO
    sigmayb(:) = 0.0_8
    sigmazb(:) = 0.0_8
    sigmay_spreadb(:) = 0.0_8
    sigmaz_spreadb(:) = 0.0_8
  ELSE IF (version .EQ. 2016) THEN
    temp13 = sigmaz_spread**2
    temp14 = deltaz**2/temp13
    temp15 = EXP(-(0.5_dp*temp14))
    temp16 = sigmay_spread**2
    temp17 = deltay**2/temp16
    temp18 = EXP(-(0.5_dp*temp17))
    temp19 = 8.0_dp*sigmay*sigmaz
    temp20 = ct*rotor_diameter_ust**2
    temp21 = temp20/temp19
    temp22 = COS(yaw)
    temp23 = SQRT(-(temp22*temp21) + 1.0_dp)
    DO nd=1,nbdirs
      IF (1.0_dp - temp22*temp21 .EQ. 0.0) THEN
        tempb8(nd) = 0.0
      ELSE
        tempb8(nd) = -(temp18*temp15*deltavb(nd)/(2.0*temp23))
      END IF
      tempb9(nd) = -(temp22*tempb8(nd)/temp19)
      tempb10(nd) = -(temp21*tempb9(nd))
      tempb11(nd) = -(0.5_dp*EXP(-(0.5_dp*temp17))*temp15*(1.0_dp-temp23&
&       )*deltavb(nd)/temp16)
      tempb12(nd) = -(0.5_dp*EXP(-(0.5_dp*temp14))*temp18*(1.0_dp-temp23&
&       )*deltavb(nd)/temp13)
      yawb(nd) = yawb(nd) + temp21*SIN(yaw)*tempb8(nd)
      ctb(nd) = ctb(nd) + rotor_diameter_ust**2*tempb9(nd)
      rotor_diameter_ustb(nd) = rotor_diameter_ustb(nd) + ct*2*&
&       rotor_diameter_ust*tempb9(nd)
      sigmayb(nd) = sigmaz*8.0_dp*tempb10(nd)
      sigmazb(nd) = 8.0_dp*sigmay*tempb10(nd)
      deltayb(nd) = 2*deltay*tempb11(nd)
      sigmay_spreadb(nd) = -(temp17*2*sigmay_spread*tempb11(nd))
      deltazb(nd) = 2*deltaz*tempb12(nd)
      sigmaz_spreadb(nd) = -(temp14*2*sigmaz_spread*tempb12(nd))
    END DO
    deltaxb(:) = 0.0_8
  ELSE
    STOP
  END IF
END SUBROUTINE DELTAV_FUNC_BV

!  Differentiation of deltav_near_wake_lin_func in reverse (adjoint) mode (with options multiDirectional i4 dr8 r4):
!   gradient     of useful results: k_2014 yaw rotor_diameter_ust
!                deltav ct
!   with respect to varying inputs: sigmay_d k_2014 yaw sigmaz_0
!                discontinuity_point x rotor_diameter_ust sigmay_0
!                sigmay_spread deltay deltaz sigmaz_d x0 sigmaz_spread
!                ct sigmaz_0_spread sigmay_0_spread
! calculates the velocity difference between hub velocity and free stream for a given wake
! for use in the near wake region only
SUBROUTINE DELTAV_NEAR_WAKE_LIN_FUNC_BV(deltay, deltayb, deltaz, deltazb&
& , ct, ctb, yaw, yawb, sigmay_0, sigmay_0b, sigmaz_0, sigmaz_0b, x0, &
& x0b, rotor_diameter_ust, rotor_diameter_ustb, x, xb, &
& discontinuity_point, discontinuity_pointb, sigmay_d, sigmay_db, &
& sigmaz_d, sigmaz_db, version, k_2014, k_2014b, deltaxd_2014, &
& sigmay_spread, sigmay_spreadb, sigmaz_spread, sigmaz_spreadb, &
& sigmay_0_spread, sigmay_0_spreadb, sigmaz_0_spread, sigmaz_0_spreadb, &
& wec_factor_2014, wech, deltav, deltavb, nbdirs)
 !!  USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: deltay, deltaz, ct, yaw, sigmay_0, sigmaz_0, &
& x0, sigmay_0_spread, sigmaz_0_spread
  REAL(dp), DIMENSION(nbdirs) :: deltayb, deltazb, ctb, yawb, &
& sigmay_0b, sigmaz_0b, x0b, sigmay_0_spreadb, sigmaz_0_spreadb
  REAL(dp), INTENT(IN) :: rotor_diameter_ust, sigmay_spread, &
& sigmaz_spread
  REAL(dp), DIMENSION(nbdirs) :: rotor_diameter_ustb, sigmay_spreadb&
& , sigmaz_spreadb
  REAL(dp), INTENT(IN) :: x, discontinuity_point, sigmay_d, sigmaz_d
  REAL(dp), DIMENSION(nbdirs) :: xb, discontinuity_pointb, sigmay_db&
& , sigmaz_db
! only for 2014 version
  REAL(dp), INTENT(IN) :: k_2014, deltaxd_2014, wec_factor_2014
  REAL(dp), DIMENSION(nbdirs) :: k_2014b
  INTEGER, INTENT(IN) :: version, wech
! local
  REAL(dp) :: deltav0m, deltavdm, sigmay, sigmaz
  REAL(dp), DIMENSION(nbdirs) :: deltav0mb, deltavdmb, sigmayb, &
& sigmazb
! only for 2014 version
  REAL(dp) :: beta_2014, epsilon_2014
  REAL(dp), DIMENSION(nbdirs) :: beta_2014b, epsilon_2014b
! out
  REAL(dp) :: deltav
  REAL(dp), DIMENSION(nbdirs) :: deltavb
! load intrinsic functions
  INTRINSIC COS, SQRT, EXP
  REAL(dp) :: temp
  REAL(dp) :: temp0
  REAL(dp) :: temp1
  REAL(dp) :: temp2
  REAL(dp) :: temp3
  REAL(dp) :: temp4
  REAL(dp) :: temp5
  REAL(dp) :: temp6
  REAL(dp) :: temp7
  REAL(dp) :: temp8
  REAL(dp) :: temp9
  REAL(dp) :: temp10
  REAL(dp) :: temp11
  REAL(dp) :: temp12
  REAL(dp) :: temp13
  INTEGER :: nd
  REAL(dp), DIMENSION(nbdirs) :: tempb
  REAL(dp), DIMENSION(nbdirs) :: tempb0
  REAL(dp), DIMENSION(nbdirs) :: tempb1
  REAL(dp), DIMENSION(nbdirs) :: tempb2
  REAL(dp), DIMENSION(nbdirs) :: tempb3
  REAL(dp), DIMENSION(nbdirs) :: tempb4
  REAL(dp), DIMENSION(nbdirs) :: tempb5
  REAL(dp), DIMENSION(nbdirs) :: tempb6
  REAL(dp), DIMENSION(nbdirs) :: tempb7
  REAL(dp), DIMENSION(nbdirs) :: tempb8
  REAL(dp), DIMENSION(nbdirs) :: tempb9
  REAL(dp), DIMENSION(nbdirs) :: tempb10
  REAL(dp), DIMENSION(nbdirs) :: tempb11
  REAL(dp), DIMENSION(nbdirs) :: tempb12
  REAL(dp) :: temp14
  REAL(dp) :: temp15
  REAL(dp) :: temp16
  REAL(dp) :: temp17
  REAL(dp) :: temp18
  REAL(dp) :: temp19
  REAL(dp) :: temp20
  REAL(dp) :: temp21
  REAL(dp), DIMENSION(nbdirs) :: tempb13
  REAL(dp), DIMENSION(nbdirs) :: tempb14
  REAL(dp), DIMENSION(nbdirs) :: tempb15
  REAL(dp), DIMENSION(nbdirs) :: tempb16
  REAL(dp), DIMENSION(nbdirs) :: tempb17
  REAL(dp), DIMENSION(nbdirs) :: tempb18
  REAL(dp) :: temp22
  REAL(dp) :: temp23
  REAL(dp) :: temp24
  REAL(dp) :: temp25
  REAL(dp) :: temp26
  REAL(dp) :: temp27
  REAL(dp) :: temp28
  REAL(dp), DIMENSION(nbdirs) :: tempb19
  REAL(dp), DIMENSION(nbdirs) :: tempb20
  REAL(dp), DIMENSION(nbdirs) :: tempb21
  REAL(dp), DIMENSION(nbdirs) :: tempb22
  REAL(dp), DIMENSION(nbdirs) :: tempb23
  REAL(dp) :: temp29
  REAL(dp) :: temp30
  REAL(dp) :: temp31
  REAL(dp) :: temp32
  REAL(dp) :: temp33
  REAL(dp) :: temp34
  REAL(dp) :: temp35
  REAL(dp) :: temp36
  REAL(dp) :: temp37
  REAL(dp), DIMENSION(nbdirs) :: tempb24
  REAL(dp), DIMENSION(nbdirs) :: tempb25
  REAL(dp), DIMENSION(nbdirs) :: tempb26
  REAL(dp), DIMENSION(nbdirs) :: tempb27
  REAL(dp), DIMENSION(nbdirs) :: tempb28
  REAL(dp), DIMENSION(nbdirs) :: tempb29
  REAL(dp), DIMENSION(nbdirs) :: tempb30
  INTEGER :: nbdirs
  IF (version .EQ. 2014) THEN
!TODO fix 2014 version
    IF (yaw .GT. 0.0_dp) THEN
      STOP
    ELSE
      beta_2014 = 0.5_dp*(1.0_dp+SQRT(1.0_dp-ct))/SQRT(1.0_dp-ct)
      epsilon_2014 = 0.2_dp*SQRT(beta_2014)
! magnitude term of gaussian at x0
      deltav0m = 1.0_dp - SQRT(1.0_dp - ct/(8.0_dp*(k_2014*x0/&
&       rotor_diameter_ust+epsilon_2014)**2))
! initialize the gaussian magnitude term at the rotor for the linear interpolation
      deltavdm = 1.0_dp - SQRT(1.0_dp - ct/(8.0_dp*(k_2014*&
&       discontinuity_point/rotor_diameter_ust+epsilon_2014)**2))
! linearized gaussian magnitude term for near wake
      temp5 = k_2014*x/rotor_diameter_ust
      temp6 = 2.0_dp*(temp5+epsilon_2014)**2
      temp7 = wec_factor_2014*rotor_diameter_ust
      temp8 = deltay/temp7
      temp9 = wec_factor_2014*rotor_diameter_ust
      temp10 = deltaz/temp9
      temp11 = temp10**2 + temp8**2
      temp12 = temp11/temp6
      temp13 = x/x0
      temp3 = k_2014*discontinuity_point/rotor_diameter_ust
      temp4 = 8.0_dp*(temp3+epsilon_2014)**2
      temp1 = k_2014*x0/rotor_diameter_ust
      temp2 = 8.0_dp*(temp1+epsilon_2014)**2
      temp = SQRT(-ct + 1.0_dp)
      temp0 = SQRT(-ct + 1.0_dp)
      DO nd=1,nbdirs
        tempb(nd) = EXP(-temp12)*deltavb(nd)
        tempb0(nd) = (deltav0m-deltavdm)*tempb(nd)/x0
        tempb1(nd) = -(EXP(-temp12)*((deltav0m-deltavdm)*temp13+deltavdm&
&         )*deltavb(nd)/temp6)
        tempb2(nd) = 2*temp10*tempb1(nd)/temp9
        tempb3(nd) = 2*temp8*tempb1(nd)/temp7
        tempb4(nd) = -(2.0_dp*temp12*2*(temp5+epsilon_2014)*tempb1(nd))
        tempb5(nd) = tempb4(nd)/rotor_diameter_ust
        deltav0mb(nd) = temp13*tempb(nd)
        deltavdmb(nd) = (1.0_8-temp13)*tempb(nd)
        xb(nd) = k_2014*tempb5(nd) + tempb0(nd)
        deltazb(nd) = tempb2(nd)
        deltayb(nd) = tempb3(nd)
        IF (1.0_dp - ct/temp4 .EQ. 0.0) THEN
          tempb10(nd) = 0.0
        ELSE
          tempb10(nd) = deltavdmb(nd)/(2.0*SQRT(1.0_dp-ct/temp4)*temp4)
        END IF
        tempb8(nd) = -(8.0_dp*ct*2*(temp3+epsilon_2014)*tempb10(nd)/&
&         temp4)
        tempb7(nd) = tempb8(nd)/rotor_diameter_ust
        discontinuity_pointb(nd) = k_2014*tempb7(nd)
        IF (1.0_dp - ct/temp2 .EQ. 0.0) THEN
          tempb11(nd) = 0.0
        ELSE
          tempb11(nd) = deltav0mb(nd)/(2.0*SQRT(1.0_dp-ct/temp2)*temp2)
        END IF
        ctb(nd) = ctb(nd) + tempb11(nd) + tempb10(nd)
        tempb9(nd) = -(8.0_dp*ct*2*(temp1+epsilon_2014)*tempb11(nd)/&
&         temp2)
        epsilon_2014b(nd) = tempb8(nd) + tempb9(nd) + tempb4(nd)
        tempb6(nd) = tempb9(nd)/rotor_diameter_ust
        x0b(nd) = k_2014*tempb6(nd) - temp13*tempb0(nd)
        rotor_diameter_ustb(nd) = rotor_diameter_ustb(nd) - temp3*tempb7&
&         (nd) - temp1*tempb6(nd) - temp5*tempb5(nd) - temp8*&
&         wec_factor_2014*tempb3(nd) - temp10*wec_factor_2014*tempb2(nd)
        k_2014b(nd) = k_2014b(nd) + discontinuity_point*tempb7(nd) + x0*&
&         tempb6(nd) + x*tempb5(nd)
        IF (beta_2014 .EQ. 0.0) THEN
          beta_2014b(nd) = 0.0
        ELSE
          beta_2014b(nd) = 0.2_dp*epsilon_2014b(nd)/(2.0*SQRT(beta_2014)&
&           )
        END IF
        tempb12(nd) = 0.5_dp*beta_2014b(nd)/temp
        IF (.NOT.1.0_dp - ct .EQ. 0.0) ctb(nd) = ctb(nd) + ((temp0+&
&           1.0_dp)/(2.0*temp**2)-1.0/(2.0*temp0))*tempb12(nd)
      END DO
      sigmay_db(:) = 0.0_8
      sigmaz_0b(:) = 0.0_8
      sigmay_0b(:) = 0.0_8
      sigmay_spreadb(:) = 0.0_8
      sigmaz_db(:) = 0.0_8
      sigmaz_spreadb(:) = 0.0_8
      sigmaz_0_spreadb(:) = 0.0_8
      sigmay_0_spreadb(:) = 0.0_8
    END IF
  ELSE IF (version .EQ. 2016) THEN
! magnitude term of gaussian at x0
    deltav0m = 1.0_dp - SQRT(1.0_dp - ct*COS(yaw)/(8.0_dp*sigmay_0*&
&     sigmaz_0/rotor_diameter_ust**2))
! initialize the gaussian magnitude term at the rotor for the linear interpolation
    deltavdm = 1.0_dp - SQRT(1.0_dp - ct*COS(yaw)/(8.0_dp*sigmay_d*&
&     sigmaz_d/rotor_diameter_ust**2))
    IF (wech .EQ. 0) THEN
      temp22 = sigmaz_spread**2
      temp23 = deltaz**2/temp22
      temp24 = sigmay_spread**2
      temp25 = deltay**2/temp24
      temp26 = EXP(-(0.5_dp*temp25))
      temp28 = x/x0
      temp27 = (deltav0m-deltavdm)*temp28 + deltavdm
      DO nd=1,nbdirs
        tempb19(nd) = EXP(-(0.5_dp*temp23))*deltavb(nd)
        tempb20(nd) = temp26*tempb19(nd)
        tempb21(nd) = (deltav0m-deltavdm)*tempb20(nd)/x0
        tempb22(nd) = -(0.5_dp*EXP(-(0.5_dp*temp25))*temp27*tempb19(nd)/&
&         temp24)
        tempb23(nd) = -(0.5_dp*EXP(-(0.5_dp*temp23))*temp27*temp26*&
&         deltavb(nd)/temp22)
        deltav0mb(nd) = temp28*tempb20(nd)
        deltavdmb(nd) = (1.0_8-temp28)*tempb20(nd)
        xb(nd) = tempb21(nd)
        x0b(nd) = -(temp28*tempb21(nd))
        deltayb(nd) = 2*deltay*tempb22(nd)
        sigmay_spreadb(nd) = -(temp25*2*sigmay_spread*tempb22(nd))
        deltazb(nd) = 2*deltaz*tempb23(nd)
        sigmaz_spreadb(nd) = -(temp23*2*sigmaz_spread*tempb23(nd))
      END DO
      sigmaz_0b(:) = 0.0_8
      sigmay_0b(:) = 0.0_8
      sigmaz_0_spreadb(:) = 0.0_8
      sigmay_0_spreadb(:) = 0.0_8
    ELSE
! linearized gaussian magnitude term for near wake for WECH
      sigmay = (sigmay_0_spread-sigmay_0)/x0*x + sigmay_0
      sigmaz = (sigmaz_0_spread-sigmay_0)/x0*x + sigmaz_0
      temp31 = sigmaz**2
      temp32 = deltaz**2/temp31
      temp33 = sigmay**2
      temp34 = deltay**2/temp33
      temp35 = EXP(-(0.5_dp*temp34))
      temp37 = x/x0
      temp36 = (deltav0m-deltavdm)*temp37 + deltavdm
      temp30 = x/x0
      temp29 = x/x0
      DO nd=1,nbdirs
        tempb24(nd) = EXP(-(0.5_dp*temp32))*deltavb(nd)
        tempb25(nd) = temp35*tempb24(nd)
        tempb26(nd) = (deltav0m-deltavdm)*tempb25(nd)/x0
        tempb27(nd) = -(0.5_dp*EXP(-(0.5_dp*temp34))*temp36*tempb24(nd)/&
&         temp33)
        tempb28(nd) = -(0.5_dp*EXP(-(0.5_dp*temp32))*temp36*temp35*&
&         deltavb(nd)/temp31)
        deltav0mb(nd) = temp37*tempb25(nd)
        deltavdmb(nd) = (1.0_8-temp37)*tempb25(nd)
        deltayb(nd) = 2*deltay*tempb27(nd)
        sigmayb(nd) = -(temp34*2*sigmay*tempb27(nd))
        deltazb(nd) = 2*deltaz*tempb28(nd)
        sigmazb(nd) = -(temp32*2*sigmaz*tempb28(nd))
        tempb29(nd) = (sigmaz_0_spread-sigmay_0)*sigmazb(nd)/x0
        sigmaz_0_spreadb(nd) = temp30*sigmazb(nd)
        sigmay_0b(nd) = (1.0_8-temp29)*sigmayb(nd) - temp30*sigmazb(nd)
        sigmaz_0b(nd) = sigmazb(nd)
        tempb30(nd) = (sigmay_0_spread-sigmay_0)*sigmayb(nd)/x0
        xb(nd) = tempb29(nd) + tempb30(nd) + tempb26(nd)
        x0b(nd) = -(temp30*tempb29(nd)) - temp29*tempb30(nd) - temp37*&
&         tempb26(nd)
        sigmay_0_spreadb(nd) = temp29*sigmayb(nd)
      END DO
      sigmay_spreadb(:) = 0.0_8
      sigmaz_spreadb(:) = 0.0_8
    END IF
    temp18 = 8.0_dp*sigmay_d*sigmaz_d
    temp19 = ct*rotor_diameter_ust**2
    temp20 = temp19/temp18
    temp21 = COS(yaw)
    temp14 = 8.0_dp*sigmay_0*sigmaz_0
    temp15 = ct*rotor_diameter_ust**2
    temp16 = temp15/temp14
    temp17 = COS(yaw)
    DO nd=1,nbdirs
      IF (1.0_dp - temp17*temp16 .EQ. 0.0) THEN
        tempb16(nd) = 0.0
      ELSE
        tempb16(nd) = -(deltav0mb(nd)/(2.0*SQRT(1.0_dp-temp17*temp16)))
      END IF
      tempb17(nd) = -(temp17*tempb16(nd)/temp14)
      IF (1.0_dp - temp21*temp20 .EQ. 0.0) THEN
        tempb13(nd) = 0.0
      ELSE
        tempb13(nd) = -(deltavdmb(nd)/(2.0*SQRT(1.0_dp-temp21*temp20)))
      END IF
      tempb14(nd) = -(temp21*tempb13(nd)/temp18)
      tempb15(nd) = -(temp20*tempb14(nd))
      yawb(nd) = yawb(nd) + temp16*SIN(yaw)*tempb16(nd) + temp20*SIN(yaw&
&       )*tempb13(nd)
      ctb(nd) = ctb(nd) + rotor_diameter_ust**2*tempb17(nd) + &
&       rotor_diameter_ust**2*tempb14(nd)
      rotor_diameter_ustb(nd) = rotor_diameter_ustb(nd) + ct*2*&
&       rotor_diameter_ust*tempb17(nd) + ct*2*rotor_diameter_ust*tempb14&
&       (nd)
      sigmay_db(nd) = sigmaz_d*8.0_dp*tempb15(nd)
      sigmaz_db(nd) = 8.0_dp*sigmay_d*tempb15(nd)
      tempb18(nd) = -(temp16*tempb17(nd))
      sigmay_0b(nd) = sigmay_0b(nd) + sigmaz_0*8.0_dp*tempb18(nd)
      sigmaz_0b(nd) = sigmaz_0b(nd) + 8.0_dp*sigmay_0*tempb18(nd)
    END DO
    discontinuity_pointb(:) = 0.0_8
  ELSE
    STOP
  END IF
END SUBROUTINE DELTAV_NEAR_WAKE_LIN_FUNC_BV

!  Differentiation of wake_combination_func in reverse (adjoint) mode (with options multiDirectional i4 dr8 r4):
!   gradient     of useful results: turb_inflow new_deficit_sum
!   with respect to varying inputs: turb_inflow old_deficit_sum
!                deltav
! combines wakes using various methods
SUBROUTINE WAKE_COMBINATION_FUNC_BV(wind_speed, turb_inflow, &
& turb_inflowb, deltav, deltavb, wake_combination_method, &
& old_deficit_sum, old_deficit_sumb, new_deficit_sum, new_deficit_sumb, &
& nbdirs)
 !!  USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: wind_speed, turb_inflow, deltav, &
& old_deficit_sum
  REAL(dp), DIMENSION(nbdirs) :: turb_inflowb, deltavb, &
& old_deficit_sumb
  INTEGER, INTENT(IN) :: wake_combination_method
! out    
  REAL(dp) :: new_deficit_sum
  REAL(dp), DIMENSION(nbdirs) :: new_deficit_sumb
! intrinsic functions
  INTRINSIC SQRT
  INTEGER :: nd
  REAL(dp), DIMENSION(nbdirs) :: tempb
  REAL(dp), DIMENSION(nbdirs) :: tempb0
  REAL(dp), DIMENSION(nbdirs) :: tempb1
  INTEGER :: nbdirs
! freestream linear superposition (Lissaman 1979)
  IF (wake_combination_method .EQ. 0) THEN
    DO nd=1,nbdirs
      old_deficit_sumb(nd) = new_deficit_sumb(nd)
      deltavb(nd) = wind_speed*new_deficit_sumb(nd)
    END DO
  ELSE IF (wake_combination_method .EQ. 1) THEN
    DO nd=1,nbdirs
      old_deficit_sumb(nd) = new_deficit_sumb(nd)
      turb_inflowb(nd) = turb_inflowb(nd) + deltav*new_deficit_sumb(nd)
      deltavb(nd) = turb_inflow*new_deficit_sumb(nd)
    END DO
  ELSE IF (wake_combination_method .EQ. 2) THEN
    DO nd=1,nbdirs
      IF (old_deficit_sum**2 + (wind_speed*deltav)**2 .EQ. 0.0) THEN
        tempb(nd) = 0.0
      ELSE
        tempb(nd) = new_deficit_sumb(nd)/(2.0*SQRT(old_deficit_sum**2+(&
&         wind_speed*deltav)**2))
      END IF
      old_deficit_sumb(nd) = 2*old_deficit_sum*tempb(nd)
      deltavb(nd) = 2*wind_speed**2*deltav*tempb(nd)
    END DO
  ELSE IF (wake_combination_method .EQ. 3) THEN
    DO nd=1,nbdirs
      IF (old_deficit_sum**2 + (turb_inflow*deltav)**2 .EQ. 0.0) THEN
        tempb0(nd) = 0.0
      ELSE
        tempb0(nd) = new_deficit_sumb(nd)/(2.0*SQRT(old_deficit_sum**2+(&
&         turb_inflow*deltav)**2))
      END IF
      tempb1(nd) = 2*turb_inflow*deltav*tempb0(nd)
      old_deficit_sumb(nd) = 2*old_deficit_sum*tempb0(nd)
      turb_inflowb(nd) = turb_inflowb(nd) + deltav*tempb1(nd)
      deltavb(nd) = turb_inflow*tempb1(nd)
    END DO
  ELSE
    STOP
  END IF
END SUBROUTINE WAKE_COMBINATION_FUNC_BV

!  Differentiation of added_ti_func in reverse (adjoint) mode (with options multiDirectional i4 dr8 r4):
!   gradient     of useful results: k_star_ust rotor_diameter_ust
!                wake_height turbine_height ti_dst ct_ust ti_area_ratio
!                rotor_diameter_dst
!   with respect to varying inputs: k_star_ust x rotor_diameter_ust
!                wake_height turbine_height ti_dst_in ct_ust deltay
!                ti_area_ratio_in rotor_diameter_dst ti_ust
! combines wakes using various methods
SUBROUTINE ADDED_TI_FUNC_BV(ti, ct_ust, ct_ustb, x, xb, k_star_ust, &
& k_star_ustb, rotor_diameter_ust, rotor_diameter_ustb, &
& rotor_diameter_dst, rotor_diameter_dstb, deltay, deltayb, wake_height&
& , wake_heightb, turbine_height, turbine_heightb, sm_smoothing, ti_ust&
& , ti_ustb, ti_calculation_method, ti_area_ratio_in, ti_area_ratio_inb&
& , ti_dst_in, ti_dst_inb, ti_area_ratio, ti_area_ratiob, ti_dst, &
& ti_dstb, nbdirs)
 !!  USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
!print *, "ratio: ", wake_overlap/rotor_area_dst
!print *, "Dr, Dw: ", rotor_diameter_dst, wake_diameter
!print *, "Ar, Aol: ", rotor_area_dst, wake_overlap          
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: ct_ust, x, k_star_ust, rotor_diameter_ust, &
& rotor_diameter_dst
  REAL(dp), DIMENSION(nbdirs) :: ct_ustb, xb, k_star_ustb, &
& rotor_diameter_ustb, rotor_diameter_dstb
  REAL(dp), INTENT(IN) :: deltay, wake_height, turbine_height, &
& sm_smoothing
  REAL(dp), DIMENSION(nbdirs) :: deltayb, wake_heightb, &
& turbine_heightb
  REAL(dp), INTENT(IN) :: ti_ust, ti, ti_area_ratio_in, ti_dst_in
  REAL(dp), DIMENSION(nbdirs) :: ti_ustb, ti_area_ratio_inb, &
& ti_dst_inb
  INTEGER, INTENT(IN) :: ti_calculation_method
! local
  REAL(dp) :: axial_induction_ust, beta, epsilon, sigma, wake_diameter, &
& wake_overlap
  REAL(dp), DIMENSION(nbdirs) :: axial_induction_ustb, betab, &
& epsilonb, sigmab, wake_diameterb, wake_overlapb
  REAL(dp) :: ti_added, ti_tmp, rotor_area_dst, ti_area_ratio_tmp
  REAL(dp), DIMENSION(nbdirs) :: ti_addedb, ti_tmpb, rotor_area_dstb&
& , ti_area_ratio_tmpb
  REAL(dp), PARAMETER :: pi=3.141592653589793_dp
! out  
  REAL(dp) :: ti_dst, ti_area_ratio
  REAL(dp), DIMENSION(nbdirs) :: ti_dstb, ti_area_ratiob
! intrinsic functions
  INTRINSIC SQRT
  INTEGER :: nd
  REAL(dp) :: temp
  REAL(dp) :: temp0
  REAL(dp) :: temp1
  REAL(dp) :: temp2
  REAL(dp) :: temp3
  REAL(dp) :: temp4
  REAL(dp), DIMENSION(nbdirs) :: tempb
  REAL(dp), DIMENSION(nbdirs) :: tempb0
  REAL(dp), DIMENSION(nbdirs) :: tempb1
  REAL(dp), DIMENSION(nbdirs) :: tempb2
  REAL(dp), DIMENSION(nbdirs) :: tempb3
  REAL(dp) :: temp5
  REAL(dp) :: temp6
  REAL(dp) :: temp7
  REAL(dp) :: temp8
  REAL(dp) :: temp9
  REAL(dp) :: temp10
  REAL(dp), DIMENSION(nbdirs) :: tempb4
  REAL(dp), DIMENSION(nbdirs) :: tempb5
  REAL(dp), DIMENSION(nbdirs) :: tempb6
  REAL(dp), DIMENSION(nbdirs) :: tempb7
  REAL(dp) :: temp11
  REAL(dp) :: temp12
  REAL(dp) :: temp13
  REAL(dp) :: temp14
  REAL(dp) :: temp15
  REAL(dp) :: temp16
  REAL(dp), DIMENSION(nbdirs) :: tempb8
  REAL(dp), DIMENSION(nbdirs) :: tempb9
  REAL(dp), DIMENSION(nbdirs) :: tempb10
  REAL(dp), DIMENSION(nbdirs) :: tempb11
  REAL(dp) :: temp17
  REAL(dp) :: temp18
  REAL(dp) :: temp19
  REAL(dp) :: temp20
  REAL(dp) :: temp21
  REAL(dp), DIMENSION(nbdirs) :: tempb12
  REAL(dp), DIMENSION(nbdirs) :: tempb13
  REAL(dp), DIMENSION(nbdirs) :: tempb14
  REAL(dp), DIMENSION(nbdirs) :: tempb15
  REAL(dp) :: temp22
  REAL(dp) :: temp23
  REAL(dp), DIMENSION(nbdirs) :: tempb16
  REAL(dp) :: temp24
  REAL(dp) :: temp25
  REAL(dp) :: temp26
  REAL(dp), DIMENSION(nbdirs) :: tempb17
  REAL(dp), DIMENSION(nbdirs) :: tempb18
  REAL(dp), DIMENSION(nbdirs) :: tempb19
  INTEGER :: nbdirs
! initialize output variables
! initialize wake overlap to zero
!print *, "TI_dst in: ", TI_dst
! Niayifar and Porte Agel 2015, 2016 (adjusted by Annoni and Thomas for SOWFA match 
! and optimization)
  IF (ti_calculation_method .EQ. 1) THEN
! calculate axial induction based on the Ct value
    CALL CT_TO_AXIAL_IND_FUNC(ct_ust, axial_induction_ust)
! calculate BPA spread parameters Bastankhah and Porte Agel 2014
    beta = 0.5_dp*((1.0_dp+SQRT(1.0_dp-ct_ust))/SQRT(1.0_dp-ct_ust))
    epsilon = 0.2_dp*SQRT(beta)
!print *, "epsilon = ", epsilon
! calculate wake spread for TI calcs
    sigma = k_star_ust*x + rotor_diameter_ust*epsilon
    wake_diameter = 4.0_dp*sigma
!print *, "sigma = ", sigma
! calculate wake overlap ratio
    CALL OVERLAP_AREA_FUNC(deltay, turbine_height, rotor_diameter_dst, &
&                    0.0_dp, wake_height, wake_diameter, wake_overlap)
!print *, "wake_overlap = ", wake_overlap   
! Calculate the turbulence added to the inflow of the downstream turbine by the 
! wake of the upstream turbine
    ti_added = 0.73_dp*axial_induction_ust**0.8325_dp*ti_ust**0.0325_dp*&
&     (x/rotor_diameter_ust)**(-0.32_dp)
!print *, "TI_added = ", TI_added
    rotor_area_dst = 0.25_dp*pi*rotor_diameter_dst**2_dp
! Calculate the total turbulence intensity at the downstream turbine
!sum_of_squares = TI_dst**2 + (TI_added*wake_overlap)**2
! print *, "sum of squares = ", sum_of_squares
!         TI_dst = sqrt(sum_of_squares)
!         !print *, "TI_dst = ", TI_dst
! Niayifar and Porte Agel 2015, 2016
    temp4 = ti_added*wake_overlap/rotor_area_dst
    temp1 = x/rotor_diameter_ust
    temp2 = ti_ust**0.0325_dp
    temp3 = axial_induction_ust**0.8325_dp
    temp = SQRT(-ct_ust + 1.0_dp)
    temp0 = SQRT(-ct_ust + 1.0_dp)
    DO nd=1,nbdirs
      IF (ti_dst_in**2.0_dp + temp4**2.0_dp .EQ. 0.0) THEN
        tempb(nd) = 0.0
      ELSE
        tempb(nd) = ti_dstb(nd)/(2.0*SQRT(ti_dst_in**2.0_dp+temp4**&
&         2.0_dp))
      END IF
      tempb0(nd) = 2.0_dp*temp4*tempb(nd)/rotor_area_dst
      ti_dst_inb(nd) = 2.0_dp*ti_dst_in*tempb(nd)
      ti_addedb(nd) = wake_overlap*tempb0(nd)
      wake_overlapb(nd) = ti_added*tempb0(nd)
      rotor_area_dstb(nd) = -(temp4*tempb0(nd))
      rotor_diameter_dstb(nd) = rotor_diameter_dstb(nd) + pi*0.25_dp*&
&       2_dp*rotor_diameter_dst*rotor_area_dstb(nd)
      tempb1(nd) = 0.73_dp*temp1**(-0.32_dp)*ti_addedb(nd)
      tempb2(nd) = -(0.32_dp*temp1**(-1.32)*temp3*temp2*0.73_dp*&
&       ti_addedb(nd)/rotor_diameter_ust)
      axial_induction_ustb(nd) = temp2*0.8325_dp*axial_induction_ust**(&
&       -0.1675)*tempb1(nd)
      ti_ustb(nd) = temp3*0.0325_dp*ti_ust**(-0.9675)*tempb1(nd)
    END DO
    CALL OVERLAP_AREA_FUNC_BV(deltay, deltayb, turbine_height, &
&                       turbine_heightb, rotor_diameter_dst, &
&                       rotor_diameter_dstb, 0.0_dp, wake_height, &
&                       wake_heightb, wake_diameter, wake_diameterb, &
&                       wake_overlap, wake_overlapb, nbdirs)
    DO nd=1,nbdirs
      sigmab(nd) = 4.0_dp*wake_diameterb(nd)
      xb(nd) = k_star_ust*sigmab(nd) + tempb2(nd)
      rotor_diameter_ustb(nd) = rotor_diameter_ustb(nd) + epsilon*sigmab&
&       (nd) - temp1*tempb2(nd)
      k_star_ustb(nd) = k_star_ustb(nd) + x*sigmab(nd)
      epsilonb(nd) = rotor_diameter_ust*sigmab(nd)
      IF (beta .EQ. 0.0) THEN
        betab(nd) = 0.0
      ELSE
        betab(nd) = 0.2_dp*epsilonb(nd)/(2.0*SQRT(beta))
      END IF
      tempb3(nd) = 0.5_dp*betab(nd)/temp
      IF (.NOT.1.0_dp - ct_ust .EQ. 0.0) ct_ustb(nd) = ct_ustb(nd) + ((&
&         temp0+1.0_dp)/(2.0*temp**2)-1.0/(2.0*temp0))*tempb3(nd)
    END DO
    CALL CT_TO_AXIAL_IND_FUNC_BV(ct_ust, ct_ustb, axial_induction_ust, &
&                          axial_induction_ustb, nbdirs)
    ti_dstb(:) = 0.0_8
    ti_area_ratio_inb(:) = 0.0_8
  ELSE IF (ti_calculation_method .EQ. 2) THEN
! calculate axial induction based on the Ct value
    CALL CT_TO_AXIAL_IND_FUNC(ct_ust, axial_induction_ust)
! calculate BPA spread parameters Bastankhah and Porte Agel 2014
    beta = 0.5_dp*((1.0_dp+SQRT(1.0_dp-ct_ust))/SQRT(1.0_dp-ct_ust))
    epsilon = 0.2_dp*SQRT(beta)
! calculate wake spread for TI calcs
    sigma = k_star_ust*x + rotor_diameter_ust*epsilon
    wake_diameter = 4.0_dp*sigma
! calculate wake overlap ratio
    CALL OVERLAP_AREA_FUNC(deltay, turbine_height, rotor_diameter_dst, &
&                    0.0_dp, wake_height, wake_diameter, wake_overlap)
! Calculate the turbulence added to the inflow of the downstream turbine by the 
! wake of the upstream turbine
    ti_added = 0.73_dp*axial_induction_ust**0.8325_dp*ti_ust**0.0325_dp*&
&     (x/rotor_diameter_ust)**(-0.32_dp)
! Calculate the total turbulence intensity at the downstream turbine based on 
! current upstream turbine
    rotor_area_dst = 0.25_dp*pi*rotor_diameter_dst**2_dp
    ti_tmp = SQRT(ti**2.0_dp + (ti_added*(wake_overlap/rotor_area_dst))&
&     **2.0_dp)
! Check if this is the max and use it if it is
    IF (ti_tmp .GT. ti_dst_in) THEN
      DO nd=1,nbdirs
        ti_tmpb(nd) = ti_dstb(nd)
      END DO
      ti_dstb(:) = 0.0_8
    ELSE
      ti_tmpb(:) = 0.0_8
    END IF
    temp10 = ti_added*wake_overlap/rotor_area_dst
    temp7 = x/rotor_diameter_ust
    temp8 = ti_ust**0.0325_dp
    temp9 = axial_induction_ust**0.8325_dp
    temp5 = SQRT(-ct_ust + 1.0_dp)
    temp6 = SQRT(-ct_ust + 1.0_dp)
    DO nd=1,nbdirs
      IF (ti**2.0_dp + temp10**2.0_dp .EQ. 0.0) THEN
        tempb4(nd) = 0.0
      ELSE
        tempb4(nd) = 2.0_dp*temp10*ti_tmpb(nd)/(2.0*SQRT(ti**2.0_dp+&
&         temp10**2.0_dp)*rotor_area_dst)
      END IF
      ti_addedb(nd) = wake_overlap*tempb4(nd)
      wake_overlapb(nd) = ti_added*tempb4(nd)
      rotor_area_dstb(nd) = -(temp10*tempb4(nd))
      rotor_diameter_dstb(nd) = rotor_diameter_dstb(nd) + pi*0.25_dp*&
&       2_dp*rotor_diameter_dst*rotor_area_dstb(nd)
      tempb5(nd) = 0.73_dp*temp7**(-0.32_dp)*ti_addedb(nd)
      tempb6(nd) = -(0.32_dp*temp7**(-1.32)*temp9*temp8*0.73_dp*&
&       ti_addedb(nd)/rotor_diameter_ust)
      axial_induction_ustb(nd) = temp8*0.8325_dp*axial_induction_ust**(&
&       -0.1675)*tempb5(nd)
      ti_ustb(nd) = temp9*0.0325_dp*ti_ust**(-0.9675)*tempb5(nd)
    END DO
    CALL OVERLAP_AREA_FUNC_BV(deltay, deltayb, turbine_height, &
&                       turbine_heightb, rotor_diameter_dst, &
&                       rotor_diameter_dstb, 0.0_dp, wake_height, &
&                       wake_heightb, wake_diameter, wake_diameterb, &
&                       wake_overlap, wake_overlapb, nbdirs)
    DO nd=1,nbdirs
      sigmab(nd) = 4.0_dp*wake_diameterb(nd)
      xb(nd) = k_star_ust*sigmab(nd) + tempb6(nd)
      rotor_diameter_ustb(nd) = rotor_diameter_ustb(nd) + epsilon*sigmab&
&       (nd) - temp7*tempb6(nd)
      k_star_ustb(nd) = k_star_ustb(nd) + x*sigmab(nd)
      epsilonb(nd) = rotor_diameter_ust*sigmab(nd)
      IF (beta .EQ. 0.0) THEN
        betab(nd) = 0.0
      ELSE
        betab(nd) = 0.2_dp*epsilonb(nd)/(2.0*SQRT(beta))
      END IF
      tempb7(nd) = 0.5_dp*betab(nd)/temp5
      IF (.NOT.1.0_dp - ct_ust .EQ. 0.0) ct_ustb(nd) = ct_ustb(nd) + ((&
&         temp6+1.0_dp)/(2.0*temp5**2)-1.0/(2.0*temp6))*tempb7(nd)
    END DO
    CALL CT_TO_AXIAL_IND_FUNC_BV(ct_ust, ct_ustb, axial_induction_ust, &
&                          axial_induction_ustb, nbdirs)
    ti_dst_inb(:) = 0.0_8
    ti_area_ratio_inb(:) = 0.0_8
  ELSE IF (ti_calculation_method .EQ. 3) THEN
! Niayifar and Porte Agel 2015, 2016 with smooth max
! calculate axial induction based on the Ct value
    CALL CT_TO_AXIAL_IND_FUNC(ct_ust, axial_induction_ust)
! calculate BPA spread parameters Bastankhah and Porte Agel 2014
    beta = 0.5_dp*((1.0_dp+SQRT(1.0_dp-ct_ust))/SQRT(1.0_dp-ct_ust))
    epsilon = 0.2_dp*SQRT(beta)
! calculate wake spread for TI calcs
    sigma = k_star_ust*x + rotor_diameter_ust*epsilon
    wake_diameter = 4.0_dp*sigma
!         print *, "sigma, k_star_ust, x, rotor_diameter_ust, epsilon ", sigma, k_star_ust, x, rotor_diameter_ust, epsilon
! print *, "deltay, turbine_height, rotor_diameter_dst, wake_height, wake_diameter", &
!                 & deltay, turbine_height, rotor_diameter_dst, &
!                             wake_height, wake_diameter
! calculate wake overlap ratio
    CALL OVERLAP_AREA_FUNC(deltay, turbine_height, rotor_diameter_dst, &
&                    0.0_dp, wake_height, wake_diameter, wake_overlap)
! Calculate the turbulence added to the inflow of the downstream turbine by the 
! wake of the upstream turbine
    ti_added = 0.73_dp*axial_induction_ust**0.8325_dp*ti_ust**0.0325_dp*&
&     (x/rotor_diameter_ust)**(-0.32_dp)
! Calculate the total turbulence intensity at the downstream turbine based on 
! current upstream turbine
    rotor_area_dst = 0.25_dp*pi*rotor_diameter_dst**2_dp
    ti_tmp = SQRT(ti**2.0_dp + (ti_added*(wake_overlap/rotor_area_dst))&
&     **2.0_dp)
!print *, "TI, TI_added, wake_overlap, rotor_area_dst: ", TI, TI_added, wake_overlap, rotor_area_dst
! Check if this is the max and use it if it is
!if (TI_tmp > TI_dst) then
!    TI_dst = TI_tmp
!end if
!         print *, "before: ", TI_dst, TI_tmp
!         TI_dst_in = TI_dst
!         print *, "after:: ", TI_dst, TI_tmp
! Niayifar and Porte Agel 2015, 2016 using max on area TI ratio
    CALL SMOOTH_MAX_BV(sm_smoothing, ti_dst_in, ti_dst_inb, ti_tmp, &
&                ti_tmpb, ti_dst, ti_dstb, nbdirs)
    temp16 = ti_added*wake_overlap/rotor_area_dst
    temp13 = x/rotor_diameter_ust
    temp14 = ti_ust**0.0325_dp
    temp15 = axial_induction_ust**0.8325_dp
    temp11 = SQRT(-ct_ust + 1.0_dp)
    temp12 = SQRT(-ct_ust + 1.0_dp)
    DO nd=1,nbdirs
      IF (ti**2.0_dp + temp16**2.0_dp .EQ. 0.0) THEN
        tempb8(nd) = 0.0
      ELSE
        tempb8(nd) = 2.0_dp*temp16*ti_tmpb(nd)/(2.0*SQRT(ti**2.0_dp+&
&         temp16**2.0_dp)*rotor_area_dst)
      END IF
      ti_addedb(nd) = wake_overlap*tempb8(nd)
      wake_overlapb(nd) = ti_added*tempb8(nd)
      rotor_area_dstb(nd) = -(temp16*tempb8(nd))
      rotor_diameter_dstb(nd) = rotor_diameter_dstb(nd) + pi*0.25_dp*&
&       2_dp*rotor_diameter_dst*rotor_area_dstb(nd)
      tempb9(nd) = 0.73_dp*temp13**(-0.32_dp)*ti_addedb(nd)
      tempb10(nd) = -(0.32_dp*temp13**(-1.32)*temp15*temp14*0.73_dp*&
&       ti_addedb(nd)/rotor_diameter_ust)
      axial_induction_ustb(nd) = temp14*0.8325_dp*axial_induction_ust**(&
&       -0.1675)*tempb9(nd)
      ti_ustb(nd) = temp15*0.0325_dp*ti_ust**(-0.9675)*tempb9(nd)
    END DO
    CALL OVERLAP_AREA_FUNC_BV(deltay, deltayb, turbine_height, &
&                       turbine_heightb, rotor_diameter_dst, &
&                       rotor_diameter_dstb, 0.0_dp, wake_height, &
&                       wake_heightb, wake_diameter, wake_diameterb, &
&                       wake_overlap, wake_overlapb, nbdirs)
    DO nd=1,nbdirs
      sigmab(nd) = 4.0_dp*wake_diameterb(nd)
      xb(nd) = k_star_ust*sigmab(nd) + tempb10(nd)
      rotor_diameter_ustb(nd) = rotor_diameter_ustb(nd) + epsilon*sigmab&
&       (nd) - temp13*tempb10(nd)
      k_star_ustb(nd) = k_star_ustb(nd) + x*sigmab(nd)
      epsilonb(nd) = rotor_diameter_ust*sigmab(nd)
      IF (beta .EQ. 0.0) THEN
        betab(nd) = 0.0
      ELSE
        betab(nd) = 0.2_dp*epsilonb(nd)/(2.0*SQRT(beta))
      END IF
      tempb11(nd) = 0.5_dp*betab(nd)/temp11
      IF (.NOT.1.0_dp - ct_ust .EQ. 0.0) ct_ustb(nd) = ct_ustb(nd) + ((&
&         temp12+1.0_dp)/(2.0*temp11**2)-1.0/(2.0*temp12))*tempb11(nd)
    END DO
    CALL CT_TO_AXIAL_IND_FUNC_BV(ct_ust, ct_ustb, axial_induction_ust, &
&                          axial_induction_ustb, nbdirs)
    ti_dstb(:) = 0.0_8
    ti_area_ratio_inb(:) = 0.0_8
  ELSE
    IF (ti_calculation_method .EQ. 4) THEN
! calculate axial induction based on the Ct value
      CALL CT_TO_AXIAL_IND_FUNC(ct_ust, axial_induction_ust)
! calculate BPA spread parameters Bastankhah and Porte Agel 2014
      beta = 0.5_dp*((1.0_dp+SQRT(1.0_dp-ct_ust))/SQRT(1.0_dp-ct_ust))
      epsilon = 0.2_dp*SQRT(beta)
! calculate wake spread for TI calcs
      sigma = k_star_ust*x + rotor_diameter_ust*epsilon
      wake_diameter = 4.0_dp*sigma
! calculate wake overlap ratio
      CALL OVERLAP_AREA_FUNC(deltay, turbine_height, rotor_diameter_dst&
&                      , 0.0_dp, wake_height, wake_diameter, &
&                      wake_overlap)
! Calculate the turbulence added to the inflow of the downstream turbine by the 
! wake of the upstream turbine
      ti_added = 0.73_dp*axial_induction_ust**0.8325_dp*ti_ust**&
&       0.0325_dp*(x/rotor_diameter_ust)**(-0.32_dp)
! Calculate the total turbulence intensity at the downstream turbine based on 
! current upstream turbine
      rotor_area_dst = 0.25_dp*pi*rotor_diameter_dst**2_dp
      ti_area_ratio_tmp = ti_added*(wake_overlap/rotor_area_dst)
! Check if this is the max and use it if it is
      IF (ti_area_ratio_tmp .GT. ti_area_ratio_in) THEN
!            print *, "ti_area_ratio_tmp > ti_area_ratio"
!TI_dst = TI_tmp
        ti_area_ratio = ti_area_ratio_tmp
        DO nd=1,nbdirs
          IF (.NOT.ti**2.0_dp + ti_area_ratio**2.0_dp .EQ. 0.0) &
&           ti_area_ratiob(nd) = ti_area_ratiob(nd) + 2.0_dp*&
&             ti_area_ratio*ti_dstb(nd)/(2.0*SQRT(ti**2.0_dp+&
&             ti_area_ratio**2.0_dp))
          ti_area_ratio_tmpb(nd) = ti_area_ratiob(nd)
        END DO
        ti_dstb(:) = 0.0_8
        ti_area_ratiob(:) = 0.0_8
      ELSE
        ti_area_ratio_tmpb(:) = 0.0_8
      END IF
      temp19 = x/rotor_diameter_ust
      temp20 = ti_ust**0.0325_dp
      temp21 = axial_induction_ust**0.8325_dp
      temp17 = SQRT(-ct_ust + 1.0_dp)
      temp18 = SQRT(-ct_ust + 1.0_dp)
      DO nd=1,nbdirs
        tempb12(nd) = ti_area_ratio_tmpb(nd)/rotor_area_dst
        ti_addedb(nd) = wake_overlap*tempb12(nd)
        wake_overlapb(nd) = ti_added*tempb12(nd)
        rotor_area_dstb(nd) = -(ti_added*wake_overlap*tempb12(nd)/&
&         rotor_area_dst)
        rotor_diameter_dstb(nd) = rotor_diameter_dstb(nd) + pi*0.25_dp*&
&         2_dp*rotor_diameter_dst*rotor_area_dstb(nd)
        tempb13(nd) = 0.73_dp*temp19**(-0.32_dp)*ti_addedb(nd)
        tempb14(nd) = -(0.32_dp*temp19**(-1.32)*temp21*temp20*0.73_dp*&
&         ti_addedb(nd)/rotor_diameter_ust)
        axial_induction_ustb(nd) = temp20*0.8325_dp*axial_induction_ust&
&         **(-0.1675)*tempb13(nd)
        ti_ustb(nd) = temp21*0.0325_dp*ti_ust**(-0.9675)*tempb13(nd)
      END DO
      CALL OVERLAP_AREA_FUNC_BV(deltay, deltayb, turbine_height, &
&                         turbine_heightb, rotor_diameter_dst, &
&                         rotor_diameter_dstb, 0.0_dp, wake_height, &
&                         wake_heightb, wake_diameter, wake_diameterb, &
&                         wake_overlap, wake_overlapb, nbdirs)
      DO nd=1,nbdirs
        sigmab(nd) = 4.0_dp*wake_diameterb(nd)
        xb(nd) = k_star_ust*sigmab(nd) + tempb14(nd)
        rotor_diameter_ustb(nd) = rotor_diameter_ustb(nd) + epsilon*&
&         sigmab(nd) - temp19*tempb14(nd)
        k_star_ustb(nd) = k_star_ustb(nd) + x*sigmab(nd)
        epsilonb(nd) = rotor_diameter_ust*sigmab(nd)
        IF (beta .EQ. 0.0) THEN
          betab(nd) = 0.0
        ELSE
          betab(nd) = 0.2_dp*epsilonb(nd)/(2.0*SQRT(beta))
        END IF
        tempb15(nd) = 0.5_dp*betab(nd)/temp17
        IF (.NOT.1.0_dp - ct_ust .EQ. 0.0) ct_ustb(nd) = ct_ustb(nd) + (&
&           (temp18+1.0_dp)/(2.0*temp17**2)-1.0/(2.0*temp18))*tempb15(nd&
&           )
      END DO
      CALL CT_TO_AXIAL_IND_FUNC_BV(ct_ust, ct_ustb, axial_induction_ust&
&                            , axial_induction_ustb, nbdirs)
      ti_area_ratio_inb(:) = 0.0_8
    ELSE IF (ti_calculation_method .EQ. 5) THEN
! Niayifar and Porte Agel 2015, 2016 using smooth max on area TI ratio
! calculate axial induction based on the Ct value
      CALL CT_TO_AXIAL_IND_FUNC(ct_ust, axial_induction_ust)
! calculate BPA spread parameters Bastankhah and Porte Agel 2014
      beta = 0.5_dp*((1.0_dp+SQRT(1.0_dp-ct_ust))/SQRT(1.0_dp-ct_ust))
      epsilon = 0.2_dp*SQRT(beta)
! calculate wake spread for TI calcs
      sigma = k_star_ust*x + rotor_diameter_ust*epsilon
      wake_diameter = 4.0_dp*sigma
! calculate wake overlap ratio
      CALL OVERLAP_AREA_FUNC(deltay, turbine_height, rotor_diameter_dst&
&                      , 0.0_dp, wake_height, wake_diameter, &
&                      wake_overlap)
! only include turbines with area overlap in the softmax
      IF (wake_overlap .GT. 0.0_dp) THEN
! Calculate the turbulence added to the inflow of the downstream turbine by the 
! wake of the upstream turbine
        ti_added = 0.73_dp*axial_induction_ust**0.8325_dp*ti_ust**&
&         0.0325_dp*(x/rotor_diameter_ust)**(-0.32_dp)
        rotor_area_dst = 0.25_dp*pi*rotor_diameter_dst**2_dp
        ti_area_ratio_tmp = ti_added*(wake_overlap/rotor_area_dst)
!TI_tmp = sqrt(TI**2.0_dp + (TI_added*(wake_overlap/rotor_area_dst))**2.0_dp)
! Run through the smooth max to get an approximation of the true max TI area ratio
        CALL SMOOTH_MAX(sm_smoothing, ti_area_ratio_in, &
&                 ti_area_ratio_tmp, ti_area_ratio)
! Calculate the total turbulence intensity at the downstream turbine based on 
! the result of the smooth max function
        DO nd=1,nbdirs
          IF (.NOT.ti**2.0_dp + ti_area_ratio**2.0_dp .EQ. 0.0) &
&           ti_area_ratiob(nd) = ti_area_ratiob(nd) + 2.0_dp*&
&             ti_area_ratio*ti_dstb(nd)/(2.0*SQRT(ti**2.0_dp+&
&             ti_area_ratio**2.0_dp))
        END DO
        CALL SMOOTH_MAX_BV(sm_smoothing, ti_area_ratio_in, &
&                    ti_area_ratio_inb, ti_area_ratio_tmp, &
&                    ti_area_ratio_tmpb, ti_area_ratio, ti_area_ratiob, &
&                    nbdirs)
        temp24 = x/rotor_diameter_ust
        temp25 = ti_ust**0.0325_dp
        temp26 = axial_induction_ust**0.8325_dp
        DO nd=1,nbdirs
          tempb17(nd) = ti_area_ratio_tmpb(nd)/rotor_area_dst
          ti_addedb(nd) = wake_overlap*tempb17(nd)
          wake_overlapb(nd) = ti_added*tempb17(nd)
          rotor_area_dstb(nd) = -(ti_added*wake_overlap*tempb17(nd)/&
&           rotor_area_dst)
          rotor_diameter_dstb(nd) = rotor_diameter_dstb(nd) + pi*0.25_dp&
&           *2_dp*rotor_diameter_dst*rotor_area_dstb(nd)
          tempb18(nd) = 0.73_dp*temp24**(-0.32_dp)*ti_addedb(nd)
          tempb19(nd) = -(0.32_dp*temp24**(-1.32)*temp26*temp25*0.73_dp*&
&           ti_addedb(nd)/rotor_diameter_ust)
          axial_induction_ustb(nd) = temp25*0.8325_dp*&
&           axial_induction_ust**(-0.1675)*tempb18(nd)
          ti_ustb(nd) = temp26*0.0325_dp*ti_ust**(-0.9675)*tempb18(nd)
          xb(nd) = tempb19(nd)
          rotor_diameter_ustb(nd) = rotor_diameter_ustb(nd) - temp24*&
&           tempb19(nd)
        END DO
        ti_dstb(:) = 0.0_8
        ti_area_ratiob(:) = 0.0_8
      ELSE
        xb(:) = 0.0_8
        ti_area_ratio_inb(:) = 0.0_8
        ti_ustb(:) = 0.0_8
        axial_induction_ustb(:) = 0.0_8
        wake_overlapb(:) = 0.0_8
      END IF
      CALL OVERLAP_AREA_FUNC_BV(deltay, deltayb, turbine_height, &
&                         turbine_heightb, rotor_diameter_dst, &
&                         rotor_diameter_dstb, 0.0_dp, wake_height, &
&                         wake_heightb, wake_diameter, wake_diameterb, &
&                         wake_overlap, wake_overlapb, nbdirs)
      temp22 = SQRT(-ct_ust + 1.0_dp)
      temp23 = SQRT(-ct_ust + 1.0_dp)
      DO nd=1,nbdirs
        sigmab(nd) = 4.0_dp*wake_diameterb(nd)
        k_star_ustb(nd) = k_star_ustb(nd) + x*sigmab(nd)
        xb(nd) = xb(nd) + k_star_ust*sigmab(nd)
        rotor_diameter_ustb(nd) = rotor_diameter_ustb(nd) + epsilon*&
&         sigmab(nd)
        epsilonb(nd) = rotor_diameter_ust*sigmab(nd)
        IF (beta .EQ. 0.0) THEN
          betab(nd) = 0.0
        ELSE
          betab(nd) = 0.2_dp*epsilonb(nd)/(2.0*SQRT(beta))
        END IF
        tempb16(nd) = 0.5_dp*betab(nd)/temp22
        IF (.NOT.1.0_dp - ct_ust .EQ. 0.0) ct_ustb(nd) = ct_ustb(nd) + (&
&           (temp23+1.0_dp)/(2.0*temp22**2)-1.0/(2.0*temp23))*tempb16(nd&
&           )
      END DO
      CALL CT_TO_AXIAL_IND_FUNC_BV(ct_ust, ct_ustb, axial_induction_ust&
&                            , axial_induction_ustb, nbdirs)
    ELSE
! wake combination method error 
      STOP
    END IF
    ti_dst_inb(:) = 0.0_8
  END IF
  DO nd=1,nbdirs
    ti_dst_inb(nd) = ti_dst_inb(nd) + ti_dstb(nd)
    ti_area_ratio_inb(nd) = ti_area_ratio_inb(nd) + ti_area_ratiob(nd)
  END DO
END SUBROUTINE ADDED_TI_FUNC_BV

!  Differentiation of overlap_area_func in reverse (adjoint) mode (with options multiDirectional i4 dr8 r4):
!   gradient     of useful results: rotor_diameter turbine_z wake_center_z
!                wake_overlap
!   with respect to varying inputs: wake_diameter rotor_diameter
!                turbine_y turbine_z wake_center_z
! calculates the overlap area between a given wake and a rotor area
SUBROUTINE OVERLAP_AREA_FUNC_BV(turbine_y, turbine_yb, turbine_z, &
& turbine_zb, rotor_diameter, rotor_diameterb, wake_center_y, &
& wake_center_z, wake_center_zb, wake_diameter, wake_diameterb, &
& wake_overlap, wake_overlapb, nbdirs)
 !!  USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: turbine_y, turbine_z, rotor_diameter
  REAL(dp), DIMENSION(nbdirs) :: turbine_yb, turbine_zb, &
& rotor_diameterb
  REAL(dp), INTENT(IN) :: wake_center_y, wake_center_z, wake_diameter
  REAL(dp), DIMENSION(nbdirs) :: wake_center_zb, wake_diameterb
! out    
  REAL(dp) :: wake_overlap
  REAL(dp), DIMENSION(nbdirs) :: wake_overlapb
! local
  REAL(dp), PARAMETER :: pi=3.141592653589793_dp, tol=0.000001_dp
  REAL(dp) :: ovdyd, ovr, ovrr, ovl, ovz, ovz2
  REAL(dp), DIMENSION(nbdirs) :: ovdydb, ovrb, ovrrb, ovlb, ovzb, &
& ovz2b
! load intrinsic functions
  INTRINSIC ACOS, SQRT
  INTEGER :: nd
  REAL(dp), DIMENSION(nbdirs) :: tempb
  REAL(dp), DIMENSION(nbdirs) :: tempb0
  REAL(dp) :: temp
  REAL(dp) :: temp0
  REAL(dp), DIMENSION(nbdirs) :: tempb1
  REAL(dp), DIMENSION(nbdirs) :: tempb2
  REAL(dp), DIMENSION(nbdirs) :: tempb3
  REAL(dp), DIMENSION(nbdirs) :: tempb4
  REAL(dp), DIMENSION(nbdirs) :: tempb5
  REAL(dp), DIMENSION(nbdirs) :: tempb6
  INTEGER :: branch
  INTEGER :: nbdirs
!     print *, turbine_y, turbine_z, rotor_diameter, &
!                             wake_center_y, wake_center_z, wake_diameter, &
!                             wake_overlap
! distance between wake center and rotor center
  IF (wake_center_z .GT. turbine_z + tol .OR. wake_center_z .LT. &
&     turbine_z - tol) THEN
    ovdyd = SQRT((wake_center_y-turbine_y)**2_dp + (wake_center_z-&
&     turbine_z)**2_dp)
    CALL PUSHCONTROL2B(0)
  ELSE IF (wake_center_y .GT. turbine_y + tol) THEN
! potential source of gradient issues, abs() did not cause a problem in FLORIS
    ovdyd = wake_center_y - turbine_y
    CALL PUSHCONTROL2B(1)
  ELSE IF (turbine_y .GT. wake_center_y + tol) THEN
    ovdyd = turbine_y - wake_center_y
    CALL PUSHCONTROL2B(2)
  ELSE
    ovdyd = 0.0_dp
    CALL PUSHCONTROL2B(3)
  END IF
!print *, "OVdYd: ", OVdYd
! find rotor radius
  ovr = rotor_diameter/2.0_dp
!print *, "OVr: ", OVr
! find wake radius
  ovrr = wake_diameter/2.0_dp
!print *, "OVRR: ", OVRR
! make sure the distance from wake center to turbine hub is positive
! OVdYd = abs(OVdYd) !!! commented out since change to 2D distance (y,z) will always be positive
! calculate the distance from the wake center to the line perpendicular to the 
! line between the two circle intersection points
!if (OVdYd >= 0.0_dp + tol) then ! check case to avoid division by zero
!     print *, "OVdYd ", OVdYd
! if (OVdYd >= 0.0_dp + tol) then ! check case to avoid division by zero
!         OVL = (-OVr*OVr+OVRR*OVRR+OVdYd*OVdYd)/(2.0_dp*OVdYd)
! !         print *, "OVdYd, OVL: ", OVdYd, OVL
!     else
!         OVL = 0.0_dp
!     end if
! 
!     OVz = OVRR*OVRR-OVL*OVL
! 
!     ! Finish calculating the distance from the intersection line to the outer edge of the wake
!     !if (OVz > 0.0_dp + tol) then
!     if (OVz > 0.0_dp + tol) then
!         OVz = sqrt(OVz)
!     else
!         OVz = 0.0_dp
!     end if
!print *, "OVRR, OVL, OVRR, OVr, OVdYd, OVz ", OVRR, OVL, OVRR, OVr, OVdYd, OVz
! if (OVdYd < (OVr+OVRR)) then ! if the rotor overlaps the wake
!         !print *, "OVL: ", OVL
!         if (OVL < OVRR .and. (OVdYd-OVL) < OVr) then
! !         if (OVdYd > 0.0_dp + tol) then
! !         if ((OVdYd > 0.0_dp) .and. (OVdYd > (OVRR - OVr))) then
!             ! print *, "acos(OVL/OVRR), acos((OVdYd-OVL)/OVr), OVRR, OVL, OVr, OVdYd, OVL/OVRR, (OVdYd-OVL)/OVr ", &
! !     & acos(OVL/OVRR), acos((OVdYd-OVL)/OVr), OVRR, OVL, OVr, OVdYd, OVL/OVRR, (OVdYd-OVL)/OVr
!             wake_overlap = OVRR*OVRR*acos(OVL/OVRR) + OVr*OVr*acos((OVdYd-OVL)/OVr) - OVdYd*OVz
!         else if (OVRR > OVr) then
!             wake_overlap = pi*OVr*OVr
!             !print *, "wake ovl: ", wake_overlap
!         else
!             wake_overlap = pi*OVRR*OVRR
!         end if
!     else
!         wake_overlap = 0.0_dp
!     end if
! determine if there is overlap
  IF (ovdyd .LT. ovr + ovrr) THEN
! if the rotor overlaps the wake zone
! check that turbine and wake centers are not perfectly aligned
    IF (ovdyd .GT. 0.0_dp + tol) THEN
! check if the rotor is wholly contained in the wake
      IF (ovdyd + ovr .LT. ovrr + tol) THEN
        wake_overlap = pi*ovr*ovr
!                 print *, "1"
! check if the wake is wholly contained in the rotor swept area
        CALL PUSHCONTROL3B(0)
      ELSE IF (ovdyd + ovrr .LT. ovr + tol) THEN
        wake_overlap = pi*ovrr*ovrr
!                 print *, "2"
        CALL PUSHCONTROL3B(1)
      ELSE
! calculate the distance from the wake center to the chord connecting the lens
! cusps
        ovl = (-(ovr*ovr)+ovrr*ovrr+ovdyd*ovdyd)/(2.0_dp*ovdyd)
        ovz = SQRT(ovrr*ovrr - ovl*ovl)
        ovz2 = SQRT(ovr*ovr - (ovdyd-ovl)*(ovdyd-ovl))
        wake_overlap = ovrr*ovrr*ACOS(ovl/ovrr) + ovr*ovr*ACOS((ovdyd-&
&         ovl)/ovr) - ovl*ovz - (ovdyd-ovl)*ovz2
!                 print *, OVRR, OVr, OVdYd, OVL, OVz, OVz2
!                 print *, "3"
        CALL PUSHCONTROL3B(2)
      END IF
    ELSE IF (ovrr .GT. ovr) THEN
! perfect overlap case where the wake is larger than the rotor
      wake_overlap = pi*ovr*ovr
!             print *, "4"
! perfect overlap case where the rotor is larger than the wake
      CALL PUSHCONTROL3B(3)
    ELSE
      wake_overlap = pi*ovrr*ovrr
!             print *, "5"
      CALL PUSHCONTROL3B(4)
    END IF
  ELSE
! case with no overlap
    wake_overlap = 0.0_dp
    CALL PUSHCONTROL3B(5)
  END IF
!     print *, "wake overlap in func: ", wake_overlap/(pi*OVr**2)
!     print *, "wake overlap in func: ", wake_overlap/(pi*OVRR**2)
  IF (wake_overlap/(pi*ovr*ovr) .GT. 1.0_dp + tol .OR. wake_overlap/(pi*&
&     ovrr*ovrr) .GT. 1.0_dp + tol) THEN
    STOP
  ELSE
    CALL POPCONTROL3B(branch)
    IF (branch .LT. 3) THEN
      IF (branch .EQ. 0) THEN
        DO nd=1,nbdirs
          ovrb(nd) = pi*2*ovr*wake_overlapb(nd)
        END DO
        ovdydb(:) = 0.0_8
        ovrrb(:) = 0.0_8
      ELSE IF (branch .EQ. 1) THEN
        DO nd=1,nbdirs
          ovrrb(nd) = pi*2*ovrr*wake_overlapb(nd)
        END DO
        ovdydb(:) = 0.0_8
        ovrb(:) = 0.0_8
      ELSE
        temp = ovl/ovrr
        temp0 = (ovdyd-ovl)/ovr
        DO nd=1,nbdirs
          ovzb(nd) = -(ovl*wake_overlapb(nd))
          ovz2b(nd) = -((ovdyd-ovl)*wake_overlapb(nd))
          IF (ovr**2 - (ovdyd-ovl)**2 .EQ. 0.0) THEN
            tempb6(nd) = 0.0
          ELSE
            tempb6(nd) = ovz2b(nd)/(2.0*SQRT(ovr**2-(ovdyd-ovl)**2))
          END IF
          tempb5(nd) = -(2*(ovdyd-ovl)*tempb6(nd))
          IF (ovrr**2 - ovl**2 .EQ. 0.0) THEN
            tempb3(nd) = 0.0
          ELSE
            tempb3(nd) = ovzb(nd)/(2.0*SQRT(ovrr**2-ovl**2))
          END IF
          IF (temp .EQ. 1.0 .OR. temp .EQ. (-1.0)) THEN
            tempb1(nd) = 0.0
          ELSE
            tempb1(nd) = -(ovrr*wake_overlapb(nd)/SQRT(1.0-temp**2))
          END IF
          IF (temp0 .EQ. 1.0 .OR. temp0 .EQ. (-1.0)) THEN
            tempb2(nd) = 0.0
          ELSE
            tempb2(nd) = -(ovr*wake_overlapb(nd)/SQRT(1.0-temp0**2))
          END IF
          ovlb(nd) = (ovz2-ovz)*wake_overlapb(nd) - 2*ovl*tempb3(nd) - &
&           tempb5(nd) - tempb2(nd) + tempb1(nd)
          tempb4(nd) = ovlb(nd)/(2.0_dp*ovdyd)
          ovrrb(nd) = 2*ovrr*tempb3(nd) + 2*ovrr*tempb4(nd) - temp*&
&           tempb1(nd) + ACOS(temp)*2*ovrr*wake_overlapb(nd)
          ovrb(nd) = 2*ovr*tempb6(nd) - 2*ovr*tempb4(nd) - temp0*tempb2(&
&           nd) + ACOS(temp0)*2*ovr*wake_overlapb(nd)
          ovdydb(nd) = tempb5(nd) + (2*ovdyd-(ovrr**2-ovr**2+ovdyd**2)/&
&           ovdyd)*tempb4(nd) - ovz2*wake_overlapb(nd) + tempb2(nd)
        END DO
      END IF
    ELSE
      IF (branch .EQ. 3) THEN
        DO nd=1,nbdirs
          ovrb(nd) = pi*2*ovr*wake_overlapb(nd)
        END DO
        ovrrb(:) = 0.0_8
      ELSE IF (branch .EQ. 4) THEN
        DO nd=1,nbdirs
          ovrrb(nd) = pi*2*ovrr*wake_overlapb(nd)
        END DO
        ovrb(:) = 0.0_8
      ELSE
        ovdydb(:) = 0.0_8
        ovrb(:) = 0.0_8
        ovrrb(:) = 0.0_8
        GOTO 100
      END IF
      ovdydb(:) = 0.0_8
    END IF
 100 DO nd=1,nbdirs
      wake_diameterb(nd) = ovrrb(nd)/2.0_dp
      rotor_diameterb(nd) = rotor_diameterb(nd) + ovrb(nd)/2.0_dp
    END DO
    CALL POPCONTROL2B(branch)
    IF (branch .LT. 2) THEN
      IF (branch .EQ. 0) THEN
        DO nd=1,nbdirs
          IF ((wake_center_y-turbine_y)**2_dp + (wake_center_z-turbine_z&
&             )**2_dp .EQ. 0.0) THEN
            tempb(nd) = 0.0
          ELSE
            tempb(nd) = ovdydb(nd)/(2.0*SQRT((wake_center_y-turbine_y)**&
&             2_dp+(wake_center_z-turbine_z)**2_dp))
          END IF
          tempb0(nd) = 2_dp*(wake_center_z-turbine_z)*tempb(nd)
          turbine_yb(nd) = -(2_dp*(wake_center_y-turbine_y)*tempb(nd))
          wake_center_zb(nd) = wake_center_zb(nd) + tempb0(nd)
          turbine_zb(nd) = turbine_zb(nd) - tempb0(nd)
        END DO
      ELSE
        DO nd=1,nbdirs
          turbine_yb(nd) = -ovdydb(nd)
        END DO
      END IF
    ELSE IF (branch .EQ. 2) THEN
      DO nd=1,nbdirs
        turbine_yb(nd) = ovdydb(nd)
      END DO
    ELSE
      turbine_yb(:) = 0.0_8
    END IF
  END IF
END SUBROUTINE OVERLAP_AREA_FUNC_BV

!  Differentiation of k_star_func in reverse (adjoint) mode (with options multiDirectional i4 dr8 r4):
!   gradient     of useful results: k_star_ust ti_ust
!   with respect to varying inputs: ti_ust
! compute wake spread parameter based on local turbulence intensity
SUBROUTINE K_STAR_FUNC_BV(ti_ust, ti_ustb, k_star_ust, k_star_ustb, &
& nbdirs)
 !!  USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: ti_ust
  REAL(dp), DIMENSION(nbdirs) :: ti_ustb
! out  
  REAL(dp) :: k_star_ust
  REAL(dp), DIMENSION(nbdirs) :: k_star_ustb
! calculate wake spread parameter from Niayifar and Porte Agel (2015, 2016)
  INTEGER :: nd
  INTEGER :: nbdirs
  DO nd=1,nbdirs
    ti_ustb(nd) = ti_ustb(nd) + 0.3837*k_star_ustb(nd)
  END DO
END SUBROUTINE K_STAR_FUNC_BV

!  Differentiation of ct_to_axial_ind_func in reverse (adjoint) mode (with options multiDirectional i4 dr8 r4):
!   gradient     of useful results: axial_induction ct
!   with respect to varying inputs: ct
! calculate axial induction from Ct
SUBROUTINE CT_TO_AXIAL_IND_FUNC_BV(ct, ctb, axial_induction, &
& axial_inductionb, nbdirs)
 !!  USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: ct
  REAL(dp), DIMENSION(nbdirs) :: ctb
! out
  REAL(dp) :: axial_induction
  REAL(dp), DIMENSION(nbdirs) :: axial_inductionb
  INTRINSIC SQRT
  INTEGER :: nd
  INTEGER :: nbdirs
! initialize axial induction to zero
! calculate axial induction
  IF (ct .GT. 0.96) THEN
    DO nd=1,nbdirs
      IF (.NOT.0.0203_dp - 0.6427_dp*(0.889_dp-ct) .EQ. 0.0) ctb(nd) = &
&         ctb(nd) + 0.6427_dp*axial_inductionb(nd)/(2.0*SQRT(0.0203_dp-&
&         0.6427_dp*(0.889_dp-ct)))
    END DO
  ELSE
    DO nd=1,nbdirs
      IF (.NOT.1.0_dp - ct .EQ. 0.0) ctb(nd) = ctb(nd) + 0.5_dp*&
&         axial_inductionb(nd)/(2.0*SQRT(1.0_dp-ct))
    END DO
  END IF
END SUBROUTINE CT_TO_AXIAL_IND_FUNC_BV

!  Differentiation of wind_shear_func in reverse (adjoint) mode (with options multiDirectional i4 dr8 r4):
!   gradient     of useful results: adjusted_wind_speed
!   with respect to varying inputs: point_z u_ref
! adjust wind speed for wind shear
SUBROUTINE WIND_SHEAR_FUNC_BV(point_z, point_zb, u_ref, u_refb, z_ref, &
& z_0, shear_exp, adjusted_wind_speed, adjusted_wind_speedb, nbdirs)
 !!  USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: point_z, u_ref, z_ref, z_0, shear_exp
  REAL(dp), DIMENSION(nbdirs) :: point_zb, u_refb
! out
  REAL(dp) :: adjusted_wind_speed
  REAL(dp), DIMENSION(nbdirs) :: adjusted_wind_speedb
  REAL(dp) :: temp
  INTEGER :: nd
  INTEGER :: nbdirs
! initialize adjusted wind speed to zero
! check that the point of interest is above ground level
  IF (point_z .GE. z_0) THEN
    temp = (point_z-z_0)/(z_ref-z_0)
    DO nd=1,nbdirs
      u_refb(nd) = temp**shear_exp*adjusted_wind_speedb(nd)
      IF (temp .LE. 0.0 .AND. (shear_exp .EQ. 0.0 .OR. shear_exp .NE. &
&         INT(shear_exp))) THEN
        point_zb(nd) = 0.0
      ELSE
        point_zb(nd) = shear_exp*temp**(shear_exp-1)*u_ref*&
&         adjusted_wind_speedb(nd)/(z_ref-z_0)
      END IF
    END DO
  ELSE
    point_zb(:) = 0.0_8
    u_refb(:) = 0.0_8
  END IF
END SUBROUTINE WIND_SHEAR_FUNC_BV

!  Differentiation of discontinuity_point_func in reverse (adjoint) mode (with options multiDirectional i4 dr8 r4):
!   gradient     of useful results: yaw discontinuity_point ky
!                kz rotor_diameter x0 ct
!   with respect to varying inputs: yaw ky kz rotor_diameter x0
!                ct
! calculate the point where the Bastankhah and Porte Agel wake model becomes undefined
SUBROUTINE DISCONTINUITY_POINT_FUNC_BV(x0, x0b, rotor_diameter, &
& rotor_diameterb, ky, kyb, kz, kzb, yaw, yawb, ct, ctb, &
& discontinuity_point, discontinuity_pointb, nbdirs)
 !!  USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: x0, rotor_diameter, ky, kz, yaw, ct
  REAL(dp), DIMENSION(nbdirs) :: x0b, rotor_diameterb, kyb, kzb, yawb&
& , ctb
! local
  REAL(dp) :: a, b, c
  REAL(dp), DIMENSION(nbdirs) :: ab, bb, cb
! out
  REAL(dp) :: discontinuity_point
  REAL(dp), DIMENSION(nbdirs) :: discontinuity_pointb
  INTRINSIC COS, SQRT
  REAL(dp) :: temp
  REAL(dp) :: temp0
  INTEGER :: nd
  REAL(dp), DIMENSION(nbdirs) :: tempb
  REAL(dp), DIMENSION(nbdirs) :: tempb0
  REAL(dp), DIMENSION(nbdirs) :: tempb1
  REAL(dp), DIMENSION(nbdirs) :: tempb2
  INTEGER :: nbdirs
! for clarity, break out the terms in the equation
  a = ky + kz*COS(yaw)
  b = 4.0_dp*ky*kz*COS(yaw)*(ct-1.0_dp)
  c = 2.0_dp*SQRT(8.0_dp)*ky*kz
! distance from rotor to the last point where the wake model is undefined
  temp = a**2 - b
  temp0 = SQRT(temp)
  DO nd=1,nbdirs
    tempb(nd) = rotor_diameter*discontinuity_pointb(nd)/c
    tempb0(nd) = (a-temp0)*discontinuity_pointb(nd)/c
    x0b(nd) = x0b(nd) + discontinuity_pointb(nd)
    IF (temp .EQ. 0.0) THEN
      ab(nd) = tempb(nd)
    ELSE
      ab(nd) = (1.0_8-2*a/(2.0*temp0))*tempb(nd)
    END IF
    IF (temp .EQ. 0.0) THEN
      bb(nd) = 0.0
    ELSE
      bb(nd) = tempb(nd)/(2.0*temp0)
    END IF
    rotor_diameterb(nd) = rotor_diameterb(nd) + tempb0(nd)
    cb(nd) = -(rotor_diameter*tempb0(nd)/c)
    tempb1(nd) = SQRT(8.0_dp)*2.0_dp*cb(nd)
    tempb2(nd) = 4.0_dp*COS(yaw)*bb(nd)
    kyb(nd) = kyb(nd) + (ct-1.0_dp)*kz*tempb2(nd) + ab(nd) + kz*tempb1(&
&     nd)
    kzb(nd) = kzb(nd) + (ct-1.0_dp)*ky*tempb2(nd) + COS(yaw)*ab(nd) + ky&
&     *tempb1(nd)
    ctb(nd) = ctb(nd) + ky*kz*tempb2(nd)
    yawb(nd) = yawb(nd) - kz*SIN(yaw)*ab(nd) - ky*kz*(ct-1.0_dp)*4.0_dp*&
&     SIN(yaw)*bb(nd)
  END DO
END SUBROUTINE DISCONTINUITY_POINT_FUNC_BV

!  Differentiation of smooth_max in reverse (adjoint) mode (with options multiDirectional i4 dr8 r4):
!   gradient     of useful results: g
!   with respect to varying inputs: x y
SUBROUTINE SMOOTH_MAX_BV(s, x, xb, y, yb, g, gb, nbdirs)
 !!  USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: s, x, y
  REAL(dp), DIMENSION(nbdirs) :: xb, yb
! local
  REAL(dp) :: max_val, min_val
  REAL(dp), DIMENSION(nbdirs) :: max_valb, min_valb
! out
  REAL(dp) :: g
  REAL(dp), DIMENSION(nbdirs) :: gb
  INTRINSIC LOG, EXP, MAX, MIN
  INTEGER :: nd
  REAL(dp), DIMENSION(nbdirs) :: tempb
  INTEGER :: branch
  INTEGER :: nbdirs
  IF (x .LT. y) THEN
    max_val = y
    CALL PUSHCONTROL1B(0)
  ELSE
    max_val = x
    CALL PUSHCONTROL1B(1)
  END IF
  IF (x .GT. y) THEN
    min_val = y
    CALL PUSHCONTROL1B(0)
  ELSE
    min_val = x
    CALL PUSHCONTROL1B(1)
  END IF
  DO nd=1,nbdirs
    tempb(nd) = EXP(s*(min_val-max_val))*gb(nd)/(EXP(s*(min_val-max_val)&
&     )+1.0_dp)
    min_valb(nd) = tempb(nd)
    max_valb(nd) = gb(nd) - tempb(nd)
  END DO
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    DO nd=1,nbdirs
      yb(nd) = min_valb(nd)
    END DO
    xb(:) = 0.0_8
  ELSE
    DO nd=1,nbdirs
      xb(nd) = min_valb(nd)
    END DO
    yb(:) = 0.0_8
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    DO nd=1,nbdirs
      yb(nd) = yb(nd) + max_valb(nd)
    END DO
  ELSE
    DO nd=1,nbdirs
      xb(nd) = xb(nd) + max_valb(nd)
    END DO
  END IF
END SUBROUTINE SMOOTH_MAX_BV

!  Differentiation of interpolation in reverse (adjoint) mode (with options multiDirectional i4 dr8 r4):
!   gradient     of useful results: yval xval
!   with respect to varying inputs: yval xval
SUBROUTINE INTERPOLATION_BV(npoints, interp_type, x, y, xval, xvalb, &
& yval, yvalb, dy0in, dy1in, usedyin, nbdirs)
 !!  USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
!     print *, "yval = ", yval
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  INTEGER, INTENT(IN) :: npoints, interp_type
  REAL(dp), DIMENSION(npoints), INTENT(IN) :: x, y
  REAL(dp), INTENT(IN) :: xval
  REAL(dp), DIMENSION(nbdirs) :: xvalb
  REAL(dp), INTENT(IN) :: dy0in, dy1in
  LOGICAL :: usedyin
! local
  INTEGER :: idx
  REAL(dp) :: x0, x1, y0, dy0, y1, dy1
! out
  REAL(dp) :: yval
  REAL(dp), DIMENSION(nbdirs) :: yvalb
  INTEGER :: nd
  INTEGER :: branch
  INTEGER :: nbdirs
!     print *, "in interpolation"
! if ((xval < x(1)) .or. (xval > x(nPoints))) then
!         print *, "interpolation point is out of bounds"
! !         STOP 1
!     end if
  IF (usedyin .AND. interp_type .EQ. 1) THEN
    STOP
  ELSE IF (xval .LT. x(1)) THEN
    yvalb(:) = 0.0_8
  ELSE IF (xval .GT. x(npoints)) THEN
    yvalb(:) = 0.0_8
  ELSE
    idx = 1
    DO WHILE (xval .GT. x(idx) .AND. idx .LE. npoints)
      idx = idx + 1
    END DO
    idx = idx - 1
    x0 = x(idx)
    x1 = x(idx+1)
    y0 = y(idx)
    y1 = y(idx+1)
! Hermite cubic piecewise spline interpolation
    IF (interp_type .EQ. 0) THEN
! approximate derivative at left end of interval
      IF (idx .EQ. 1) THEN
        IF (usedyin) THEN
          CALL PUSHCONTROL1B(0)
          dy0 = dy0in
        ELSE
          CALL PUSHCONTROL1B(0)
          dy0 = 0.0_dp
        END IF
      ELSE
        CALL PUSHCONTROL1B(1)
        dy0 = (y(idx+1)-y(idx-1))/(x(idx+1)-x(idx-1))
      END IF
! approximate derivative at the right end of interval
      IF (idx .GE. npoints - 1) THEN
        IF (usedyin) THEN
          CALL PUSHCONTROL1B(0)
          dy1 = dy1in
        ELSE
          CALL PUSHCONTROL1B(0)
          dy1 = 0.0_dp
        END IF
      ELSE
        CALL PUSHCONTROL1B(1)
        dy1 = (y(idx+2)-y(idx))/(x(idx+2)-x(idx))
      END IF
      CALL HERMITE_SPLINE_BV(xval, xvalb, x0, x1, y0, dy0, y1, dy1, yval&
&                      , yvalb, nbdirs)
      CALL POPCONTROL1B(branch)
      CALL POPCONTROL1B(branch)
      yvalb(:) = 0.0_8
    ELSE IF (interp_type .EQ. 1) THEN
      DO nd=1,nbdirs
        xvalb(nd) = xvalb(nd) + (y1-y0)*yvalb(nd)/(x1-x0)
      END DO
      yvalb(:) = 0.0_8
    END IF
  END IF
END SUBROUTINE INTERPOLATION_BV

!  Differentiation of hermite_spline in reverse (adjoint) mode (with options multiDirectional i4 dr8 r4):
!   gradient     of useful results: x y
!   with respect to varying inputs: x
SUBROUTINE HERMITE_SPLINE_BV(x, xb, x0, x1, y0, dy0, y1, dy1, y, yb, &
& nbdirs)
 !!  USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
!dy_dx = c3*3*x**2 + c2*2*x + c1
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: x, x0, x1, y0, dy0, y1, dy1
  REAL(dp), DIMENSION(nbdirs) :: xb
! out
!, dy_dx
  REAL(dp) :: y
  REAL(dp), DIMENSION(nbdirs) :: yb
! local
  REAL(dp) :: c3, c2, c1, c0
  INTEGER :: nd
  INTEGER :: nbdirs
! initialize coefficients for parametric cubic spline
  c3 = 2.0_dp*y1/(x0**3-3.0_dp*x0**2*x1+3.0_dp*x0*x1**2-x1**3) - 2.0_dp*&
&   y0/(x0**3-3.0_dp*x0**2*x1+3.0_dp*x0*x1**2-x1**3) + dy0/(x0**2-2.0_dp&
&   *x0*x1+x1**2) + dy1/(x0**2-2.0_dp*x0*x1+x1**2)
  c2 = 3.0_dp*y0*(x0+x1)/(x0**3-3.0_dp*x0**2*x1+3.0_dp*x0*x1**2-x1**3) -&
&   dy1*(2.0_dp*x0+x1)/(x0**2-2.0_dp*x0*x1+x1**2) - dy0*(x0+2.0_dp*x1)/(&
&   x0**2-2.0_dp*x0*x1+x1**2) - 3.0_dp*y1*(x0+x1)/(x0**3-3.0_dp*x0**2*x1&
&   +3.0_dp*x0*x1**2-x1**3)
  c1 = dy0*(x1**2+2.0_dp*x0*x1)/(x0**2-2.0_dp*x0*x1+x1**2) + dy1*(x0**2+&
&   2.0_dp*x1*x0)/(x0**2-2.0_dp*x0*x1+x1**2) - 6.0_dp*x0*x1*y0/(x0**3-&
&   3.0_dp*x0**2*x1+3.0_dp*x0*x1**2-x1**3) + 6.0_dp*x0*x1*y1/(x0**3-&
&   3.0_dp*x0**2*x1+3.0_dp*x0*x1**2-x1**3)
!    print *, 'c3 = ', c3
!    print *, 'c2 = ', c2
!    print *, 'c1 = ', c1
!    print *, 'c0 = ', c0
! Solve for y and dy values at the given point
  DO nd=1,nbdirs
    xb(nd) = xb(nd) + (c1+c2*2*x+c3*3*x**2)*yb(nd)
  END DO
END SUBROUTINE HERMITE_SPLINE_BV
!    yd, n = _checkIfFloat(yd)
! 
!     y1 = (1-pct_offset)*ymax
!     y2 = (1+pct_offset)*ymax
! 
!     dy1 = (1-pct_offset)
!     dy2 = (1+pct_offset)
! 
!     if (maxmin == 1) then
!         f1 = y1
!         f2 = ymax
!         g1 = 1.0_dp
!         g2 = 0.0_dp
!         if (yd .ge. y2) then
!             idx_constant = False
!         else
!             idx_constant = True
!         end if
! 
!         df1 = dy1
!         df2 = 1.0_dp
! 
! 
!     else if (maxmin == 0) then
!         f1 = ymax
!         f2 = y2
!         g1 = 0.0_dp
!         g2 = 1.0_dp
!         if (yd .ge. y1) then
!             idx_constant = False
!         else
!             idx_constant = True
!         end if
! 
!         df1 = 1.0_dp
!         df2 = dy2
!         
!     end if
! 
!     f = CubicSplineSegment(y1, y2, f1, f2, g1, g2)
! 
!     # main region
!     ya = np.copy(yd)
!     if dyd is None:
!         dya_dyd = np.ones_like(yd)
!     else:
!         dya_dyd = np.copy(dyd)
! 
!     dya_dymax = np.zeros_like(ya)
! 
!     # cubic spline region
!     idx = np.logical_and(yd > y1, yd < y2)
!     ya[idx] = f.eval(yd[idx])
!     dya_dyd[idx] = f.eval_deriv(yd[idx])
!     dya_dymax[idx] = f.eval_deriv_params(yd[idx], dy1, dy2, df1, df2, 0.0, 0.0)
! 
!     # constant region
!     ya[idx_constant] = ymax
!     dya_dyd[idx_constant] = 0.0
!     dya_dymax[idx_constant] = 1.0
! 
!     if n == 1:
!         ya = ya[0]
!         dya_dyd = dya_dyd[0]
!         dya_dymax = dya_dymax[0]
! 
! 
!     return ya, dya_dyd, dya_dymax
! 
! 
! def smooth_max(yd, ymax, pct_offset=0.01, dyd=None):
!     """array max, uses cubic spline to smoothly transition.  derivatives with respect to array and max value.
!     width of transition can be controlled, and chain rules for differentiation"""
!     return _smooth_maxmin(yd, ymax, 'max', pct_offset, dyd)
! 
! 
! def smooth_min(yd, ymin, pct_offset=0.01, dyd=None):
!     """array min, uses cubic spline to smoothly transition.  derivatives with respect to array and min value.
!     width of transition can be controlled, and chain rules for differentiation"""
!     return _smooth_maxmin(yd, ymin, 'min', pct_offset, dyd)
! 


!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.15 (develop) -  7 Jan 2020 16:27
!
!  Differentiation of porteagel_analyze in reverse (adjoint) mode:
!   gradient     of useful results: wtvelocity
!   with respect to varying inputs: rotordiameter turbinez turbinexw
!                wtvelocity turbineyw yawdeg ct
!   RW status of diff variables: rotordiameter:out turbinez:out
!                turbinexw:out wtvelocity:in-zero turbineyw:out
!                yawdeg:out ct:out
! Implementation of the Bastankhah and Porte Agel gaussian-shaped wind turbine wake 
! model (2016) with various farm modeling (TI and wake combination) methods included
! Created by Jared J. Thomas, 2017-2019.
! FLight Optimization and Wind Laboratory (FLOW Lab)
! Brigham Young University
! implementation of the Bastankhah and Porte Agel (BPA) wake model for analysis
SUBROUTINE PORTEAGEL_ANALYZE_BV(nturbines, nrotorpoints, nctpoints, &
& nfieldpoints, turbinexw, turbinexwb, sorted_x_idx, turbineyw, &
& turbineywb, turbinez, turbinezb, rotordiameter, rotordiameterb, ct, &
& ctb, wind_speed, yawdeg, yawdegb, ky, kz, alpha, beta, ti, &
& rotorpointsy, rotorpointsz, fieldpointsx, fieldpointsy, fieldpointsz, &
& z_ref, z_0, shear_exp, wake_combination_method, ti_calculation_method&
& , calc_k_star, wec_factor, print_ti, wake_model_version, interp_type, &
& use_ct_curve, ct_curve_wind_speed, ct_curve_ct, sm_smoothing, &
& wec_spreading_angle, calculateflowfield, wech, wtvelocityb, nbdirs)
  ! USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  INTEGER, INTENT(IN) :: nturbines, nrotorpoints, nctpoints, &
& nfieldpoints
  INTEGER, INTENT(IN) :: wake_combination_method, ti_calculation_method&
& , wake_model_version, interp_type, wech
  LOGICAL, INTENT(IN) :: calc_k_star, print_ti, use_ct_curve, &
& calculateflowfield
  REAL(dp), DIMENSION(nturbines), INTENT(IN) :: turbinexw, turbineyw, &
& turbinez
  REAL(dp), DIMENSION(nbdirs, nturbines), intent(out) :: turbinexwb, turbineywb, &
& turbinezb
  INTEGER, DIMENSION(nturbines), INTENT(IN) :: sorted_x_idx
  REAL(dp), DIMENSION(nturbines), INTENT(IN) :: rotordiameter, yawdeg
  REAL(dp), DIMENSION(nbdirs, nturbines), intent(out) :: rotordiameterb, yawdegb
  REAL(dp), DIMENSION(nturbines) :: ct
  REAL(dp), DIMENSION(nbdirs, nturbines), intent(out) :: ctb
  REAL(dp), INTENT(IN) :: ky, kz, alpha, beta, ti, wind_speed, z_ref, &
& z_0, shear_exp, wec_factor
  REAL(dp), DIMENSION(nrotorpoints), INTENT(IN) :: rotorpointsy, &
& rotorpointsz
  REAL(dp), DIMENSION(nctpoints), INTENT(IN) :: ct_curve_wind_speed, &
& ct_curve_ct
  REAL(dp), INTENT(IN) :: sm_smoothing, wec_spreading_angle
  REAL(dp), DIMENSION(nfieldpoints), INTENT(IN) :: fieldpointsx, &
& fieldpointsy, fieldpointsz
! local (General)
  REAL(dp), DIMENSION(nturbines) :: yaw, titurbs, ct_local, ky_local, &
& kz_local
  REAL(dp), DIMENSION(nbdirs, nturbines) :: yawb, titurbsb, ct_localb&
& , ky_localb, kz_localb
  REAL(dp) :: k_star
  REAL(dp), DIMENSION(nbdirs) :: k_starb
  REAL(dp) :: tol, ti_area_ratio
  REAL(dp), DIMENSION(nbdirs) :: ti_area_ratiob
  REAL(dp) :: ti_area_ratio_tmp, ti_dst_tmp, ti_ust_tmp, rpts
  REAL(dp), DIMENSION(nbdirs) :: ti_area_ratio_tmpb, ti_dst_tmpb, &
& ti_ust_tmpb
  REAL(dp) :: localrotorpointy, localrotorpointz
  REAL(dp), DIMENSION(nbdirs) :: localrotorpointyb, localrotorpointzb
  REAL(dp) :: pointx, pointy, pointz, point_velocity_with_shear
  REAL(dp), DIMENSION(nbdirs) :: pointxb, pointyb, pointzb, &
& point_velocity_with_shearb
  REAL(dp) :: x, x0, theta_c_0, deltay, deltax0, sigmay, sigmaz, &
& wake_offset
  REAL(dp), DIMENSION(nbdirs) :: xb, x0b, theta_c_0b, deltayb, &
& sigmayb, sigmazb, wake_offsetb
  INTEGER :: d, u, turbi, p, turb
  REAL(dp), PARAMETER :: pi=3.141592653589793_dp
! model out
  REAL(dp), DIMENSION(nturbines) :: wtvelocity
  REAL(dp), DIMENSION(nbdirs, nturbines) :: wtvelocityb
  REAL(dp), DIMENSION(nfieldpoints) :: fieldvelocity
! initialize intrinsic functions
  INTRINSIC SIN, COS, ATAN, MAX, SQRT, LOG
  INTRINSIC REAL
  INTEGER :: nd
  INTEGER :: branch
  INTEGER :: nbdirs
! bastankhah and porte agel 2016 defines yaw to be positive clockwise, this is 
! reversed from the convention used in plant energy and from typical convention
  yaw = -(yawdeg*pi/180.0_dp)
! set tolerance for location checks
  tol = 0.1_dp
! initialize wind turbine velocities to 0.0
  wtvelocity = 0.0_dp
! initialize local TI of all turbines to free-stream value
  titurbs(:) = ti
! initialize the local wake factors
  IF (calc_k_star .EQV. .true.) THEN
    CALL K_STAR_FUNC(ti, k_star)
    ky_local(:) = k_star
    kz_local(:) = k_star
  ELSE
    ky_local(:) = ky
    kz_local(:) = kz
  END IF
  ct_local(:) = ct
  DO d=1,nturbines
! get index of downstream turbine
    CALL PUSHINTEGER4(turbi)
    turbi = sorted_x_idx(d) + 1
    DO p=1,nrotorpoints
! scale rotor sample point coordinate by rotor diameter (in rotor hub ref. frame)
      localrotorpointy = rotorpointsy(p)*0.5_dp*rotordiameter(turbi)
      localrotorpointz = rotorpointsz(p)*0.5_dp*rotordiameter(turbi)
      CALL PUSHREAL8(pointx)
      pointx = turbinexw(turbi) + localrotorpointy*SIN(yaw(turbi))
      CALL PUSHREAL8(pointy)
      pointy = turbineyw(turbi) + localrotorpointy*COS(yaw(turbi))
      pointz = turbinez(turbi) + localrotorpointz
! calculate the velocity at given point
      CALL POINT_VELOCITY_WITH_SHEAR_FUNC(nturbines, turbi, &
&                                   wake_combination_method, &
&                                   wake_model_version, sorted_x_idx, &
&                                   pointx, pointy, pointz, tol, alpha, &
&                                   beta, wec_spreading_angle, &
&                                   wec_factor, wind_speed, z_ref, z_0, &
&                                   shear_exp, turbinexw, turbineyw, &
&                                   turbinez, rotordiameter, yaw, &
&                                   wtvelocity, ct_local, titurbs, &
&                                   ky_local, kz_local, wech, &
&                                   point_velocity_with_shear)
! add sample point velocity to turbine velocity to be averaged later
      CALL PUSHREAL8(wtvelocity(turbi))
      wtvelocity(turbi) = wtvelocity(turbi) + point_velocity_with_shear
    END DO
! final velocity calculation for turbine turbI (average equally across all points)
    CALL PUSHREAL8(rpts)
    rpts = REAL(nrotorpoints, dp)
    CALL PUSHREAL8(wtvelocity(turbi))
    wtvelocity(turbi) = wtvelocity(turbi)/rpts
! update thrust coefficient for turbI
    IF (use_ct_curve) THEN
      CALL PUSHREAL8(ct_local(turbi))
      CALL INTERPOLATION(nctpoints, interp_type, ct_curve_wind_speed, &
&                  ct_curve_ct, wtvelocity(turbi), ct_local(turbi), &
&                  0.0_dp, 0.0_dp, .false.)
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
! calculate local turbulence intensity at turbI
    IF (ti_calculation_method .GT. 0) THEN
! initialize the TI_area_ratio to 0.0 for each turbine
      ti_area_ratio = 0.0_dp
! initialize local ti tmp
! loop over upstream turbines
      DO u=1,nturbines
! get index of upstream turbine
        CALL PUSHINTEGER4(turb)
        turb = sorted_x_idx(u) + 1
! skip turbine's influence on itself
        IF (turb .EQ. turbi) THEN
          CALL PUSHCONTROL2B(0)
        ELSE
! calculate downstream distance between wind turbines
          x = turbinexw(turbi) - turbinexw(turb)
          IF (x .GT. tol) THEN
! determine the far-wake onset location 
            CALL PUSHREAL8(x0)
            CALL X0_FUNC(rotordiameter(turb), yaw(turb), ct_local(turb)&
&                  , alpha, titurbs(turb), beta, x0)
! calculate the distance from the onset of far-wake
! horizontal spread 
            CALL PUSHREAL8(sigmay)
            CALL SIGMAY_FUNC(x, x0, ky_local(turb), rotordiameter(turb)&
&                      , yaw(turb), sigmay)
! vertical spread 
            CALL PUSHREAL8(sigmaz)
            CALL SIGMAZ_FUNC(x, x0, kz_local(turb), rotordiameter(turb)&
&                      , sigmaz)
! determine the initial wake angle at the onset of far wake
            CALL PUSHREAL8(theta_c_0)
            CALL THETA_C_0_FUNC(yaw(turb), ct_local(turb), theta_c_0)
! horizontal cross-wind wake displacement from hub
            CALL WAKE_OFFSET_FUNC(x, rotordiameter(turb), theta_c_0, x0&
&                           , yaw(turb), ky_local(turb), kz_local(turb)&
&                           , ct_local(turb), sigmay, sigmaz, &
&                           wake_offset)
! cross wind distance from point location to upstream turbine wake center
            CALL PUSHREAL8(deltay)
            deltay = turbineyw(turbi) - (turbineyw(turb)+wake_offset)
! save ti_area_ratio and ti_dst to new memory locations to avoid 
! aliasing during differentiation
            CALL PUSHREAL8(ti_area_ratio_tmp)
            ti_area_ratio_tmp = ti_area_ratio
            CALL PUSHREAL8(ti_dst_tmp)
            ti_dst_tmp = titurbs(turbi)
            CALL PUSHREAL8(ti_ust_tmp)
            ti_ust_tmp = titurbs(turb)
! update local turbulence intensity
            CALL PUSHREAL8(titurbs(turbi))
            CALL ADDED_TI_FUNC(ti, ct_local(turb), x, ky_local(turb), &
&                        rotordiameter(turb), rotordiameter(turbi), &
&                        deltay, turbinez(turb), turbinez(turbi), &
&                        sm_smoothing, ti_ust_tmp, ti_calculation_method&
&                        , ti_area_ratio_tmp, ti_dst_tmp, ti_area_ratio&
&                        , titurbs(turbi))
            CALL PUSHCONTROL2B(2)
          ELSE
            CALL PUSHCONTROL2B(1)
          END IF
        END IF
      END DO
! calculate wake spreading parameter at turbI based on local turbulence intensity
      IF (calc_k_star .EQV. .true.) THEN
        CALL K_STAR_FUNC(titurbs(turbi), k_star)
        CALL PUSHREAL8(ky_local(turbi))
        ky_local(turbi) = k_star
        CALL PUSHREAL8(kz_local(turbi))
        kz_local(turbi) = k_star
        CALL PUSHCONTROL2B(2)
      ELSE
        CALL PUSHCONTROL2B(1)
      END IF
    ELSE
      CALL PUSHCONTROL2B(0)
    END IF
  END DO
  rotordiameterb(:, :) = 0.0_8
  turbinezb(:, :) = 0.0_8
  turbinexwb(:, :) = 0.0_8
  turbineywb(:, :) = 0.0_8
  yawb(:, :) = 0.0_8
  titurbsb(:, :) = 0.0_8
  kz_localb(:, :) = 0.0_8
  ct_localb(:, :) = 0.0_8
  ky_localb(:, :) = 0.0_8
  DO d=nturbines,1,-1
    CALL POPCONTROL2B(branch)
    IF (branch .NE. 0) THEN
      IF (branch .NE. 1) THEN
        turbi = sorted_x_idx(d) + 1
        CALL POPREAL8(kz_local(turbi))
        CALL POPREAL8(ky_local(turbi))
        DO nd=1,nbdirs
          k_starb(nd) = kz_localb(nd, turbi) + ky_localb(nd, turbi)
          kz_localb(nd, turbi) = 0.0_8
          ky_localb(nd, turbi) = 0.0_8
        END DO
        CALL K_STAR_FUNC_BV(titurbs(turbi), titurbsb(1, turbi), k_star, &
&                     k_starb, nbdirs)
      END IF
      ti_area_ratiob(:) = 0.0_8
      DO u=nturbines,1,-1
        CALL POPCONTROL2B(branch)
        IF (branch .NE. 0) THEN
          IF (branch .EQ. 1) THEN
            xb(:) = 0.0_8
          ELSE
            turb = sorted_x_idx(u) + 1
            x = turbinexw(turbi) - turbinexw(turb)
            CALL POPREAL8(titurbs(turbi))
            CALL ADDED_TI_FUNC_BV(ti, ct_local(turb), ct_localb(1, turb)&
&                           , x, xb, ky_local(turb), ky_localb(1, turb)&
&                           , rotordiameter(turb), rotordiameterb(1, &
&                           turb), rotordiameter(turbi), rotordiameterb(&
&                           1, turbi), deltay, deltayb, turbinez(turb), &
&                           turbinezb(1, turb), turbinez(turbi), &
&                           turbinezb(1, turbi), sm_smoothing, &
&                           ti_ust_tmp, ti_ust_tmpb, &
&                           ti_calculation_method, ti_area_ratio_tmp, &
&                           ti_area_ratio_tmpb, ti_dst_tmp, ti_dst_tmpb&
&                           , ti_area_ratio, ti_area_ratiob, titurbs(&
&                           turbi), titurbsb(1, turbi), nbdirs)
            titurbsb(:, turbi) = 0.0_8
            CALL POPREAL8(ti_ust_tmp)
            CALL POPREAL8(ti_dst_tmp)
            CALL POPREAL8(ti_area_ratio_tmp)
            CALL POPREAL8(deltay)
            x0b(:) = 0.0_8
            sigmayb(:) = 0.0_8
            sigmazb(:) = 0.0_8
            DO nd=1,nbdirs
              titurbsb(nd, turb) = titurbsb(nd, turb) + ti_ust_tmpb(nd)
              titurbsb(nd, turbi) = titurbsb(nd, turbi) + ti_dst_tmpb(nd&
&               )
              ti_area_ratiob(nd) = ti_area_ratio_tmpb(nd)
              turbineywb(nd, turbi) = turbineywb(nd, turbi) + deltayb(nd&
&               )
              turbineywb(nd, turb) = turbineywb(nd, turb) - deltayb(nd)
              wake_offsetb(nd) = -deltayb(nd)
            END DO
            CALL WAKE_OFFSET_FUNC_BV(x, xb, rotordiameter(turb), &
&                              rotordiameterb(1, turb), theta_c_0, &
&                              theta_c_0b, x0, x0b, yaw(turb), yawb(1, &
&                              turb), ky_local(turb), ky_localb(1, turb)&
&                              , kz_local(turb), kz_localb(1, turb), &
&                              ct_local(turb), ct_localb(1, turb), &
&                              sigmay, sigmayb, sigmaz, sigmazb, &
&                              wake_offset, wake_offsetb, nbdirs)
            CALL POPREAL8(theta_c_0)
            CALL THETA_C_0_FUNC_BV(yaw(turb), yawb(1, turb), ct_local(&
&                            turb), ct_localb(1, turb), theta_c_0, &
&                            theta_c_0b, nbdirs)
            CALL POPREAL8(sigmaz)
            CALL SIGMAZ_FUNC_BV(x, xb, x0, x0b, kz_local(turb), &
&                         kz_localb(1, turb), rotordiameter(turb), &
&                         rotordiameterb(1, turb), sigmaz, sigmazb, &
&                         nbdirs)
            CALL POPREAL8(sigmay)
            CALL SIGMAY_FUNC_BV(x, xb, x0, x0b, ky_local(turb), &
&                         ky_localb(1, turb), rotordiameter(turb), &
&                         rotordiameterb(1, turb), yaw(turb), yawb(1, &
&                         turb), sigmay, sigmayb, nbdirs)
            CALL POPREAL8(x0)
            CALL X0_FUNC_BV(rotordiameter(turb), rotordiameterb(1, turb)&
&                     , yaw(turb), yawb(1, turb), ct_local(turb), &
&                     ct_localb(1, turb), alpha, titurbs(turb), titurbsb&
&                     (1, turb), beta, x0, x0b, nbdirs)
          END IF
          DO nd=1,nbdirs
            turbinexwb(nd, turbi) = turbinexwb(nd, turbi) + xb(nd)
            turbinexwb(nd, turb) = turbinexwb(nd, turb) - xb(nd)
          END DO
        END IF
        CALL POPINTEGER4(turb)
      END DO
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8(ct_local(turbi))
      CALL INTERPOLATION_BV(nctpoints, interp_type, ct_curve_wind_speed&
&                     , ct_curve_ct, wtvelocity(turbi), wtvelocityb(1, &
&                     turbi), ct_local(turbi), ct_localb(1, turbi), &
&                     0.0_dp, 0.0_dp, .false., nbdirs)
    END IF
    DO nd=1,nbdirs
      wtvelocityb(nd, turbi) = wtvelocityb(nd, turbi)/rpts
    END DO
    CALL POPREAL8(wtvelocity(turbi))
    CALL POPREAL8(rpts)
    DO p=nrotorpoints,1,-1
      DO nd=1,nbdirs
        point_velocity_with_shearb(nd) = wtvelocityb(nd, turbi)
      END DO
      CALL POPREAL8(wtvelocity(turbi))
      localrotorpointz = rotorpointsz(p)*0.5_dp*rotordiameter(turbi)
      pointz = turbinez(turbi) + localrotorpointz
      CALL POINT_VELOCITY_WITH_SHEAR_FUNC_BV(nturbines, turbi, &
&                                      wake_combination_method, &
&                                      wake_model_version, sorted_x_idx&
&                                      , pointx, pointxb, pointy, &
&                                      pointyb, pointz, pointzb, tol, &
&                                      alpha, beta, wec_spreading_angle&
&                                      , wec_factor, wind_speed, z_ref, &
&                                      z_0, shear_exp, turbinexw, &
&                                      turbinexwb, turbineyw, turbineywb&
&                                      , turbinez, turbinezb, &
&                                      rotordiameter, rotordiameterb, &
&                                      yaw, yawb, wtvelocity, &
&                                      wtvelocityb, ct_local, ct_localb&
&                                      , titurbs, titurbsb, ky_local, &
&                                      ky_localb, kz_local, kz_localb, &
&                                      wech, point_velocity_with_shear, &
&                                      point_velocity_with_shearb, &
&                                      nbdirs)
      localrotorpointy = rotorpointsy(p)*0.5_dp*rotordiameter(turbi)
      CALL POPREAL8(pointy)
      CALL POPREAL8(pointx)
      DO nd=1,nbdirs
        turbinezb(nd, turbi) = turbinezb(nd, turbi) + pointzb(nd)
        localrotorpointzb(nd) = pointzb(nd)
        turbineywb(nd, turbi) = turbineywb(nd, turbi) + pointyb(nd)
        localrotorpointyb(nd) = COS(yaw(turbi))*pointyb(nd) + SIN(yaw(&
&         turbi))*pointxb(nd)
        yawb(nd, turbi) = yawb(nd, turbi) + COS(yaw(turbi))*&
&         localrotorpointy*pointxb(nd) - SIN(yaw(turbi))*&
&         localrotorpointy*pointyb(nd)
        turbinexwb(nd, turbi) = turbinexwb(nd, turbi) + pointxb(nd)
        rotordiameterb(nd, turbi) = rotordiameterb(nd, turbi) + &
&         rotorpointsz(p)*0.5_dp*localrotorpointzb(nd) + rotorpointsy(p)&
&         *0.5_dp*localrotorpointyb(nd)
      END DO
    END DO
    CALL POPINTEGER4(turbi)
  END DO
  ctb(:, :) = 0.0_8
  DO nd=1,nbdirs
    ctb(nd, :) = ct_localb(nd, :)
  END DO
  yawdegb(:, :) = 0.0_8
  DO nd=1,nbdirs
    yawdegb(nd, :) = -(pi*yawb(nd, :)/180.0_dp)
  END DO
  wtvelocityb(:, :) = 0.0_8
END SUBROUTINE PORTEAGEL_ANALYZE_BV

!  Differentiation of point_velocity_with_shear_func in reverse (adjoint) mode:
!   gradient     of useful results: yaw rotordiameter turbinez
!                turbinexw wtvelocity point_velocity_with_shear
!                titurbs turbineyw kz_local ct_local ky_local
!   with respect to varying inputs: yaw rotordiameter turbinez
!                turbinexw pointx pointy pointz wtvelocity titurbs
!                turbineyw kz_local ct_local ky_local
SUBROUTINE POINT_VELOCITY_WITH_SHEAR_FUNC_BV(nturbines, turbi, &
& wake_combination_method, wake_model_version, sorted_x_idx, pointx, &
& pointxb, pointy, pointyb, pointz, pointzb, tol, alpha, beta, &
& wec_spreading_angle, wec_factor, wind_speed, z_ref, z_0, shear_exp, &
& turbinexw, turbinexwb, turbineyw, turbineywb, turbinez, turbinezb, &
& rotordiameter, rotordiameterb, yaw, yawb, wtvelocity, wtvelocityb, &
& ct_local, ct_localb, titurbs, titurbsb, ky_local, ky_localb, kz_local&
& , kz_localb, wech, point_velocity_with_shear, &
& point_velocity_with_shearb, nbdirs)
  ! USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  INTEGER, INTENT(IN) :: nturbines, turbi, wake_combination_method, &
& wake_model_version, wech
  INTEGER, DIMENSION(nturbines), INTENT(IN) :: sorted_x_idx
  REAL(dp), INTENT(IN) :: pointx, pointy, pointz
  REAL(dp), DIMENSION(nbdirs) :: pointxb, pointyb, pointzb
  REAL(dp), INTENT(IN) :: tol, alpha, beta, wec_spreading_angle, &
& wec_factor
  REAL(dp), INTENT(IN) :: wind_speed
  REAL(dp), INTENT(IN) :: z_ref, z_0, shear_exp
  REAL(dp), DIMENSION(nturbines), INTENT(IN) :: turbinexw, turbineyw, &
& turbinez
  REAL(dp), DIMENSION(nbdirs, nturbines) :: turbinexwb, turbineywb, &
& turbinezb
  REAL(dp), DIMENSION(nturbines), INTENT(IN) :: rotordiameter, yaw, &
& wtvelocity
  REAL(dp), DIMENSION(nbdirs, nturbines) :: rotordiameterb, yawb, &
& wtvelocityb
  REAL(dp), DIMENSION(nturbines), INTENT(IN) :: ct_local, titurbs, &
& ky_local, kz_local
  REAL(dp), DIMENSION(nbdirs, nturbines) :: ct_localb, titurbsb, &
& ky_localb, kz_localb
! out
  REAL(dp) :: point_velocity_with_shear
  REAL(dp), DIMENSION(nbdirs) :: point_velocity_with_shearb
  REAL(dp) :: wake_offset
  REAL(dp), DIMENSION(nbdirs) :: wake_offsetb
! local
  REAL(dp) :: old_deficit_sum, deficit_sum
  REAL(dp), DIMENSION(nbdirs) :: old_deficit_sumb, deficit_sumb
  REAL(dp) :: x, deltav, x0, theta_c_0, sigmay, sigmaz
  REAL(dp), DIMENSION(nbdirs) :: xb, deltavb, x0b, theta_c_0b, &
& sigmayb, sigmazb
  REAL(dp) :: discontinuity_point, sigmay_d, sigmaz_d
  REAL(dp), DIMENSION(nbdirs) :: discontinuity_pointb, sigmay_db, &
& sigmaz_db
  REAL(dp) :: sigmay_0, sigmaz_0, deltay, deltaz, point_velocity
  REAL(dp), DIMENSION(nbdirs) :: sigmay_0b, sigmaz_0b, deltayb, &
& deltazb, point_velocityb
  REAL(dp) :: sigmay_spread, sigmaz_spread, sigmay_0_spread, &
& sigmaz_0_spread
  REAL(dp), DIMENSION(nbdirs) :: sigmay_spreadb, sigmaz_spreadb, &
& sigmay_0_spreadb, sigmaz_0_spreadb
  INTEGER :: u, turb
  INTEGER :: nd
  INTEGER :: branch
  INTEGER :: nbdirs
! initialize deficit summation term to zero
  deficit_sum = 0.0_dp
! loop through all turbines
! at turbineX-locations
  DO u=1,nturbines
! get index of upstream turbine
    CALL PUSHINTEGER4(turb)
    turb = sorted_x_idx(u) + 1
! skip this loop if turb = turbI (turbines impact on itself)
    IF (turb .EQ. turbi) THEN
      CALL PUSHCONTROL2B(0)
    ELSE
! downstream distance between upstream turbine and point
      x = pointx - turbinexw(turb)
! set this iterations velocity deficit to 0
! check turbine relative locations
      IF (x .GT. tol) THEN
! determine the onset location of far wake
        CALL PUSHREAL8(x0)
        CALL X0_FUNC(rotordiameter(turb), yaw(turb), ct_local(turb), &
&              alpha, titurbs(turb), beta, x0)
! find the final point where the original model is undefined
        CALL PUSHREAL8(discontinuity_point)
        CALL DISCONTINUITY_POINT_FUNC(x0, rotordiameter(turb), ky_local(&
&                               turb), kz_local(turb), yaw(turb), &
&                               ct_local(turb), discontinuity_point)
! horizontal spread at discontinuity point
        CALL PUSHREAL8(sigmay_d)
        CALL SIGMAY_FUNC(discontinuity_point, x0, ky_local(turb), &
&                  rotordiameter(turb), yaw(turb), sigmay_d)
! vertical spread at discontinuity point
        CALL PUSHREAL8(sigmaz_d)
        CALL SIGMAZ_FUNC(discontinuity_point, x0, kz_local(turb), &
&                  rotordiameter(turb), sigmaz_d)
! horizontal spread at far wake onset point
        CALL PUSHREAL8(sigmay_0)
        CALL SIGMAY_FUNC(x0, x0, ky_local(turb), rotordiameter(turb), &
&                  yaw(turb), sigmay_0)
! vertical spread at at far wake onset point
        CALL PUSHREAL8(sigmaz_0)
        CALL SIGMAZ_FUNC(x0, x0, kz_local(turb), rotordiameter(turb), &
&                  sigmaz_0)
! calculate wake spread in horizontal at point of interest
        CALL PUSHREAL8(sigmay)
        CALL SIGMA_SPREAD_FUNC(x, x0, ky_local(turb), sigmay_0, sigmay_d&
&                        , 0.0_dp, 1.0_dp, sigmay)
! calculate wake spread in vertical at point of interest
        CALL PUSHREAL8(sigmaz)
        CALL SIGMA_SPREAD_FUNC(x, x0, kz_local(turb), sigmaz_0, sigmaz_d&
&                        , 0.0_dp, 1.0_dp, sigmaz)
! calculate new spread for WEC in y (horizontal)
        CALL PUSHREAL8(sigmay_spread)
        CALL SIGMA_SPREAD_FUNC(x, x0, ky_local(turb), sigmay_0, sigmay_d&
&                        , wec_spreading_angle, wec_factor, &
&                        sigmay_spread)
! calculate new spread for WEC in z (horizontal)
        CALL PUSHREAL8(sigmaz_spread)
        CALL SIGMA_SPREAD_FUNC(x, x0, kz_local(turb), sigmaz_0, sigmaz_d&
&                        , wec_spreading_angle, wec_factor, &
&                        sigmaz_spread)
! calculate new spread for WEC in y (horizontal) at onset of far wake
        CALL PUSHREAL8(sigmay_0_spread)
        CALL SIGMA_SPREAD_FUNC(x0, x0, ky_local(turb), sigmay_0, &
&                        sigmay_d, wec_spreading_angle, wec_factor, &
&                        sigmay_0_spread)
! calculate new spread for WEC in z (horizontal) at onset of far wake
        CALL PUSHREAL8(sigmaz_0_spread)
        CALL SIGMA_SPREAD_FUNC(x0, x0, kz_local(turb), sigmaz_0, &
&                        sigmaz_d, wec_spreading_angle, wec_factor, &
&                        sigmaz_0_spread)
! determine the initial wake angle at the onset of far wake
        CALL PUSHREAL8(theta_c_0)
        CALL THETA_C_0_FUNC(yaw(turb), ct_local(turb), theta_c_0)
! horizontal cross-wind wake displacement from hub
        CALL WAKE_OFFSET_FUNC(x, rotordiameter(turb), theta_c_0, x0, yaw&
&                       (turb), ky_local(turb), kz_local(turb), ct_local&
&                       (turb), sigmay, sigmaz, wake_offset)
! print *, x
! cross wind distance from point location to upstream turbine wake center
        CALL PUSHREAL8(deltay)
        deltay = pointy - (turbineyw(turb)+wake_offset)
! vertical distance from upstream hub height to height of point of interest
        deltaz = pointz - turbinez(turb)
        IF (x .GT. x0) THEN
! velocity difference in the wake
          CALL PUSHREAL8(deltav)
          CALL DELTAV_FUNC(deltay, deltaz, ct_local(turb), yaw(turb), &
&                    sigmay, sigmaz, rotordiameter(turb), &
&                    wake_model_version, kz_local(turb), x, wec_factor, &
&                    sigmay_spread, sigmaz_spread, deltav)
          CALL PUSHCONTROL1B(0)
        ELSE
! velocity deficit in the nearwake (linear model)
          CALL PUSHREAL8(deltav)
          CALL DELTAV_NEAR_WAKE_LIN_FUNC(deltay, deltaz, ct_local(turb)&
&                                  , yaw(turb), sigmay_0, sigmaz_0, x0, &
&                                  rotordiameter(turb), x, &
&                                  discontinuity_point, sigmay_d, &
&                                  sigmaz_d, wake_model_version, &
&                                  kz_local(turb), x0, sigmay_spread, &
&                                  sigmaz_spread, sigmay_0_spread, &
&                                  sigmaz_0_spread, wec_factor, wech, &
&                                  deltav)
          CALL PUSHCONTROL1B(1)
        END IF
! save deficit sum in holder for AD purposes
        CALL PUSHREAL8(old_deficit_sum)
        old_deficit_sum = deficit_sum
! combine deficits according to selected wake combination method
        CALL WAKE_COMBINATION_FUNC(wind_speed, wtvelocity(turb), deltav&
&                            , wake_combination_method, old_deficit_sum&
&                            , deficit_sum)
        CALL PUSHCONTROL2B(2)
      ELSE
        CALL PUSHCONTROL2B(1)
      END IF
    END IF
  END DO
! find velocity at point without shear
  point_velocity = wind_speed - deficit_sum
! adjust sample point velocity for shear
  CALL WIND_SHEAR_FUNC_BV(pointz, pointzb, point_velocity, &
&                   point_velocityb, z_ref, z_0, shear_exp, &
&                   point_velocity_with_shear, &
&                   point_velocity_with_shearb, nbdirs)
  DO nd=1,nbdirs
    deficit_sumb(nd) = -point_velocityb(nd)
  END DO
  pointxb(:) = 0.0_8
  pointyb(:) = 0.0_8
  DO u=nturbines,1,-1
    CALL POPCONTROL2B(branch)
    IF (branch .NE. 0) THEN
      IF (branch .EQ. 1) THEN
        xb(:) = 0.0_8
      ELSE
        turb = sorted_x_idx(u) + 1
        CALL WAKE_COMBINATION_FUNC_BV(wind_speed, wtvelocity(turb), &
&                               wtvelocityb(1, turb), deltav, deltavb, &
&                               wake_combination_method, old_deficit_sum&
&                               , old_deficit_sumb, deficit_sum, &
&                               deficit_sumb, nbdirs)
        CALL POPREAL8(old_deficit_sum)
        DO nd=1,nbdirs
          deficit_sumb(nd) = old_deficit_sumb(nd)
        END DO
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          x = pointx - turbinexw(turb)
          deltaz = pointz - turbinez(turb)
          CALL POPREAL8(deltav)
          CALL DELTAV_FUNC_BV(deltay, deltayb, deltaz, deltazb, ct_local&
&                       (turb), ct_localb(1, turb), yaw(turb), yawb(1, &
&                       turb), sigmay, sigmayb, sigmaz, sigmazb, &
&                       rotordiameter(turb), rotordiameterb(1, turb), &
&                       wake_model_version, kz_local(turb), kz_localb(1&
&                       , turb), x, xb, wec_factor, sigmay_spread, &
&                       sigmay_spreadb, sigmaz_spread, sigmaz_spreadb, &
&                       deltav, deltavb, nbdirs)
          sigmay_db(:) = 0.0_8
          sigmaz_0b(:) = 0.0_8
          discontinuity_pointb(:) = 0.0_8
          sigmay_0b(:) = 0.0_8
          sigmaz_db(:) = 0.0_8
          x0b(:) = 0.0_8
          sigmaz_0_spreadb(:) = 0.0_8
          sigmay_0_spreadb(:) = 0.0_8
        ELSE
          x = pointx - turbinexw(turb)
          deltaz = pointz - turbinez(turb)
          CALL POPREAL8(deltav)
          CALL DELTAV_NEAR_WAKE_LIN_FUNC_BV(deltay, deltayb, deltaz, &
&                                     deltazb, ct_local(turb), ct_localb&
&                                     (1, turb), yaw(turb), yawb(1, turb&
&                                     ), sigmay_0, sigmay_0b, sigmaz_0, &
&                                     sigmaz_0b, x0, x0b, rotordiameter(&
&                                     turb), rotordiameterb(1, turb), x&
&                                     , xb, discontinuity_point, &
&                                     discontinuity_pointb, sigmay_d, &
&                                     sigmay_db, sigmaz_d, sigmaz_db, &
&                                     wake_model_version, kz_local(turb)&
&                                     , kz_localb(1, turb), x0, &
&                                     sigmay_spread, sigmay_spreadb, &
&                                     sigmaz_spread, sigmaz_spreadb, &
&                                     sigmay_0_spread, sigmay_0_spreadb&
&                                     , sigmaz_0_spread, &
&                                     sigmaz_0_spreadb, wec_factor, wech&
&                                     , deltav, deltavb, nbdirs)
          sigmayb(:) = 0.0_8
          sigmazb(:) = 0.0_8
        END IF
        DO nd=1,nbdirs
          pointzb(nd) = pointzb(nd) + deltazb(nd)
          turbinezb(nd, turb) = turbinezb(nd, turb) - deltazb(nd)
          pointyb(nd) = pointyb(nd) + deltayb(nd)
          turbineywb(nd, turb) = turbineywb(nd, turb) - deltayb(nd)
          wake_offsetb(nd) = -deltayb(nd)
        END DO
        CALL POPREAL8(deltay)
        CALL WAKE_OFFSET_FUNC_BV(x, xb, rotordiameter(turb), &
&                          rotordiameterb(1, turb), theta_c_0, &
&                          theta_c_0b, x0, x0b, yaw(turb), yawb(1, turb)&
&                          , ky_local(turb), ky_localb(1, turb), &
&                          kz_local(turb), kz_localb(1, turb), ct_local(&
&                          turb), ct_localb(1, turb), sigmay, sigmayb, &
&                          sigmaz, sigmazb, wake_offset, wake_offsetb, &
&                          nbdirs)
        CALL POPREAL8(theta_c_0)
        CALL THETA_C_0_FUNC_BV(yaw(turb), yawb(1, turb), ct_local(turb)&
&                        , ct_localb(1, turb), theta_c_0, theta_c_0b, &
&                        nbdirs)
        CALL POPREAL8(sigmaz_0_spread)
        CALL SIGMA_SPREAD_FUNC_BV(x0, x0b, x0, x0b, kz_local(turb), &
&                           kz_localb(1, turb), sigmaz_0, sigmaz_0b, &
&                           sigmaz_d, sigmaz_db, wec_spreading_angle, &
&                           wec_factor, sigmaz_0_spread, &
&                           sigmaz_0_spreadb, nbdirs)
        CALL POPREAL8(sigmay_0_spread)
        CALL SIGMA_SPREAD_FUNC_BV(x0, x0b, x0, x0b, ky_local(turb), &
&                           ky_localb(1, turb), sigmay_0, sigmay_0b, &
&                           sigmay_d, sigmay_db, wec_spreading_angle, &
&                           wec_factor, sigmay_0_spread, &
&                           sigmay_0_spreadb, nbdirs)
        CALL POPREAL8(sigmaz_spread)
        CALL SIGMA_SPREAD_FUNC_BV(x, xb, x0, x0b, kz_local(turb), &
&                           kz_localb(1, turb), sigmaz_0, sigmaz_0b, &
&                           sigmaz_d, sigmaz_db, wec_spreading_angle, &
&                           wec_factor, sigmaz_spread, sigmaz_spreadb, &
&                           nbdirs)
        CALL POPREAL8(sigmay_spread)
        CALL SIGMA_SPREAD_FUNC_BV(x, xb, x0, x0b, ky_local(turb), &
&                           ky_localb(1, turb), sigmay_0, sigmay_0b, &
&                           sigmay_d, sigmay_db, wec_spreading_angle, &
&                           wec_factor, sigmay_spread, sigmay_spreadb, &
&                           nbdirs)
        CALL POPREAL8(sigmaz)
        CALL SIGMA_SPREAD_FUNC_BV(x, xb, x0, x0b, kz_local(turb), &
&                           kz_localb(1, turb), sigmaz_0, sigmaz_0b, &
&                           sigmaz_d, sigmaz_db, 0.0_dp, 1.0_dp, sigmaz&
&                           , sigmazb, nbdirs)
        CALL POPREAL8(sigmay)
        CALL SIGMA_SPREAD_FUNC_BV(x, xb, x0, x0b, ky_local(turb), &
&                           ky_localb(1, turb), sigmay_0, sigmay_0b, &
&                           sigmay_d, sigmay_db, 0.0_dp, 1.0_dp, sigmay&
&                           , sigmayb, nbdirs)
        CALL POPREAL8(sigmaz_0)
        CALL SIGMAZ_FUNC_BV(x0, x0b, x0, x0b, kz_local(turb), kz_localb(&
&                     1, turb), rotordiameter(turb), rotordiameterb(1, &
&                     turb), sigmaz_0, sigmaz_0b, nbdirs)
        CALL POPREAL8(sigmay_0)
        CALL SIGMAY_FUNC_BV(x0, x0b, x0, x0b, ky_local(turb), ky_localb(&
&                     1, turb), rotordiameter(turb), rotordiameterb(1, &
&                     turb), yaw(turb), yawb(1, turb), sigmay_0, &
&                     sigmay_0b, nbdirs)
        CALL POPREAL8(sigmaz_d)
        CALL SIGMAZ_FUNC_BV(discontinuity_point, discontinuity_pointb, &
&                     x0, x0b, kz_local(turb), kz_localb(1, turb), &
&                     rotordiameter(turb), rotordiameterb(1, turb), &
&                     sigmaz_d, sigmaz_db, nbdirs)
        CALL POPREAL8(sigmay_d)
        CALL SIGMAY_FUNC_BV(discontinuity_point, discontinuity_pointb, &
&                     x0, x0b, ky_local(turb), ky_localb(1, turb), &
&                     rotordiameter(turb), rotordiameterb(1, turb), yaw(&
&                     turb), yawb(1, turb), sigmay_d, sigmay_db, nbdirs)
        CALL POPREAL8(discontinuity_point)
        CALL DISCONTINUITY_POINT_FUNC_BV(x0, x0b, rotordiameter(turb), &
&                                  rotordiameterb(1, turb), ky_local(&
&                                  turb), ky_localb(1, turb), kz_local(&
&                                  turb), kz_localb(1, turb), yaw(turb)&
&                                  , yawb(1, turb), ct_local(turb), &
&                                  ct_localb(1, turb), &
&                                  discontinuity_point, &
&                                  discontinuity_pointb, nbdirs)
        CALL POPREAL8(x0)
        CALL X0_FUNC_BV(rotordiameter(turb), rotordiameterb(1, turb), &
&                 yaw(turb), yawb(1, turb), ct_local(turb), ct_localb(1&
&                 , turb), alpha, titurbs(turb), titurbsb(1, turb), beta&
&                 , x0, x0b, nbdirs)
      END IF
      DO nd=1,nbdirs
        pointxb(nd) = pointxb(nd) + xb(nd)
        turbinexwb(nd, turb) = turbinexwb(nd, turb) - xb(nd)
      END DO
    END IF
    CALL POPINTEGER4(turb)
  END DO
END SUBROUTINE POINT_VELOCITY_WITH_SHEAR_FUNC_BV

!  Differentiation of x0_func in reverse (adjoint) mode:
!   gradient     of useful results: ti yaw rotor_diameter x0 ct
!   with respect to varying inputs: ti yaw rotor_diameter ct
! calculates the onset of far-wake conditions
SUBROUTINE X0_FUNC_BV(rotor_diameter, rotor_diameterb, yaw, yawb, ct, &
& ctb, alpha, ti, tib, beta, x0, x0b, nbdirs)
  ! USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: rotor_diameter, yaw, ct, alpha, ti, beta
  REAL(dp), DIMENSION(nbdirs) :: rotor_diameterb, yawb, ctb, tib
! out
  REAL(dp) :: x0
  REAL(dp), DIMENSION(nbdirs) :: x0b
  INTRINSIC COS, SQRT
! determine the onset location of far wake
  INTEGER :: nd
  REAL(dp) :: temp
  REAL(dp) :: temp0
  REAL(dp) :: temp1
  REAL(dp), DIMENSION(nbdirs) :: tempb
  REAL(dp) :: temp2
  REAL(dp) :: temp3
  REAL(dp), DIMENSION(nbdirs) :: tempb0
  INTEGER :: nbdirs
  temp = SQRT(-ct + 1.0_dp)
  temp0 = SQRT(2.0_dp)
  temp1 = temp0*(alpha*ti+beta*(-temp+1.0_dp))
  temp2 = SQRT(-ct + 1.0_dp)
  temp3 = COS(yaw)
  DO nd=1,nbdirs
    tempb(nd) = x0b(nd)/temp1
    rotor_diameterb(nd) = rotor_diameterb(nd) + temp3*(temp2+1.0_dp)*&
&     tempb(nd)
    yawb(nd) = yawb(nd) - SIN(yaw)*rotor_diameter*(temp2+1.0_dp)*tempb(&
&     nd)
    IF (.NOT.1.0_dp - ct .EQ. 0.0) ctb(nd) = ctb(nd) - rotor_diameter*&
&       temp3*tempb(nd)/(2.0*temp2)
    tempb0(nd) = -(temp0*rotor_diameter*temp3*(temp2+1.0_dp)*tempb(nd)/&
&     temp1)
    tib(nd) = tib(nd) + alpha*tempb0(nd)
    IF (.NOT.1.0_dp - ct .EQ. 0.0) ctb(nd) = ctb(nd) + beta*tempb0(nd)/(&
&       2.0*temp)
  END DO
END SUBROUTINE X0_FUNC_BV

!  Differentiation of theta_c_0_func in reverse (adjoint) mode:
!   gradient     of useful results: theta_c_0 yaw ct
!   with respect to varying inputs: yaw ct
! calculates the wake angle at the onset of far wake conditions
SUBROUTINE THETA_C_0_FUNC_BV(yaw, yawb, ct, ctb, theta_c_0, theta_c_0b, &
& nbdirs)
  ! USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: yaw, ct
  REAL(dp), DIMENSION(nbdirs) :: yawb, ctb
! out
  REAL(dp) :: theta_c_0
  REAL(dp), DIMENSION(nbdirs) :: theta_c_0b
  INTRINSIC COS, SQRT
! determine the initial wake angle at the onset of far wake
  INTEGER :: nd
  REAL(dp) :: temp
  REAL(dp) :: temp0
  REAL(dp) :: temp1
  REAL(dp), DIMENSION(nbdirs) :: tempb
  REAL(dp), DIMENSION(nbdirs) :: tempb0
  INTEGER :: nbdirs
  temp = COS(yaw)
  temp0 = COS(yaw)
  temp1 = SQRT(-(ct*temp0) + 1.0_dp)
  DO nd=1,nbdirs
    tempb0(nd) = (1.0_dp-temp1)*0.3_dp*theta_c_0b(nd)/temp
    yawb(nd) = yawb(nd) + (SIN(yaw)*yaw/temp+1.0)*tempb0(nd) + SIN(yaw)*&
&     ct*tempb(nd)
    ctb(nd) = ctb(nd) - temp0*tempb(nd)
  END DO
END SUBROUTINE THETA_C_0_FUNC_BV

!  Differentiation of sigmay_func in reverse (adjoint) mode:
!   gradient     of useful results: yaw x sigmay ky rotor_diameter
!                x0
!   with respect to varying inputs: yaw x ky rotor_diameter x0
! calculates the horizontal spread of the wake at a given distance from the onset of far 
! wake condition
SUBROUTINE SIGMAY_FUNC_BV(x, xb, x0, x0b, ky, kyb, rotor_diameter, &
& rotor_diameterb, yaw, yawb, sigmay, sigmayb, nbdirs)
  ! USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: ky, x, x0, rotor_diameter, yaw
  REAL(dp), DIMENSION(nbdirs) :: kyb, xb, x0b, rotor_diameterb, yawb
! out
  REAL(dp) :: sigmay
  REAL(dp), DIMENSION(nbdirs) :: sigmayb
  INTRINSIC COS, SQRT
! horizontal spread
  INTEGER :: nd
  REAL(dp) :: temp
  INTEGER :: nbdirs
  temp = SQRT(8.0_dp)
  DO nd=1,nbdirs
    kyb(nd) = kyb(nd) + (x-x0)*sigmayb(nd)
    xb(nd) = xb(nd) + ky*sigmayb(nd)
    x0b(nd) = x0b(nd) - ky*sigmayb(nd)
    yawb(nd) = yawb(nd) - SIN(yaw)*rotor_diameter*sigmayb(nd)/temp
    rotor_diameterb(nd) = rotor_diameterb(nd) + COS(yaw)*sigmayb(nd)/&
&     temp
  END DO
END SUBROUTINE SIGMAY_FUNC_BV

!  Differentiation of sigmaz_func in reverse (adjoint) mode:
!   gradient     of useful results: x sigmaz kz rotor_diameter
!                x0
!   with respect to varying inputs: x kz rotor_diameter x0
! calculates the vertical spread of the wake at a given distance from the onset of far 
! wake condition
SUBROUTINE SIGMAZ_FUNC_BV(x, xb, x0, x0b, kz, kzb, rotor_diameter, &
& rotor_diameterb, sigmaz, sigmazb, nbdirs)
  ! USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: kz, x, x0, rotor_diameter
  REAL(dp), DIMENSION(nbdirs) :: kzb, xb, x0b, rotor_diameterb
! out
  REAL(dp) :: sigmaz
  REAL(dp), DIMENSION(nbdirs) :: sigmazb
! load necessary intrinsic functions
  INTRINSIC SQRT
! vertical spread
  INTEGER :: nd
  INTEGER :: nbdirs
  DO nd=1,nbdirs
    kzb(nd) = kzb(nd) + (x-x0)*sigmazb(nd)
    xb(nd) = xb(nd) + kz*sigmazb(nd)
    x0b(nd) = x0b(nd) - kz*sigmazb(nd)
    rotor_diameterb(nd) = rotor_diameterb(nd) + sigmazb(nd)/SQRT(8.0_dp)
  END DO
END SUBROUTINE SIGMAZ_FUNC_BV

!  Differentiation of sigma_spread_func in reverse (adjoint) mode:
!   gradient     of useful results: k sigma_d x sigma_spread sigma_0
!                x0
!   with respect to varying inputs: k sigma_d x sigma_0 x0
SUBROUTINE SIGMA_SPREAD_FUNC_BV(x, xb, x0, x0b, k, kb, sigma_0, sigma_0b&
& , sigma_d, sigma_db, wec_spreading_angle, wec_factor, sigma_spread, &
& sigma_spreadb, nbdirs)
  ! USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
!! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: x, x0, k, sigma_0, sigma_d, &
& wec_spreading_angle, wec_factor
  REAL(dp), DIMENSION(nbdirs) :: xb, x0b, kb, sigma_0b, sigma_db
! out
  REAL(dp) :: sigma_spread
  REAL(dp), DIMENSION(nbdirs) :: sigma_spreadb
! local
  REAL(dp) :: k_near_wake, sigma_0_new, k_spread
  REAL(dp), DIMENSION(nbdirs) :: k_near_wakeb, sigma_0_newb
  REAL(dp), PARAMETER :: pi=3.141592653589793_dp
  INTRINSIC TAN, ATAN
  INTEGER :: nd
  REAL(dp), DIMENSION(nbdirs) :: tempb
  INTEGER :: branch
  INTEGER :: nbdirs
! check if spreading angle is too high
  IF (wec_spreading_angle*pi/180.0_dp .GE. pi/2.0_dp) THEN
    STOP
  ELSE
! get slope of wake expansion in the near wake
    k_near_wake = (sigma_0-sigma_d)/x0
    k_spread = TAN(wec_spreading_angle*pi/180.0_dp)
    IF (k_spread .GT. k_near_wake) THEN
      k_near_wake = k_spread
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
! get new value for wake spread at the point of far wake onset
! get the wake spread at the point of interest
    IF (x .GE. x0 .AND. k .GT. k_near_wake) THEN
      DO nd=1,nbdirs
        tempb(nd) = wec_factor*sigma_spreadb(nd)
        kb(nd) = kb(nd) + (x-x0)*tempb(nd)
        xb(nd) = xb(nd) + k*tempb(nd)
        x0b(nd) = x0b(nd) - k*tempb(nd)
        sigma_0_newb(nd) = tempb(nd)
      END DO
      k_near_wakeb(:) = 0.0_8
    ELSE
      IF (x .GE. 0.0_dp) THEN
        DO nd=1,nbdirs
          tempb(nd) = wec_factor*sigma_spreadb(nd)
          k_near_wakeb(nd) = x*tempb(nd)
          xb(nd) = xb(nd) + k_near_wake*tempb(nd)
          sigma_db(nd) = sigma_db(nd) + tempb(nd)
        END DO
      ELSE
        k_near_wakeb(:) = 0.0_8
      END IF
      sigma_0_newb(:) = 0.0_8
    END IF
    DO nd=1,nbdirs
      k_near_wakeb(nd) = k_near_wakeb(nd) + x0*sigma_0_newb(nd)
      x0b(nd) = x0b(nd) + k_near_wake*sigma_0_newb(nd)
      sigma_db(nd) = sigma_db(nd) + sigma_0_newb(nd)
    END DO
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) k_near_wakeb(:) = 0.0_8
    DO nd=1,nbdirs
      tempb(nd) = k_near_wakeb(nd)/x0
      sigma_0b(nd) = sigma_0b(nd) + tempb(nd)
      sigma_db(nd) = sigma_db(nd) - tempb(nd)
      x0b(nd) = x0b(nd) - (sigma_0-sigma_d)*tempb(nd)/x0
    END DO
  END IF
END SUBROUTINE SIGMA_SPREAD_FUNC_BV

!  Differentiation of wake_offset_func in reverse (adjoint) mode:
!   gradient     of useful results: yaw x sigmay sigmaz ky kz rotor_diameter
!                x0 wake_offset ct
!   with respect to varying inputs: theta_c_0 yaw x sigmay sigmaz
!                ky kz rotor_diameter x0 ct
! calculates the horizontal distance from the wake center to the hub of the turbine making
! the wake
SUBROUTINE WAKE_OFFSET_FUNC_BV(x, xb, rotor_diameter, rotor_diameterb, &
& theta_c_0, theta_c_0b, x0, x0b, yaw, yawb, ky, kyb, kz, kzb, ct, ctb, &
& sigmay, sigmayb, sigmaz, sigmazb, wake_offset, wake_offsetb, nbdirs)
  ! USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: x, rotor_diameter, theta_c_0, x0, yaw, ky, kz&
& , ct, sigmay
  REAL(dp), DIMENSION(nbdirs) :: xb, rotor_diameterb, theta_c_0b, x0b&
& , yawb, kyb, kzb, ctb, sigmayb
  REAL(dp), INTENT(IN) :: sigmaz
  REAL(dp), DIMENSION(nbdirs) :: sigmazb
! local
  REAL(dp) :: a, b, c, d, e, f, g
  REAL(dp), DIMENSION(nbdirs) :: ab, bb, cb, db, eb, fb, gb
! out
  REAL(dp) :: wake_offset
  REAL(dp), DIMENSION(nbdirs) :: wake_offsetb
  INTRINSIC COS, SQRT, LOG
  INTEGER :: nd
  REAL(dp) :: temp
  REAL(dp) :: temp0
  REAL(dp), DIMENSION(nbdirs) :: tempb
  REAL(dp), DIMENSION(nbdirs) :: tempb0
  REAL(dp) :: temp1
  REAL(dp), DIMENSION(nbdirs) :: tempb1
  INTEGER :: nbdirs
  IF (x .LT. x0) THEN
    DO nd=1,nbdirs
      theta_c_0b(nd) = x*wake_offsetb(nd)
      xb(nd) = xb(nd) + theta_c_0*wake_offsetb(nd)
    END DO
  ELSE
    b = rotor_diameter*theta_c_0/14.7_dp
    c = SQRT(COS(yaw)/(ky*kz*ct))
    d = 2.9_dp + 1.3_dp*SQRT(1.0_dp-ct) - ct
    e = 1.6_dp*SQRT(8.0_dp*sigmay*sigmaz/(rotor_diameter**2*COS(yaw)))
    f = (1.6_dp+SQRT(ct))*(e-SQRT(ct))
    g = (1.6_dp-SQRT(ct))*(e+SQRT(ct))
    temp1 = f/g
    temp0 = SQRT(ct)
    DO nd=1,nbdirs
      ab(nd) = wake_offsetb(nd)
      tempb1(nd) = b*c*d*wake_offsetb(nd)/(g*temp1)
      fb(nd) = tempb1(nd)
      gb(nd) = -(temp1*tempb1(nd))
      bb(nd) = c*d*tempb(nd)
      cb(nd) = b*d*tempb(nd)
      db(nd) = b*c*tempb(nd)
      eb(nd) = (1.6_dp-temp0)*gb(nd)
      theta_c_0b(nd) = rotor_diameter*bb(nd)/14.7_dp + x0*ab(nd)
      x0b(nd) = x0b(nd) + theta_c_0*ab(nd)
    END DO
    temp1 = SQRT(ct)
    DO nd=1,nbdirs
      IF (.NOT.ct .EQ. 0.0) ctb(nd) = ctb(nd) - (e+temp1)*gb(nd)/(2.0*&
&         temp0)
      IF (.NOT.ct .EQ. 0.0) ctb(nd) = ctb(nd) + (1.6_dp-temp0)*gb(nd)/(&
&         2.0*temp1)
    END DO
    temp1 = SQRT(ct)
    temp0 = SQRT(ct)
    DO nd=1,nbdirs
      IF (.NOT.ct .EQ. 0.0) ctb(nd) = ctb(nd) + (e-temp1)*fb(nd)/(2.0*&
&         temp0)
      eb(nd) = eb(nd) + (temp0+1.6_dp)*fb(nd)
      IF (.NOT.ct .EQ. 0.0) ctb(nd) = ctb(nd) - (temp0+1.6_dp)*fb(nd)/(&
&         2.0*temp1)
    END DO
    temp0 = COS(yaw)
    temp = rotor_diameter*rotor_diameter*temp0
    temp1 = sigmay*sigmaz/temp
    DO nd=1,nbdirs
      IF (8.0_dp*temp1 .EQ. 0.0) THEN
        tempb1(nd) = 0.0_8
      ELSE
        tempb1(nd) = 8.0_dp*1.6_dp*eb(nd)/(temp*2.0*SQRT(8.0_dp*temp1))
      END IF
      sigmayb(nd) = sigmayb(nd) + sigmaz*tempb1(nd)
      sigmazb(nd) = sigmazb(nd) + sigmay*tempb1(nd)
      tempb0(nd) = -(temp1*tempb1(nd))
      rotor_diameterb(nd) = rotor_diameterb(nd) + 2*rotor_diameter*temp0&
&       *tempb0(nd) + theta_c_0*bb(nd)/14.7_dp
    END DO
    temp = ky*kz*ct
    temp0 = COS(yaw)/temp
    DO nd=1,nbdirs
      IF (temp0 .EQ. 0.0) THEN
        tempb(nd) = 0.0_8
      ELSE
        tempb(nd) = cb(nd)/(temp*2.0*SQRT(temp0))
      END IF
      yawb(nd) = yawb(nd) - SIN(yaw)*rotor_diameter**2*tempb0(nd) - SIN(&
&       yaw)*tempb(nd)
      tempb0(nd) = -(temp0*tempb(nd))
      IF (1.0_dp - ct .EQ. 0.0) THEN
        ctb(nd) = ctb(nd) + ky*kz*tempb0(nd) - db(nd)
      ELSE
        ctb(nd) = ctb(nd) + ky*kz*tempb0(nd) - (1.3_dp/(2.0*SQRT(1.0_dp-&
&         ct))+1.0)*db(nd)
      END IF
      kyb(nd) = kyb(nd) + kz*ct*tempb0(nd)
      kzb(nd) = kzb(nd) + ky*ct*tempb0(nd)
    END DO
  END IF
END SUBROUTINE WAKE_OFFSET_FUNC_BV

!  Differentiation of deltav_func in reverse (adjoint) mode:
!   gradient     of useful results: k yaw rotor_diameter_ust deltav
!                ct
!   with respect to varying inputs: k yaw rotor_diameter_ust sigmay
!                sigmaz sigmay_spread deltax deltay deltaz sigmaz_spread
!                ct
! calculates the velocity difference between hub velocity and free stream for a given wake
! for use in the far wake region
SUBROUTINE DELTAV_FUNC_BV(deltay, deltayb, deltaz, deltazb, ct, ctb, yaw&
& , yawb, sigmay, sigmayb, sigmaz, sigmazb, rotor_diameter_ust, &
& rotor_diameter_ustb, version, k, kb, deltax, deltaxb, wec_factor, &
& sigmay_spread, sigmay_spreadb, sigmaz_spread, sigmaz_spreadb, deltav, &
& deltavb, nbdirs)
  ! USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
!print *, "rotor_diameter in deltav exit", rotor_diameter_ust
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: deltay, deltaz, ct, yaw, sigmay
  REAL(dp), DIMENSION(nbdirs) :: deltayb, deltazb, ctb, yawb, sigmayb
  REAL(dp), INTENT(IN) :: sigmaz, rotor_diameter_ust, wec_factor, &
& sigmay_spread, sigmaz_spread
  REAL(dp), DIMENSION(nbdirs) :: sigmazb, rotor_diameter_ustb, &
& sigmay_spreadb, sigmaz_spreadb
! only for 2014 version
  REAL(dp), INTENT(IN) :: k, deltax
  REAL(dp), DIMENSION(nbdirs) :: kb, deltaxb
  INTEGER, INTENT(IN) :: version
! local
! only for 2014 version
  REAL(dp) :: beta_2014, epsilon_2014
  REAL(dp), DIMENSION(nbdirs) :: beta_2014b, epsilon_2014b
! out
  REAL(dp) :: deltav
  REAL(dp), DIMENSION(nbdirs) :: deltavb
! load intrinsic functions
  INTRINSIC COS, SQRT, EXP
  INTEGER :: nd
  REAL(dp) :: temp
  REAL(dp) :: temp0
  REAL(dp), DIMENSION(nbdirs) :: tempb
  REAL(dp) :: temp1
  REAL(dp) :: temp2
  REAL(dp) :: temp3
  REAL(dp) :: temp4
  REAL(dp) :: temp5
  REAL(dp) :: temp6
  REAL(dp) :: temp7
  REAL(dp), DIMENSION(nbdirs) :: tempb0
  REAL(dp) :: temp8
  REAL(dp), DIMENSION(nbdirs) :: tempb1
  REAL(dp), DIMENSION(nbdirs) :: tempb2
  REAL(dp), DIMENSION(nbdirs) :: tempb3
  REAL(dp), DIMENSION(nbdirs) :: tempb4
  REAL(dp), DIMENSION(nbdirs) :: tempb5
  REAL(dp) :: temp9
  REAL(dp), DIMENSION(nbdirs) :: tempb6
  REAL(dp), DIMENSION(nbdirs) :: tempb7
  REAL(dp), DIMENSION(nbdirs) :: tempb8
  REAL(dp), DIMENSION(nbdirs) :: tempb9
  INTEGER :: nbdirs
!print *, "rotor_diameter in deltav entry", rotor_diameter_ust
!     print *, 'wake model version in deltav: ', version
  IF (version .EQ. 2014) THEN
!print *, "in 2014 version"
    beta_2014 = 0.5_dp*(1.0_dp+SQRT(1.0_dp-ct))/SQRT(1.0_dp-ct)
    epsilon_2014 = 0.2_dp*SQRT(beta_2014)
! print *, "beta = ", beta_2014, "epsilon = ", epsilon_2014
! print *, "k, deltax: ", k, deltax
! print *, "term: ", Ct                                                   &
!                            / (8.0_dp * (k*deltax/rotor_diameter_ust+epsilon_2014)**2)
! print *, "deltav 2014 = ", deltav
    temp1 = k*deltax/rotor_diameter_ust
    temp0 = 2.0_dp*((temp1+epsilon_2014)*(temp1+epsilon_2014))
    temp = deltay/(wec_factor*rotor_diameter_ust)
    temp2 = deltaz/(wec_factor*rotor_diameter_ust)
    temp3 = (temp2*temp2+temp*temp)/temp0
    temp4 = k*deltax/rotor_diameter_ust
    temp5 = 8.0_dp*((temp4+epsilon_2014)*(temp4+epsilon_2014))
    temp6 = ct/temp5
    temp7 = SQRT(-temp6 + 1.0_dp)
    DO nd=1,nbdirs
      tempb3(nd) = -(EXP(-temp3)*(1.0_dp-temp7)*deltavb(nd)/temp0)
      tempb5(nd) = 2*temp*tempb3(nd)/(wec_factor*rotor_diameter_ust)
      tempb6(nd) = -(2*(temp1+epsilon_2014)*2.0_dp*temp3*tempb3(nd))
      tempb7(nd) = tempb6(nd)/rotor_diameter_ust
      rotor_diameter_ustb(nd) = rotor_diameter_ustb(nd) - temp1*tempb7(&
&       nd) - wec_factor*temp*tempb5(nd)
      deltayb(nd) = tempb5(nd)
      tempb1(nd) = -(2*(temp4+epsilon_2014)*8.0_dp*temp6*tempb0(nd))
      epsilon_2014b(nd) = tempb6(nd) + tempb1(nd)
      IF (beta_2014 .EQ. 0.0) THEN
        beta_2014b(nd) = 0.0_8
      ELSE
        beta_2014b(nd) = 0.2_dp*epsilon_2014b(nd)/(2.0*SQRT(beta_2014))
      END IF
    END DO
    temp = SQRT(-ct + 1.0_dp)
    temp1 = SQRT(-ct + 1.0_dp)
    DO nd=1,nbdirs
      tempb(nd) = 0.5_dp*beta_2014b(nd)/temp
      kb(nd) = kb(nd) + deltax*tempb7(nd) + deltax*tempb2(nd)
      deltaxb(nd) = k*tempb7(nd) + k*tempb2(nd)
      deltazb(nd) = tempb4(nd)
      rotor_diameter_ustb(nd) = rotor_diameter_ustb(nd) - wec_factor*&
&       temp2*tempb4(nd) - temp4*tempb2(nd)
      IF (1.0_dp - ct .EQ. 0.0) THEN
        ctb(nd) = ctb(nd) + tempb0(nd)
      ELSE
        ctb(nd) = ctb(nd) + tempb0(nd) - tempb(nd)/(2.0*temp1)
      END IF
      IF (.NOT.1.0_dp - ct .EQ. 0.0) ctb(nd) = ctb(nd) + (temp1+1.0_dp)*&
&         tempb(nd)/(2.0*temp**2)
    END DO
    sigmayb(:) = 0.0_8
    sigmazb(:) = 0.0_8
    sigmay_spreadb(:) = 0.0_8
    sigmaz_spreadb(:) = 0.0_8
  ELSE IF (version .EQ. 2016) THEN
    temp9 = deltaz*deltaz/(sigmaz_spread*sigmaz_spread)
    temp8 = EXP(-(0.5_dp*temp9))
    temp7 = deltay*deltay/(sigmay_spread*sigmay_spread)
    temp6 = EXP(-(0.5_dp*temp7))
    temp5 = 8.0_dp*sigmay*sigmaz
    temp4 = ct*(rotor_diameter_ust*rotor_diameter_ust)/temp5
    temp3 = COS(yaw)
    temp2 = SQRT(-(temp3*temp4) + 1.0_dp)
    DO nd=1,nbdirs
      tempb6(nd) = -(0.5_dp*EXP(-(0.5_dp*temp9))*temp6*(1.0_dp-temp2)*&
&       deltavb(nd)/sigmaz_spread**2)
      deltazb(nd) = 2*deltaz*tempb6(nd)
      sigmaz_spreadb(nd) = -(2*sigmaz_spread*temp9*tempb6(nd))
      deltayb(nd) = 2*deltay*tempb9(nd)
      sigmay_spreadb(nd) = -(2*sigmay_spread*temp7*tempb9(nd))
      yawb(nd) = yawb(nd) + SIN(yaw)*temp4*tempb7(nd)
      tempb2(nd) = -(temp3*tempb7(nd)/temp5)
      ctb(nd) = ctb(nd) + rotor_diameter_ust**2*tempb2(nd)
      rotor_diameter_ustb(nd) = rotor_diameter_ustb(nd) + 2*&
&       rotor_diameter_ust*ct*tempb2(nd)
      tempb8(nd) = -(temp4*tempb2(nd))
      sigmayb(nd) = 8.0_dp*sigmaz*tempb8(nd)
      sigmazb(nd) = 8.0_dp*sigmay*tempb8(nd)
    END DO
    deltaxb(:) = 0.0_8
  ELSE
    STOP
  END IF
END SUBROUTINE DELTAV_FUNC_BV

!  Differentiation of deltav_near_wake_lin_func in reverse (adjoint) mode:
!   gradient     of useful results: k_2014 yaw rotor_diameter_ust
!                deltav ct
!   with respect to varying inputs: sigmay_d k_2014 yaw sigmaz_0
!                discontinuity_point x rotor_diameter_ust sigmay_0
!                sigmay_spread deltay deltaz sigmaz_d x0 sigmaz_spread
!                ct sigmaz_0_spread sigmay_0_spread
! calculates the velocity difference between hub velocity and free stream for a given wake
! for use in the near wake region only
SUBROUTINE DELTAV_NEAR_WAKE_LIN_FUNC_BV(deltay, deltayb, deltaz, deltazb&
& , ct, ctb, yaw, yawb, sigmay_0, sigmay_0b, sigmaz_0, sigmaz_0b, x0, &
& x0b, rotor_diameter_ust, rotor_diameter_ustb, x, xb, &
& discontinuity_point, discontinuity_pointb, sigmay_d, sigmay_db, &
& sigmaz_d, sigmaz_db, version, k_2014, k_2014b, deltaxd_2014, &
& sigmay_spread, sigmay_spreadb, sigmaz_spread, sigmaz_spreadb, &
& sigmay_0_spread, sigmay_0_spreadb, sigmaz_0_spread, sigmaz_0_spreadb, &
& wec_factor_2014, wech, deltav, deltavb, nbdirs)
  ! USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: deltay, deltaz, ct, yaw, sigmay_0, sigmaz_0, &
& x0, sigmay_0_spread, sigmaz_0_spread
  REAL(dp), DIMENSION(nbdirs) :: deltayb, deltazb, ctb, yawb, &
& sigmay_0b, sigmaz_0b, x0b, sigmay_0_spreadb, sigmaz_0_spreadb
  REAL(dp), INTENT(IN) :: rotor_diameter_ust, sigmay_spread, &
& sigmaz_spread
  REAL(dp), DIMENSION(nbdirs) :: rotor_diameter_ustb, sigmay_spreadb&
& , sigmaz_spreadb
  REAL(dp), INTENT(IN) :: x, discontinuity_point, sigmay_d, sigmaz_d
  REAL(dp), DIMENSION(nbdirs) :: xb, discontinuity_pointb, sigmay_db&
& , sigmaz_db
! only for 2014 version
  REAL(dp), INTENT(IN) :: k_2014, deltaxd_2014, wec_factor_2014
  REAL(dp), DIMENSION(nbdirs) :: k_2014b
  INTEGER, INTENT(IN) :: version, wech
! local
  REAL(dp) :: deltav0m, deltavdm, sigmay, sigmaz
  REAL(dp), DIMENSION(nbdirs) :: deltav0mb, deltavdmb, sigmayb, &
& sigmazb
! only for 2014 version
  REAL(dp) :: beta_2014, epsilon_2014
  REAL(dp), DIMENSION(nbdirs) :: beta_2014b, epsilon_2014b
! out
  REAL(dp) :: deltav
  REAL(dp), DIMENSION(nbdirs) :: deltavb
! load intrinsic functions
  INTRINSIC COS, SQRT, EXP
  INTEGER :: nd
  REAL(dp) :: temp
  REAL(dp) :: temp0
  REAL(dp), DIMENSION(nbdirs) :: tempb
  REAL(dp) :: temp1
  REAL(dp), DIMENSION(nbdirs) :: tempb0
  REAL(dp) :: temp2
  REAL(dp), DIMENSION(nbdirs) :: tempb1
  REAL(dp), DIMENSION(nbdirs) :: tempb2
  REAL(dp) :: temp3
  REAL(dp) :: temp4
  REAL(dp), DIMENSION(nbdirs) :: tempb3
  REAL(dp) :: temp5
  REAL(dp), DIMENSION(nbdirs) :: tempb4
  REAL(dp), DIMENSION(nbdirs) :: tempb5
  REAL(dp) :: temp6
  REAL(dp), DIMENSION(nbdirs) :: tempb6
  INTEGER :: nbdirs
  IF (version .EQ. 2014) THEN
!TODO fix 2014 version
    IF (yaw .GT. 0.0_dp) THEN
      STOP
    ELSE
      beta_2014 = 0.5_dp*(1.0_dp+SQRT(1.0_dp-ct))/SQRT(1.0_dp-ct)
      epsilon_2014 = 0.2_dp*SQRT(beta_2014)
! magnitude term of gaussian at x0
      deltav0m = 1.0_dp - SQRT(1.0_dp - ct/(8.0_dp*(k_2014*x0/&
&       rotor_diameter_ust+epsilon_2014)**2))
! initialize the gaussian magnitude term at the rotor for the linear interpolation
      deltavdm = 1.0_dp - SQRT(1.0_dp - ct/(8.0_dp*(k_2014*&
&       discontinuity_point/rotor_diameter_ust+epsilon_2014)**2))
! linearized gaussian magnitude term for near wake
      temp2 = k_2014*x/rotor_diameter_ust
      temp1 = 2.0_dp*((temp2+epsilon_2014)*(temp2+epsilon_2014))
      temp0 = deltay/(wec_factor_2014*rotor_diameter_ust)
      temp = deltaz/(wec_factor_2014*rotor_diameter_ust)
      temp3 = (temp*temp+temp0*temp0)/temp1
      temp5 = x/x0
      DO nd=1,nbdirs
        tempb5(nd) = -(EXP(-temp3)*((deltav0m-deltavdm)*temp5+deltavdm)*&
&         deltavb(nd)/temp1)
        tempb0(nd) = 2*temp*tempb5(nd)/(wec_factor_2014*&
&         rotor_diameter_ust)
        tempb(nd) = 2*temp0*tempb5(nd)/(wec_factor_2014*&
&         rotor_diameter_ust)
        tempb6(nd) = -(2*(temp2+epsilon_2014)*2.0_dp*temp3*tempb5(nd))
        tempb1(nd) = tempb6(nd)/rotor_diameter_ust
        k_2014b(nd) = k_2014b(nd) + x*tempb1(nd)
        rotor_diameter_ustb(nd) = rotor_diameter_ustb(nd) - temp2*tempb1&
&         (nd) - wec_factor_2014*temp0*tempb(nd) - wec_factor_2014*temp*&
&         tempb0(nd)
        deltayb(nd) = tempb(nd)
        deltazb(nd) = tempb0(nd)
        deltav0mb(nd) = temp5*tempb3(nd)
        deltavdmb(nd) = (1.0-temp5)*tempb3(nd)
      END DO
      temp2 = k_2014*discontinuity_point/rotor_diameter_ust
      temp1 = 8.0_dp*((temp2+epsilon_2014)*(temp2+epsilon_2014))
      temp = SQRT(-ct + 1.0_dp)
      DO nd=1,nbdirs
        IF (1.0_dp - ct/temp1 .EQ. 0.0) THEN
          tempb(nd) = 0.0_8
        ELSE
          tempb(nd) = deltavdmb(nd)/(temp1*2.0*SQRT(1.0_dp-ct/temp1))
        END IF
        tempb0(nd) = -(2*(temp2+epsilon_2014)*8.0_dp*ct*tempb(nd)/temp1)
      END DO
      temp1 = k_2014*x0/rotor_diameter_ust
      temp0 = 8.0_dp*((temp1+epsilon_2014)*(temp1+epsilon_2014))
      DO nd=1,nbdirs
        epsilon_2014b(nd) = tempb6(nd) + tempb0(nd)
        xb(nd) = k_2014*tempb1(nd) + tempb4(nd)
        ctb(nd) = ctb(nd) + tempb(nd)
        IF (1.0_dp - ct/temp0 .EQ. 0.0) THEN
          tempb0(nd) = 0.0_8
        ELSE
          tempb0(nd) = deltav0mb(nd)/(temp0*2.0*SQRT(1.0_dp-ct/temp0))
        END IF
        k_2014b(nd) = k_2014b(nd) + discontinuity_point*tempb1(nd)
        discontinuity_pointb(nd) = k_2014*tempb1(nd)
        rotor_diameter_ustb(nd) = rotor_diameter_ustb(nd) - temp2*tempb1&
&         (nd)
        tempb1(nd) = -(2*(temp1+epsilon_2014)*8.0_dp*ct*tempb0(nd)/temp0&
&         )
        epsilon_2014b(nd) = epsilon_2014b(nd) + tempb1(nd)
        IF (beta_2014 .EQ. 0.0) THEN
          beta_2014b(nd) = 0.0_8
        ELSE
          beta_2014b(nd) = 0.2_dp*epsilon_2014b(nd)/(2.0*SQRT(beta_2014)&
&           )
        END IF
        tempb(nd) = 0.5_dp*beta_2014b(nd)/temp
        x0b(nd) = k_2014*tempb2(nd) - temp5*tempb4(nd)
        k_2014b(nd) = k_2014b(nd) + x0*tempb2(nd)
        rotor_diameter_ustb(nd) = rotor_diameter_ustb(nd) - temp1*tempb2&
&         (nd)
      END DO
      temp1 = SQRT(-ct + 1.0_dp)
      DO nd=1,nbdirs
        IF (1.0_dp - ct .EQ. 0.0) THEN
          ctb(nd) = ctb(nd) + tempb0(nd)
        ELSE
          ctb(nd) = ctb(nd) + tempb0(nd) - tempb(nd)/(2.0*temp1)
        END IF
        IF (.NOT.1.0_dp - ct .EQ. 0.0) ctb(nd) = ctb(nd) + (temp1+1.0_dp&
&           )*tempb(nd)/(2.0*temp**2)
      END DO
      sigmay_db(:) = 0.0_8
      sigmaz_0b(:) = 0.0_8
      sigmay_0b(:) = 0.0_8
      sigmay_spreadb(:) = 0.0_8
      sigmaz_db(:) = 0.0_8
      sigmaz_spreadb(:) = 0.0_8
      sigmaz_0_spreadb(:) = 0.0_8
      sigmay_0_spreadb(:) = 0.0_8
    END IF
  ELSE IF (version .EQ. 2016) THEN
! magnitude term of gaussian at x0
    deltav0m = 1.0_dp - SQRT(1.0_dp - ct*COS(yaw)/(8.0_dp*sigmay_0*&
&     sigmaz_0/rotor_diameter_ust**2))
! initialize the gaussian magnitude term at the rotor for the linear interpolation
    deltavdm = 1.0_dp - SQRT(1.0_dp - ct*COS(yaw)/(8.0_dp*sigmay_d*&
&     sigmaz_d/rotor_diameter_ust**2))
    IF (wech .EQ. 0) THEN
      temp6 = deltaz*deltaz/(sigmaz_spread*sigmaz_spread)
      temp4 = deltay*deltay/(sigmay_spread*sigmay_spread)
      temp3 = EXP(-(0.5_dp*temp4))
      temp1 = x/x0
      temp2 = (deltav0m-deltavdm)*temp1 + deltavdm
      DO nd=1,nbdirs
        tempb6(nd) = -(0.5_dp*EXP(-(0.5_dp*temp6))*temp2*temp3*deltavb(&
&         nd)/sigmaz_spread**2)
        deltazb(nd) = 2*deltaz*tempb6(nd)
        sigmaz_spreadb(nd) = -(2*sigmaz_spread*temp6*tempb6(nd))
        tempb1(nd) = temp3*tempb4(nd)
        tempb3(nd) = -(0.5_dp*EXP(-(0.5_dp*temp4))*temp2*tempb4(nd)/&
&         sigmay_spread**2)
        deltayb(nd) = 2*deltay*tempb3(nd)
        sigmay_spreadb(nd) = -(2*sigmay_spread*temp4*tempb3(nd))
        deltav0mb(nd) = temp1*tempb1(nd)
        deltavdmb(nd) = (1.0-temp1)*tempb1(nd)
        tempb2(nd) = (deltav0m-deltavdm)*tempb1(nd)/x0
        xb(nd) = tempb2(nd)
        x0b(nd) = -(temp1*tempb2(nd))
      END DO
      sigmaz_0b(:) = 0.0_8
      sigmay_0b(:) = 0.0_8
      sigmaz_0_spreadb(:) = 0.0_8
      sigmay_0_spreadb(:) = 0.0_8
    ELSE
! linearized gaussian magnitude term for near wake for WECH
      sigmay = (sigmay_0_spread-sigmay_0)/x0*x + sigmay_0
      sigmaz = (sigmaz_0_spread-sigmay_0)/x0*x + sigmaz_0
      temp6 = deltaz*deltaz/(sigmaz*sigmaz)
      temp4 = deltay*deltay/(sigmay*sigmay)
      temp3 = EXP(-(0.5_dp*temp4))
      temp1 = x/x0
      temp2 = (deltav0m-deltavdm)*temp1 + deltavdm
      DO nd=1,nbdirs
        tempb6(nd) = -(0.5_dp*EXP(-(0.5_dp*temp6))*temp2*temp3*deltavb(&
&         nd)/sigmaz**2)
        deltazb(nd) = 2*deltaz*tempb6(nd)
        sigmazb(nd) = -(2*sigmaz*temp6*tempb6(nd))
        tempb6(nd) = (sigmaz_0_spread-sigmay_0)*sigmazb(nd)/x0
        deltayb(nd) = 2*deltay*tempb3(nd)
        sigmayb(nd) = -(2*sigmay*temp4*tempb3(nd))
        deltav0mb(nd) = temp1*tempb1(nd)
        deltavdmb(nd) = (1.0-temp1)*tempb1(nd)
        xb(nd) = tempb2(nd) + tempb6(nd)
        sigmaz_0b(nd) = sigmazb(nd)
      END DO
      temp6 = x/x0
      DO nd=1,nbdirs
        x0b(nd) = -(temp1*tempb2(nd)) - temp6*tempb6(nd)
        sigmaz_0_spreadb(nd) = temp6*sigmazb(nd)
        sigmay_0b(nd) = -(temp6*sigmazb(nd))
        tempb6(nd) = (sigmay_0_spread-sigmay_0)*sigmayb(nd)/x0
        xb(nd) = xb(nd) + tempb6(nd)
      END DO
      temp6 = x/x0
      DO nd=1,nbdirs
        sigmay_0_spreadb(nd) = temp6*sigmayb(nd)
        sigmay_0b(nd) = sigmay_0b(nd) + (1.0-temp6)*sigmayb(nd)
        x0b(nd) = x0b(nd) - temp6*tempb6(nd)
      END DO
      sigmay_spreadb(:) = 0.0_8
      sigmaz_spreadb(:) = 0.0_8
    END IF
    temp6 = 8.0_dp*sigmay_d*sigmaz_d
    temp5 = ct*(rotor_diameter_ust*rotor_diameter_ust)/temp6
    temp4 = COS(yaw)
    DO nd=1,nbdirs
      IF (1.0_dp - temp4*temp5 .EQ. 0.0) THEN
        tempb5(nd) = 0.0_8
      ELSE
        tempb5(nd) = -(deltavdmb(nd)/(2.0*SQRT(1.0_dp-temp4*temp5)))
      END IF
      yawb(nd) = yawb(nd) + SIN(yaw)*temp5*tempb5(nd)
      tempb4(nd) = -(temp4*tempb5(nd)/temp6)
      ctb(nd) = ctb(nd) + rotor_diameter_ust**2*tempb4(nd)
      rotor_diameter_ustb(nd) = rotor_diameter_ustb(nd) + 2*&
&       rotor_diameter_ust*ct*tempb4(nd)
      tempb6(nd) = -(temp5*tempb4(nd))
      sigmay_db(nd) = 8.0_dp*sigmaz_d*tempb6(nd)
      sigmaz_db(nd) = 8.0_dp*sigmay_d*tempb6(nd)
    END DO
    temp6 = 8.0_dp*sigmay_0*sigmaz_0
    temp5 = ct*(rotor_diameter_ust*rotor_diameter_ust)/temp6
    temp4 = COS(yaw)
    DO nd=1,nbdirs
      IF (1.0_dp - temp4*temp5 .EQ. 0.0) THEN
        tempb5(nd) = 0.0_8
      ELSE
        tempb5(nd) = -(deltav0mb(nd)/(2.0*SQRT(1.0_dp-temp4*temp5)))
      END IF
      yawb(nd) = yawb(nd) + SIN(yaw)*temp5*tempb5(nd)
      tempb4(nd) = -(temp4*tempb5(nd)/temp6)
      ctb(nd) = ctb(nd) + rotor_diameter_ust**2*tempb4(nd)
      rotor_diameter_ustb(nd) = rotor_diameter_ustb(nd) + 2*&
&       rotor_diameter_ust*ct*tempb4(nd)
      tempb6(nd) = -(temp5*tempb4(nd))
      sigmay_0b(nd) = sigmay_0b(nd) + 8.0_dp*sigmaz_0*tempb6(nd)
      sigmaz_0b(nd) = sigmaz_0b(nd) + 8.0_dp*sigmay_0*tempb6(nd)
    END DO
    discontinuity_pointb(:) = 0.0_8
  ELSE
    STOP
  END IF
END SUBROUTINE DELTAV_NEAR_WAKE_LIN_FUNC_BV

!  Differentiation of wake_combination_func in reverse (adjoint) mode:
!   gradient     of useful results: turb_inflow new_deficit_sum
!   with respect to varying inputs: turb_inflow old_deficit_sum
!                deltav
! combines wakes using various methods
SUBROUTINE WAKE_COMBINATION_FUNC_BV(wind_speed, turb_inflow, &
& turb_inflowb, deltav, deltavb, wake_combination_method, &
& old_deficit_sum, old_deficit_sumb, new_deficit_sum, new_deficit_sumb, &
& nbdirs)
  ! USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: wind_speed, turb_inflow, deltav, &
& old_deficit_sum
  REAL(dp), DIMENSION(nbdirs) :: turb_inflowb, deltavb, &
& old_deficit_sumb
  INTEGER, INTENT(IN) :: wake_combination_method
! out    
  REAL(dp) :: new_deficit_sum
  REAL(dp), DIMENSION(nbdirs) :: new_deficit_sumb
! intrinsic functions
  INTRINSIC SQRT
  INTEGER :: nd
  REAL(dp), DIMENSION(nbdirs) :: tempb
  REAL(dp), DIMENSION(nbdirs) :: tempb0
  INTEGER :: nbdirs
! freestream linear superposition (Lissaman 1979)
  IF (wake_combination_method .EQ. 0) THEN
    DO nd=1,nbdirs
      old_deficit_sumb(nd) = new_deficit_sumb(nd)
      deltavb(nd) = wind_speed*new_deficit_sumb(nd)
    END DO
  ELSE IF (wake_combination_method .EQ. 1) THEN
    DO nd=1,nbdirs
      old_deficit_sumb(nd) = new_deficit_sumb(nd)
      turb_inflowb(nd) = turb_inflowb(nd) + deltav*new_deficit_sumb(nd)
      deltavb(nd) = turb_inflow*new_deficit_sumb(nd)
    END DO
  ELSE IF (wake_combination_method .EQ. 2) THEN
    DO nd=1,nbdirs
      IF (old_deficit_sum**2 + (wind_speed*deltav)**2 .EQ. 0.0) THEN
        tempb(nd) = 0.0_8
      ELSE
        tempb(nd) = new_deficit_sumb(nd)/(2.0*SQRT(old_deficit_sum**2+(&
&         wind_speed*deltav)**2))
      END IF
      old_deficit_sumb(nd) = 2*old_deficit_sum*tempb(nd)
      deltavb(nd) = wind_speed**2*2*deltav*tempb(nd)
    END DO
  ELSE IF (wake_combination_method .EQ. 3) THEN
    DO nd=1,nbdirs
      IF (old_deficit_sum**2 + (turb_inflow*deltav)**2 .EQ. 0.0) THEN
        tempb(nd) = 0.0_8
      ELSE
        tempb(nd) = new_deficit_sumb(nd)/(2.0*SQRT(old_deficit_sum**2+(&
&         turb_inflow*deltav)**2))
      END IF
      old_deficit_sumb(nd) = 2*old_deficit_sum*tempb(nd)
      tempb0(nd) = 2*turb_inflow*deltav*tempb(nd)
      turb_inflowb(nd) = turb_inflowb(nd) + deltav*tempb0(nd)
      deltavb(nd) = turb_inflow*tempb0(nd)
    END DO
  ELSE
    STOP
  END IF
END SUBROUTINE WAKE_COMBINATION_FUNC_BV

!  Differentiation of added_ti_func in reverse (adjoint) mode:
!   gradient     of useful results: k_star_ust rotor_diameter_ust
!                wake_height turbine_height ti_dst ct_ust ti_area_ratio
!                rotor_diameter_dst
!   with respect to varying inputs: k_star_ust x rotor_diameter_ust
!                wake_height turbine_height ti_dst_in ct_ust deltay
!                ti_area_ratio_in rotor_diameter_dst ti_ust
! combines wakes using various methods
SUBROUTINE ADDED_TI_FUNC_BV(ti, ct_ust, ct_ustb, x, xb, k_star_ust, &
& k_star_ustb, rotor_diameter_ust, rotor_diameter_ustb, &
& rotor_diameter_dst, rotor_diameter_dstb, deltay, deltayb, wake_height&
& , wake_heightb, turbine_height, turbine_heightb, sm_smoothing, ti_ust&
& , ti_ustb, ti_calculation_method, ti_area_ratio_in, ti_area_ratio_inb&
& , ti_dst_in, ti_dst_inb, ti_area_ratio, ti_area_ratiob, ti_dst, &
& ti_dstb, nbdirs)
  ! USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
!print *, "ratio: ", wake_overlap/rotor_area_dst
!print *, "Dr, Dw: ", rotor_diameter_dst, wake_diameter
!print *, "Ar, Aol: ", rotor_area_dst, wake_overlap          
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: ct_ust, x, k_star_ust, rotor_diameter_ust, &
& rotor_diameter_dst
  REAL(dp), DIMENSION(nbdirs) :: ct_ustb, xb, k_star_ustb, &
& rotor_diameter_ustb, rotor_diameter_dstb
  REAL(dp), INTENT(IN) :: deltay, wake_height, turbine_height, &
& sm_smoothing
  REAL(dp), DIMENSION(nbdirs) :: deltayb, wake_heightb, &
& turbine_heightb
  REAL(dp), INTENT(IN) :: ti_ust, ti, ti_area_ratio_in, ti_dst_in
  REAL(dp), DIMENSION(nbdirs) :: ti_ustb, ti_area_ratio_inb, &
& ti_dst_inb
  INTEGER, INTENT(IN) :: ti_calculation_method
! local
  REAL(dp) :: axial_induction_ust, beta, epsilon, sigma, wake_diameter, &
& wake_overlap
  REAL(dp), DIMENSION(nbdirs) :: axial_induction_ustb, betab, &
& epsilonb, sigmab, wake_diameterb, wake_overlapb
  REAL(dp) :: ti_added, ti_tmp, rotor_area_dst, ti_area_ratio_tmp
  REAL(dp), DIMENSION(nbdirs) :: ti_addedb, ti_tmpb, rotor_area_dstb&
& , ti_area_ratio_tmpb
  REAL(dp), PARAMETER :: pi=3.141592653589793_dp
! out  
  REAL(dp) :: ti_dst, ti_area_ratio
  REAL(dp), DIMENSION(nbdirs) :: ti_dstb, ti_area_ratiob
! intrinsic functions
  INTRINSIC SQRT
  INTEGER :: nd
  REAL(dp) :: temp
  REAL(dp) :: temp0
  REAL(dp), DIMENSION(nbdirs) :: tempb
  REAL(dp) :: temp1
  REAL(dp) :: temp2
  REAL(dp), DIMENSION(nbdirs) :: tempb0
  REAL(dp), DIMENSION(nbdirs) :: tempb1
  INTEGER :: nbdirs
! initialize output variables
! initialize wake overlap to zero
!print *, "TI_dst in: ", TI_dst
! Niayifar and Porte Agel 2015, 2016 (adjusted by Annoni and Thomas for SOWFA match 
! and optimization)
  IF (ti_calculation_method .EQ. 1) THEN
! calculate axial induction based on the Ct value
    CALL CT_TO_AXIAL_IND_FUNC(ct_ust, axial_induction_ust)
! calculate BPA spread parameters Bastankhah and Porte Agel 2014
    beta = 0.5_dp*((1.0_dp+SQRT(1.0_dp-ct_ust))/SQRT(1.0_dp-ct_ust))
    epsilon = 0.2_dp*SQRT(beta)
!print *, "epsilon = ", epsilon
! calculate wake spread for TI calcs
    sigma = k_star_ust*x + rotor_diameter_ust*epsilon
    wake_diameter = 4.0_dp*sigma
!print *, "sigma = ", sigma
! calculate wake overlap ratio
    CALL OVERLAP_AREA_FUNC(deltay, turbine_height, rotor_diameter_dst, &
&                    0.0_dp, wake_height, wake_diameter, wake_overlap)
!print *, "wake_overlap = ", wake_overlap   
! Calculate the turbulence added to the inflow of the downstream turbine by the 
! wake of the upstream turbine
    ti_added = 0.73_dp*axial_induction_ust**0.8325_dp*ti_ust**0.0325_dp*&
&     (x/rotor_diameter_ust)**(-0.32_dp)
!print *, "TI_added = ", TI_added
    rotor_area_dst = 0.25_dp*pi*rotor_diameter_dst**2_dp
! Calculate the total turbulence intensity at the downstream turbine
!sum_of_squares = TI_dst**2 + (TI_added*wake_overlap)**2
! print *, "sum of squares = ", sum_of_squares
!         TI_dst = sqrt(sum_of_squares)
!         !print *, "TI_dst = ", TI_dst
! Niayifar and Porte Agel 2015, 2016
    temp2 = ti_added*wake_overlap/rotor_area_dst
    temp1 = x/rotor_diameter_ust
    temp = ti_ust**0.0325_dp
    DO nd=1,nbdirs
      IF (ti_dst_in**2.0_dp + temp2**2.0_dp .EQ. 0.0) THEN
        tempb0(nd) = 0.0_8
      ELSE
        tempb0(nd) = ti_dstb(nd)/(2.0*SQRT(ti_dst_in**2.0_dp+temp2**&
&         2.0_dp))
      END IF
      ti_dst_inb(nd) = 2.0_dp*ti_dst_in*tempb0(nd)
      tempb1(nd) = 2.0_dp*temp2*tempb0(nd)/rotor_area_dst
      ti_addedb(nd) = wake_overlap*tempb1(nd)
      wake_overlapb(nd) = ti_added*tempb1(nd)
      rotor_area_dstb(nd) = -(temp2*tempb1(nd))
      rotor_diameter_dstb(nd) = rotor_diameter_dstb(nd) + 2_dp*&
&       rotor_diameter_dst*pi*0.25_dp*rotor_area_dstb(nd)
    END DO
    temp2 = axial_induction_ust**0.8325_dp
    CALL OVERLAP_AREA_FUNC_BV(deltay, deltayb, turbine_height, &
&                       turbine_heightb, rotor_diameter_dst, &
&                       rotor_diameter_dstb, 0.0_dp, wake_height, &
&                       wake_heightb, wake_diameter, wake_diameterb, &
&                       wake_overlap, wake_overlapb, nbdirs)
    DO nd=1,nbdirs
      sigmab(nd) = 4.0_dp*wake_diameterb(nd)
      tempb0(nd) = -(0.32_dp*temp1**(-1.32)*temp2*temp*0.73_dp*ti_addedb&
&       (nd)/rotor_diameter_ust)
      xb(nd) = tempb0(nd) + k_star_ust*sigmab(nd)
      rotor_diameter_ustb(nd) = rotor_diameter_ustb(nd) + epsilon*sigmab&
&       (nd) - temp1*tempb0(nd)
      axial_induction_ustb(nd) = 0.8325_dp*axial_induction_ust**(-0.1675&
&       )*temp*tempb(nd)
      ti_ustb(nd) = 0.0325_dp*ti_ust**(-0.9675)*temp2*tempb(nd)
      k_star_ustb(nd) = k_star_ustb(nd) + x*sigmab(nd)
      epsilonb(nd) = rotor_diameter_ust*sigmab(nd)
      IF (beta .EQ. 0.0) THEN
        betab(nd) = 0.0_8
      ELSE
        betab(nd) = 0.2_dp*epsilonb(nd)/(2.0*SQRT(beta))
      END IF
    END DO
    temp = SQRT(-ct_ust + 1.0_dp)
    temp1 = SQRT(-ct_ust + 1.0_dp)
    DO nd=1,nbdirs
      tempb(nd) = 0.5_dp*betab(nd)/temp
      IF (.NOT.1.0_dp - ct_ust .EQ. 0.0) ct_ustb(nd) = ct_ustb(nd) - &
&         tempb(nd)/(2.0*temp1)
      IF (.NOT.1.0_dp - ct_ust .EQ. 0.0) ct_ustb(nd) = ct_ustb(nd) + (&
&         temp1+1.0_dp)*tempb(nd)/(2.0*temp**2)
    END DO
    CALL CT_TO_AXIAL_IND_FUNC_BV(ct_ust, ct_ustb, axial_induction_ust, &
&                          axial_induction_ustb, nbdirs)
    ti_dstb(:) = 0.0_8
    ti_area_ratio_inb(:) = 0.0_8
  ELSE IF (ti_calculation_method .EQ. 2) THEN
! calculate axial induction based on the Ct value
    CALL CT_TO_AXIAL_IND_FUNC(ct_ust, axial_induction_ust)
! calculate BPA spread parameters Bastankhah and Porte Agel 2014
    beta = 0.5_dp*((1.0_dp+SQRT(1.0_dp-ct_ust))/SQRT(1.0_dp-ct_ust))
    epsilon = 0.2_dp*SQRT(beta)
! calculate wake spread for TI calcs
    sigma = k_star_ust*x + rotor_diameter_ust*epsilon
    wake_diameter = 4.0_dp*sigma
! calculate wake overlap ratio
    CALL OVERLAP_AREA_FUNC(deltay, turbine_height, rotor_diameter_dst, &
&                    0.0_dp, wake_height, wake_diameter, wake_overlap)
! Calculate the turbulence added to the inflow of the downstream turbine by the 
! wake of the upstream turbine
    ti_added = 0.73_dp*axial_induction_ust**0.8325_dp*ti_ust**0.0325_dp*&
&     (x/rotor_diameter_ust)**(-0.32_dp)
! Calculate the total turbulence intensity at the downstream turbine based on 
! current upstream turbine
    rotor_area_dst = 0.25_dp*pi*rotor_diameter_dst**2_dp
    ti_tmp = SQRT(ti**2.0_dp + (ti_added*(wake_overlap/rotor_area_dst))&
&     **2.0_dp)
! Check if this is the max and use it if it is
    IF (ti_tmp .GT. ti_dst_in) THEN
      DO nd=1,nbdirs
        ti_tmpb(nd) = ti_dstb(nd)
      END DO
      ti_dstb(:) = 0.0_8
    ELSE
      ti_tmpb(:) = 0.0_8
    END IF
    temp2 = ti_added*wake_overlap/rotor_area_dst
    temp0 = ti_ust**0.0325_dp
    temp = axial_induction_ust**0.8325_dp
    DO nd=1,nbdirs
      IF (ti**2.0_dp + temp2**2.0_dp .EQ. 0.0) THEN
        tempb1(nd) = 0.0_8
      ELSE
        tempb1(nd) = 2.0_dp*temp2*ti_tmpb(nd)/(rotor_area_dst*2.0*SQRT(&
&         ti**2.0_dp+temp2**2.0_dp))
      END IF
      ti_addedb(nd) = wake_overlap*tempb1(nd)
      wake_overlapb(nd) = ti_added*tempb1(nd)
      rotor_area_dstb(nd) = -(temp2*tempb1(nd))
      rotor_diameter_dstb(nd) = rotor_diameter_dstb(nd) + 2_dp*&
&       rotor_diameter_dst*pi*0.25_dp*rotor_area_dstb(nd)
    END DO
    temp2 = x/rotor_diameter_ust
    CALL OVERLAP_AREA_FUNC_BV(deltay, deltayb, turbine_height, &
&                       turbine_heightb, rotor_diameter_dst, &
&                       rotor_diameter_dstb, 0.0_dp, wake_height, &
&                       wake_heightb, wake_diameter, wake_diameterb, &
&                       wake_overlap, wake_overlapb, nbdirs)
    DO nd=1,nbdirs
      sigmab(nd) = 4.0_dp*wake_diameterb(nd)
      tempb1(nd) = -(0.32_dp*temp2**(-1.32)*temp*temp0*0.73_dp*ti_addedb&
&       (nd)/rotor_diameter_ust)
      xb(nd) = tempb1(nd) + k_star_ust*sigmab(nd)
      rotor_diameter_ustb(nd) = rotor_diameter_ustb(nd) + epsilon*sigmab&
&       (nd) - temp2*tempb1(nd)
      axial_induction_ustb(nd) = 0.8325_dp*axial_induction_ust**(-0.1675&
&       )*temp0*tempb0(nd)
      ti_ustb(nd) = 0.0325_dp*ti_ust**(-0.9675)*temp*tempb0(nd)
      k_star_ustb(nd) = k_star_ustb(nd) + x*sigmab(nd)
      epsilonb(nd) = rotor_diameter_ust*sigmab(nd)
      IF (beta .EQ. 0.0) THEN
        betab(nd) = 0.0_8
      ELSE
        betab(nd) = 0.2_dp*epsilonb(nd)/(2.0*SQRT(beta))
      END IF
    END DO
    temp2 = SQRT(-ct_ust + 1.0_dp)
    temp0 = SQRT(-ct_ust + 1.0_dp)
    DO nd=1,nbdirs
      tempb0(nd) = 0.5_dp*betab(nd)/temp2
      IF (.NOT.1.0_dp - ct_ust .EQ. 0.0) ct_ustb(nd) = ct_ustb(nd) - &
&         tempb0(nd)/(2.0*temp0)
      IF (.NOT.1.0_dp - ct_ust .EQ. 0.0) ct_ustb(nd) = ct_ustb(nd) + (&
&         temp0+1.0_dp)*tempb0(nd)/(2.0*temp2**2)
    END DO
    CALL CT_TO_AXIAL_IND_FUNC_BV(ct_ust, ct_ustb, axial_induction_ust, &
&                          axial_induction_ustb, nbdirs)
    ti_dst_inb(:) = 0.0_8
    ti_area_ratio_inb(:) = 0.0_8
  ELSE IF (ti_calculation_method .EQ. 3) THEN
! Niayifar and Porte Agel 2015, 2016 with smooth max
! calculate axial induction based on the Ct value
    CALL CT_TO_AXIAL_IND_FUNC(ct_ust, axial_induction_ust)
! calculate BPA spread parameters Bastankhah and Porte Agel 2014
    beta = 0.5_dp*((1.0_dp+SQRT(1.0_dp-ct_ust))/SQRT(1.0_dp-ct_ust))
    epsilon = 0.2_dp*SQRT(beta)
! calculate wake spread for TI calcs
    sigma = k_star_ust*x + rotor_diameter_ust*epsilon
    wake_diameter = 4.0_dp*sigma
!         print *, "sigma, k_star_ust, x, rotor_diameter_ust, epsilon ", sigma, k_star_ust, x, rotor_diameter_ust, epsilon
! print *, "deltay, turbine_height, rotor_diameter_dst, wake_height, wake_diameter", &
!                 & deltay, turbine_height, rotor_diameter_dst, &
!                             wake_height, wake_diameter
! calculate wake overlap ratio
    CALL OVERLAP_AREA_FUNC(deltay, turbine_height, rotor_diameter_dst, &
&                    0.0_dp, wake_height, wake_diameter, wake_overlap)
! Calculate the turbulence added to the inflow of the downstream turbine by the 
! wake of the upstream turbine
    ti_added = 0.73_dp*axial_induction_ust**0.8325_dp*ti_ust**0.0325_dp*&
&     (x/rotor_diameter_ust)**(-0.32_dp)
! Calculate the total turbulence intensity at the downstream turbine based on 
! current upstream turbine
    rotor_area_dst = 0.25_dp*pi*rotor_diameter_dst**2_dp
    ti_tmp = SQRT(ti**2.0_dp + (ti_added*(wake_overlap/rotor_area_dst))&
&     **2.0_dp)
!print *, "TI, TI_added, wake_overlap, rotor_area_dst: ", TI, TI_added, wake_overlap, rotor_area_dst
! Check if this is the max and use it if it is
!if (TI_tmp > TI_dst) then
!    TI_dst = TI_tmp
!end if
!         print *, "before: ", TI_dst, TI_tmp
!         TI_dst_in = TI_dst
!         print *, "after:: ", TI_dst, TI_tmp
! Niayifar and Porte Agel 2015, 2016 using max on area TI ratio
    CALL SMOOTH_MAX_BV(sm_smoothing, ti_dst_in, ti_dst_inb, ti_tmp, &
&                ti_tmpb, ti_dst, ti_dstb, nbdirs)
    temp2 = ti_added*wake_overlap/rotor_area_dst
    temp0 = ti_ust**0.0325_dp
    temp = axial_induction_ust**0.8325_dp
    DO nd=1,nbdirs
      IF (ti**2.0_dp + temp2**2.0_dp .EQ. 0.0) THEN
        tempb1(nd) = 0.0_8
      ELSE
        tempb1(nd) = 2.0_dp*temp2*ti_tmpb(nd)/(rotor_area_dst*2.0*SQRT(&
&         ti**2.0_dp+temp2**2.0_dp))
      END IF
      ti_addedb(nd) = wake_overlap*tempb1(nd)
      wake_overlapb(nd) = ti_added*tempb1(nd)
      rotor_area_dstb(nd) = -(temp2*tempb1(nd))
      rotor_diameter_dstb(nd) = rotor_diameter_dstb(nd) + 2_dp*&
&       rotor_diameter_dst*pi*0.25_dp*rotor_area_dstb(nd)
    END DO
    temp2 = x/rotor_diameter_ust
    CALL OVERLAP_AREA_FUNC_BV(deltay, deltayb, turbine_height, &
&                       turbine_heightb, rotor_diameter_dst, &
&                       rotor_diameter_dstb, 0.0_dp, wake_height, &
&                       wake_heightb, wake_diameter, wake_diameterb, &
&                       wake_overlap, wake_overlapb, nbdirs)
    DO nd=1,nbdirs
      sigmab(nd) = 4.0_dp*wake_diameterb(nd)
      tempb1(nd) = -(0.32_dp*temp2**(-1.32)*temp*temp0*0.73_dp*ti_addedb&
&       (nd)/rotor_diameter_ust)
      xb(nd) = tempb1(nd) + k_star_ust*sigmab(nd)
      rotor_diameter_ustb(nd) = rotor_diameter_ustb(nd) + epsilon*sigmab&
&       (nd) - temp2*tempb1(nd)
      axial_induction_ustb(nd) = 0.8325_dp*axial_induction_ust**(-0.1675&
&       )*temp0*tempb0(nd)
      ti_ustb(nd) = 0.0325_dp*ti_ust**(-0.9675)*temp*tempb0(nd)
      k_star_ustb(nd) = k_star_ustb(nd) + x*sigmab(nd)
      epsilonb(nd) = rotor_diameter_ust*sigmab(nd)
      IF (beta .EQ. 0.0) THEN
        betab(nd) = 0.0_8
      ELSE
        betab(nd) = 0.2_dp*epsilonb(nd)/(2.0*SQRT(beta))
      END IF
    END DO
    temp2 = SQRT(-ct_ust + 1.0_dp)
    temp0 = SQRT(-ct_ust + 1.0_dp)
    DO nd=1,nbdirs
      tempb0(nd) = 0.5_dp*betab(nd)/temp2
      IF (.NOT.1.0_dp - ct_ust .EQ. 0.0) ct_ustb(nd) = ct_ustb(nd) - &
&         tempb0(nd)/(2.0*temp0)
      IF (.NOT.1.0_dp - ct_ust .EQ. 0.0) ct_ustb(nd) = ct_ustb(nd) + (&
&         temp0+1.0_dp)*tempb0(nd)/(2.0*temp2**2)
    END DO
    CALL CT_TO_AXIAL_IND_FUNC_BV(ct_ust, ct_ustb, axial_induction_ust, &
&                          axial_induction_ustb, nbdirs)
    ti_dstb(:) = 0.0_8
    ti_area_ratio_inb(:) = 0.0_8
  ELSE
    IF (ti_calculation_method .EQ. 4) THEN
! calculate axial induction based on the Ct value
      CALL CT_TO_AXIAL_IND_FUNC(ct_ust, axial_induction_ust)
! calculate BPA spread parameters Bastankhah and Porte Agel 2014
      beta = 0.5_dp*((1.0_dp+SQRT(1.0_dp-ct_ust))/SQRT(1.0_dp-ct_ust))
      epsilon = 0.2_dp*SQRT(beta)
! calculate wake spread for TI calcs
      sigma = k_star_ust*x + rotor_diameter_ust*epsilon
      wake_diameter = 4.0_dp*sigma
! calculate wake overlap ratio
      CALL OVERLAP_AREA_FUNC(deltay, turbine_height, rotor_diameter_dst&
&                      , 0.0_dp, wake_height, wake_diameter, &
&                      wake_overlap)
! Calculate the turbulence added to the inflow of the downstream turbine by the 
! wake of the upstream turbine
      ti_added = 0.73_dp*axial_induction_ust**0.8325_dp*ti_ust**&
&       0.0325_dp*(x/rotor_diameter_ust)**(-0.32_dp)
! Calculate the total turbulence intensity at the downstream turbine based on 
! current upstream turbine
      rotor_area_dst = 0.25_dp*pi*rotor_diameter_dst**2_dp
      ti_area_ratio_tmp = ti_added*(wake_overlap/rotor_area_dst)
! Check if this is the max and use it if it is
      IF (ti_area_ratio_tmp .GT. ti_area_ratio_in) THEN
!            print *, "ti_area_ratio_tmp > ti_area_ratio"
!TI_dst = TI_tmp
        ti_area_ratio = ti_area_ratio_tmp
        DO nd=1,nbdirs
          IF (.NOT.ti**2.0_dp + ti_area_ratio**2.0_dp .EQ. 0.0) &
&           ti_area_ratiob(nd) = ti_area_ratiob(nd) + 2.0_dp*&
&             ti_area_ratio*ti_dstb(nd)/(2.0*SQRT(ti**2.0_dp+&
&             ti_area_ratio**2.0_dp))
          ti_area_ratio_tmpb(nd) = ti_area_ratiob(nd)
        END DO
        ti_dstb(:) = 0.0_8
        ti_area_ratiob(:) = 0.0_8
      ELSE
        ti_area_ratio_tmpb(:) = 0.0_8
      END IF
      temp2 = x/rotor_diameter_ust
      temp0 = ti_ust**0.0325_dp
      temp = axial_induction_ust**0.8325_dp
      DO nd=1,nbdirs
        tempb1(nd) = ti_area_ratio_tmpb(nd)/rotor_area_dst
        ti_addedb(nd) = wake_overlap*tempb1(nd)
        wake_overlapb(nd) = ti_added*tempb1(nd)
        rotor_area_dstb(nd) = -(ti_added*wake_overlap*tempb1(nd)/&
&         rotor_area_dst)
        rotor_diameter_dstb(nd) = rotor_diameter_dstb(nd) + 2_dp*&
&         rotor_diameter_dst*pi*0.25_dp*rotor_area_dstb(nd)
        tempb1(nd) = -(0.32_dp*temp2**(-1.32)*temp*temp0*0.73_dp*&
&         ti_addedb(nd)/rotor_diameter_ust)
        axial_induction_ustb(nd) = 0.8325_dp*axial_induction_ust**(&
&         -0.1675)*temp0*tempb0(nd)
        ti_ustb(nd) = 0.0325_dp*ti_ust**(-0.9675)*temp*tempb0(nd)
      END DO
      CALL OVERLAP_AREA_FUNC_BV(deltay, deltayb, turbine_height, &
&                         turbine_heightb, rotor_diameter_dst, &
&                         rotor_diameter_dstb, 0.0_dp, wake_height, &
&                         wake_heightb, wake_diameter, wake_diameterb, &
&                         wake_overlap, wake_overlapb, nbdirs)
      temp0 = SQRT(-ct_ust + 1.0_dp)
      DO nd=1,nbdirs
        sigmab(nd) = 4.0_dp*wake_diameterb(nd)
        xb(nd) = tempb1(nd) + k_star_ust*sigmab(nd)
        rotor_diameter_ustb(nd) = rotor_diameter_ustb(nd) + epsilon*&
&         sigmab(nd) - temp2*tempb1(nd)
        k_star_ustb(nd) = k_star_ustb(nd) + x*sigmab(nd)
        epsilonb(nd) = rotor_diameter_ust*sigmab(nd)
        IF (beta .EQ. 0.0) THEN
          betab(nd) = 0.0_8
        ELSE
          betab(nd) = 0.2_dp*epsilonb(nd)/(2.0*SQRT(beta))
        END IF
      END DO
      temp2 = SQRT(-ct_ust + 1.0_dp)
      DO nd=1,nbdirs
        tempb0(nd) = 0.5_dp*betab(nd)/temp2
        IF (.NOT.1.0_dp - ct_ust .EQ. 0.0) ct_ustb(nd) = ct_ustb(nd) - &
&           tempb0(nd)/(2.0*temp0)
        IF (.NOT.1.0_dp - ct_ust .EQ. 0.0) ct_ustb(nd) = ct_ustb(nd) + (&
&           temp0+1.0_dp)*tempb0(nd)/(2.0*temp2**2)
      END DO
      CALL CT_TO_AXIAL_IND_FUNC_BV(ct_ust, ct_ustb, axial_induction_ust&
&                            , axial_induction_ustb, nbdirs)
      ti_area_ratio_inb(:) = 0.0_8
    ELSE IF (ti_calculation_method .EQ. 5) THEN
! Niayifar and Porte Agel 2015, 2016 using smooth max on area TI ratio
! calculate axial induction based on the Ct value
      CALL CT_TO_AXIAL_IND_FUNC(ct_ust, axial_induction_ust)
! calculate BPA spread parameters Bastankhah and Porte Agel 2014
      beta = 0.5_dp*((1.0_dp+SQRT(1.0_dp-ct_ust))/SQRT(1.0_dp-ct_ust))
      epsilon = 0.2_dp*SQRT(beta)
! calculate wake spread for TI calcs
      sigma = k_star_ust*x + rotor_diameter_ust*epsilon
      wake_diameter = 4.0_dp*sigma
! calculate wake overlap ratio
      CALL OVERLAP_AREA_FUNC(deltay, turbine_height, rotor_diameter_dst&
&                      , 0.0_dp, wake_height, wake_diameter, &
&                      wake_overlap)
! only include turbines with area overlap in the softmax
      IF (wake_overlap .GT. 0.0_dp) THEN
! Calculate the turbulence added to the inflow of the downstream turbine by the 
! wake of the upstream turbine
        ti_added = 0.73_dp*axial_induction_ust**0.8325_dp*ti_ust**&
&         0.0325_dp*(x/rotor_diameter_ust)**(-0.32_dp)
        rotor_area_dst = 0.25_dp*pi*rotor_diameter_dst**2_dp
        ti_area_ratio_tmp = ti_added*(wake_overlap/rotor_area_dst)
!TI_tmp = sqrt(TI**2.0_dp + (TI_added*(wake_overlap/rotor_area_dst))**2.0_dp)
! Run through the smooth max to get an approximation of the true max TI area ratio
        CALL SMOOTH_MAX(sm_smoothing, ti_area_ratio_in, &
&                 ti_area_ratio_tmp, ti_area_ratio)
! Calculate the total turbulence intensity at the downstream turbine based on 
! the result of the smooth max function
        DO nd=1,nbdirs
          IF (.NOT.ti**2.0_dp + ti_area_ratio**2.0_dp .EQ. 0.0) &
&           ti_area_ratiob(nd) = ti_area_ratiob(nd) + 2.0_dp*&
&             ti_area_ratio*ti_dstb(nd)/(2.0*SQRT(ti**2.0_dp+&
&             ti_area_ratio**2.0_dp))
        END DO
        CALL SMOOTH_MAX_BV(sm_smoothing, ti_area_ratio_in, &
&                    ti_area_ratio_inb, ti_area_ratio_tmp, &
&                    ti_area_ratio_tmpb, ti_area_ratio, ti_area_ratiob, &
&                    nbdirs)
        temp2 = x/rotor_diameter_ust
        temp0 = ti_ust**0.0325_dp
        temp = axial_induction_ust**0.8325_dp
        DO nd=1,nbdirs
          tempb1(nd) = ti_area_ratio_tmpb(nd)/rotor_area_dst
          ti_addedb(nd) = wake_overlap*tempb1(nd)
          wake_overlapb(nd) = ti_added*tempb1(nd)
          rotor_area_dstb(nd) = -(ti_added*wake_overlap*tempb1(nd)/&
&           rotor_area_dst)
          rotor_diameter_dstb(nd) = rotor_diameter_dstb(nd) + 2_dp*&
&           rotor_diameter_dst*pi*0.25_dp*rotor_area_dstb(nd)
          tempb1(nd) = -(0.32_dp*temp2**(-1.32)*temp*temp0*0.73_dp*&
&           ti_addedb(nd)/rotor_diameter_ust)
          xb(nd) = tempb1(nd)
          rotor_diameter_ustb(nd) = rotor_diameter_ustb(nd) - temp2*&
&           tempb1(nd)
          axial_induction_ustb(nd) = 0.8325_dp*axial_induction_ust**(&
&           -0.1675)*temp0*tempb0(nd)
          ti_ustb(nd) = 0.0325_dp*ti_ust**(-0.9675)*temp*tempb0(nd)
        END DO
        ti_dstb(:) = 0.0_8
        ti_area_ratiob(:) = 0.0_8
      ELSE
        xb(:) = 0.0_8
        ti_area_ratio_inb(:) = 0.0_8
        ti_ustb(:) = 0.0_8
        axial_induction_ustb(:) = 0.0_8
        wake_overlapb(:) = 0.0_8
      END IF
      CALL OVERLAP_AREA_FUNC_BV(deltay, deltayb, turbine_height, &
&                         turbine_heightb, rotor_diameter_dst, &
&                         rotor_diameter_dstb, 0.0_dp, wake_height, &
&                         wake_heightb, wake_diameter, wake_diameterb, &
&                         wake_overlap, wake_overlapb, nbdirs)
      temp2 = SQRT(-ct_ust + 1.0_dp)
      temp0 = SQRT(-ct_ust + 1.0_dp)
      DO nd=1,nbdirs
        sigmab(nd) = 4.0_dp*wake_diameterb(nd)
        k_star_ustb(nd) = k_star_ustb(nd) + x*sigmab(nd)
        xb(nd) = xb(nd) + k_star_ust*sigmab(nd)
        rotor_diameter_ustb(nd) = rotor_diameter_ustb(nd) + epsilon*&
&         sigmab(nd)
        epsilonb(nd) = rotor_diameter_ust*sigmab(nd)
        IF (beta .EQ. 0.0) THEN
          betab(nd) = 0.0_8
        ELSE
          betab(nd) = 0.2_dp*epsilonb(nd)/(2.0*SQRT(beta))
        END IF
        tempb0(nd) = 0.5_dp*betab(nd)/temp2
        IF (.NOT.1.0_dp - ct_ust .EQ. 0.0) ct_ustb(nd) = ct_ustb(nd) - &
&           tempb0(nd)/(2.0*temp0)
        IF (.NOT.1.0_dp - ct_ust .EQ. 0.0) ct_ustb(nd) = ct_ustb(nd) + (&
&           temp0+1.0_dp)*tempb0(nd)/(2.0*temp2**2)
      END DO
      CALL CT_TO_AXIAL_IND_FUNC_BV(ct_ust, ct_ustb, axial_induction_ust&
&                            , axial_induction_ustb, nbdirs)
    ELSE
! wake combination method error 
      STOP
    END IF
    ti_dst_inb(:) = 0.0_8
  END IF
  DO nd=1,nbdirs
    ti_dst_inb(nd) = ti_dst_inb(nd) + ti_dstb(nd)
    ti_area_ratio_inb(nd) = ti_area_ratio_inb(nd) + ti_area_ratiob(nd)
  END DO
END SUBROUTINE ADDED_TI_FUNC_BV

!  Differentiation of overlap_area_func in reverse (adjoint) mode:
!   gradient     of useful results: rotor_diameter turbine_z wake_center_z
!                wake_overlap
!   with respect to varying inputs: wake_diameter rotor_diameter
!                turbine_y turbine_z wake_center_z
! calculates the overlap area between a given wake and a rotor area
SUBROUTINE OVERLAP_AREA_FUNC_BV(turbine_y, turbine_yb, turbine_z, &
& turbine_zb, rotor_diameter, rotor_diameterb, wake_center_y, &
& wake_center_z, wake_center_zb, wake_diameter, wake_diameterb, &
& wake_overlap, wake_overlapb, nbdirs)
  ! USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: turbine_y, turbine_z, rotor_diameter
  REAL(dp), DIMENSION(nbdirs) :: turbine_yb, turbine_zb, &
& rotor_diameterb
  REAL(dp), INTENT(IN) :: wake_center_y, wake_center_z, wake_diameter
  REAL(dp), DIMENSION(nbdirs) :: wake_center_zb, wake_diameterb
! out    
  REAL(dp) :: wake_overlap
  REAL(dp), DIMENSION(nbdirs) :: wake_overlapb
! local
  REAL(dp), PARAMETER :: pi=3.141592653589793_dp, tol=0.000001_dp
  REAL(dp) :: ovdyd, ovr, ovrr, ovl, ovz, ovz2
  REAL(dp), DIMENSION(nbdirs) :: ovdydb, ovrb, ovrrb, ovlb, ovzb, &
& ovz2b
! load intrinsic functions
  INTRINSIC ACOS, SQRT
  INTEGER :: nd
  REAL(dp) :: temp
  REAL(dp), DIMENSION(nbdirs) :: tempb
  REAL(dp) :: temp0
  REAL(dp), DIMENSION(nbdirs) :: tempb0
  INTEGER :: branch
  INTEGER :: nbdirs
!     print *, turbine_y, turbine_z, rotor_diameter, &
!                             wake_center_y, wake_center_z, wake_diameter, &
!                             wake_overlap
! distance between wake center and rotor center
  IF (wake_center_z .GT. turbine_z + tol .OR. wake_center_z .LT. &
&     turbine_z - tol) THEN
    ovdyd = SQRT((wake_center_y-turbine_y)**2_dp + (wake_center_z-&
&     turbine_z)**2_dp)
    CALL PUSHCONTROL2B(0)
  ELSE IF (wake_center_y .GT. turbine_y + tol) THEN
! potential source of gradient issues, abs() did not cause a problem in FLORIS
    ovdyd = wake_center_y - turbine_y
    CALL PUSHCONTROL2B(1)
  ELSE IF (turbine_y .GT. wake_center_y + tol) THEN
    ovdyd = turbine_y - wake_center_y
    CALL PUSHCONTROL2B(2)
  ELSE
    ovdyd = 0.0_dp
    CALL PUSHCONTROL2B(3)
  END IF
!print *, "OVdYd: ", OVdYd
! find rotor radius
  ovr = rotor_diameter/2.0_dp
!print *, "OVr: ", OVr
! find wake radius
  ovrr = wake_diameter/2.0_dp
!print *, "OVRR: ", OVRR
! make sure the distance from wake center to turbine hub is positive
! OVdYd = abs(OVdYd) !!! commented out since change to 2D distance (y,z) will always be positive
! calculate the distance from the wake center to the line perpendicular to the 
! line between the two circle intersection points
!if (OVdYd >= 0.0_dp + tol) then ! check case to avoid division by zero
!     print *, "OVdYd ", OVdYd
! if (OVdYd >= 0.0_dp + tol) then ! check case to avoid division by zero
!         OVL = (-OVr*OVr+OVRR*OVRR+OVdYd*OVdYd)/(2.0_dp*OVdYd)
! !         print *, "OVdYd, OVL: ", OVdYd, OVL
!     else
!         OVL = 0.0_dp
!     end if
! 
!     OVz = OVRR*OVRR-OVL*OVL
! 
!     ! Finish calculating the distance from the intersection line to the outer edge of the wake
!     !if (OVz > 0.0_dp + tol) then
!     if (OVz > 0.0_dp + tol) then
!         OVz = sqrt(OVz)
!     else
!         OVz = 0.0_dp
!     end if
!print *, "OVRR, OVL, OVRR, OVr, OVdYd, OVz ", OVRR, OVL, OVRR, OVr, OVdYd, OVz
! if (OVdYd < (OVr+OVRR)) then ! if the rotor overlaps the wake
!         !print *, "OVL: ", OVL
!         if (OVL < OVRR .and. (OVdYd-OVL) < OVr) then
! !         if (OVdYd > 0.0_dp + tol) then
! !         if ((OVdYd > 0.0_dp) .and. (OVdYd > (OVRR - OVr))) then
!             ! print *, "acos(OVL/OVRR), acos((OVdYd-OVL)/OVr), OVRR, OVL, OVr, OVdYd, OVL/OVRR, (OVdYd-OVL)/OVr ", &
! !     & acos(OVL/OVRR), acos((OVdYd-OVL)/OVr), OVRR, OVL, OVr, OVdYd, OVL/OVRR, (OVdYd-OVL)/OVr
!             wake_overlap = OVRR*OVRR*acos(OVL/OVRR) + OVr*OVr*acos((OVdYd-OVL)/OVr) - OVdYd*OVz
!         else if (OVRR > OVr) then
!             wake_overlap = pi*OVr*OVr
!             !print *, "wake ovl: ", wake_overlap
!         else
!             wake_overlap = pi*OVRR*OVRR
!         end if
!     else
!         wake_overlap = 0.0_dp
!     end if
! determine if there is overlap
  IF (ovdyd .LT. ovr + ovrr) THEN
! if the rotor overlaps the wake zone
! check that turbine and wake centers are not perfectly aligned
    IF (ovdyd .GT. 0.0_dp + tol) THEN
! check if the rotor is wholly contained in the wake
      IF (ovdyd + ovr .LT. ovrr + tol) THEN
        wake_overlap = pi*ovr*ovr
!                 print *, "1"
! check if the wake is wholly contained in the rotor swept area
        CALL PUSHCONTROL3B(0)
      ELSE IF (ovdyd + ovrr .LT. ovr + tol) THEN
        wake_overlap = pi*ovrr*ovrr
!                 print *, "2"
        CALL PUSHCONTROL3B(1)
      ELSE
! calculate the distance from the wake center to the chord connecting the lens
! cusps
        ovl = (-(ovr*ovr)+ovrr*ovrr+ovdyd*ovdyd)/(2.0_dp*ovdyd)
        ovz = SQRT(ovrr*ovrr - ovl*ovl)
        ovz2 = SQRT(ovr*ovr - (ovdyd-ovl)*(ovdyd-ovl))
        wake_overlap = ovrr*ovrr*ACOS(ovl/ovrr) + ovr*ovr*ACOS((ovdyd-&
&         ovl)/ovr) - ovl*ovz - (ovdyd-ovl)*ovz2
!                 print *, OVRR, OVr, OVdYd, OVL, OVz, OVz2
!                 print *, "3"
        CALL PUSHCONTROL3B(2)
      END IF
    ELSE IF (ovrr .GT. ovr) THEN
! perfect overlap case where the wake is larger than the rotor
      wake_overlap = pi*ovr*ovr
!             print *, "4"
! perfect overlap case where the rotor is larger than the wake
      CALL PUSHCONTROL3B(3)
    ELSE
      wake_overlap = pi*ovrr*ovrr
!             print *, "5"
      CALL PUSHCONTROL3B(4)
    END IF
  ELSE
! case with no overlap
    wake_overlap = 0.0_dp
    CALL PUSHCONTROL3B(5)
  END IF
!     print *, "wake overlap in func: ", wake_overlap/(pi*OVr**2)
!     print *, "wake overlap in func: ", wake_overlap/(pi*OVRR**2)
  IF (wake_overlap/(pi*ovr*ovr) .GT. 1.0_dp + tol .OR. wake_overlap/(pi*&
&     ovrr*ovrr) .GT. 1.0_dp + tol) THEN
    STOP
  ELSE
    CALL POPCONTROL3B(branch)
    IF (branch .LT. 3) THEN
      IF (branch .EQ. 0) THEN
        DO nd=1,nbdirs
          ovrb(nd) = 2*ovr*pi*wake_overlapb(nd)
        END DO
        ovdydb(:) = 0.0_8
        ovrrb(:) = 0.0_8
      ELSE IF (branch .EQ. 1) THEN
        DO nd=1,nbdirs
          ovrrb(nd) = 2*ovrr*pi*wake_overlapb(nd)
        END DO
        ovdydb(:) = 0.0_8
        ovrb(:) = 0.0_8
      ELSE
        temp0 = ovl/ovrr
        temp = (ovdyd-ovl)/ovr
        DO nd=1,nbdirs
          IF (temp .EQ. 1.0 .OR. temp .EQ. (-1.0)) THEN
            tempb(nd) = 0.0_8
          ELSE
            tempb(nd) = -(ovr*wake_overlapb(nd)/SQRT(1.0-temp**2))
          END IF
          ovrrb(nd) = 2*ovrr*ACOS(temp0)*wake_overlapb(nd) - temp0*&
&           tempb0(nd)
          ovlb(nd) = (ovz2-ovz)*wake_overlapb(nd) + tempb0(nd) - tempb(&
&           nd)
          ovzb(nd) = -(ovl*wake_overlapb(nd))
          ovdydb(nd) = tempb(nd) - ovz2*wake_overlapb(nd)
          ovz2b(nd) = -((ovdyd-ovl)*wake_overlapb(nd))
          IF (ovr**2 - (ovdyd-ovl)**2 .EQ. 0.0) THEN
            tempb0(nd) = 0.0_8
          ELSE
            tempb0(nd) = ovz2b(nd)/(2.0*SQRT(ovr**2-(ovdyd-ovl)**2))
          END IF
          ovrb(nd) = 2*ovr*ACOS(temp)*wake_overlapb(nd) + 2*ovr*tempb0(&
&           nd) - temp*tempb(nd)
          IF (ovrr**2 - ovl**2 .EQ. 0.0) THEN
            tempb0(nd) = 0.0_8
          ELSE
            tempb0(nd) = ovzb(nd)/(2.0*SQRT(ovrr**2-ovl**2))
          END IF
          ovlb(nd) = ovlb(nd) - tempb(nd) - 2*ovl*tempb0(nd)
          ovrrb(nd) = ovrrb(nd) + 2*ovrr*tempb0(nd)
          tempb0(nd) = ovlb(nd)/(2.0_dp*ovdyd)
          ovdydb(nd) = ovdydb(nd) + tempb(nd) + (2*ovdyd-(ovrr**2-ovr**2&
&           +ovdyd**2)/ovdyd)*tempb0(nd)
          ovrrb(nd) = ovrrb(nd) + 2*ovrr*tempb0(nd)
          ovrb(nd) = ovrb(nd) - 2*ovr*tempb0(nd)
        END DO
      END IF
    ELSE
      IF (branch .EQ. 3) THEN
        DO nd=1,nbdirs
          ovrb(nd) = 2*ovr*pi*wake_overlapb(nd)
        END DO
        ovrrb(:) = 0.0_8
      ELSE IF (branch .EQ. 4) THEN
        DO nd=1,nbdirs
          ovrrb(nd) = 2*ovrr*pi*wake_overlapb(nd)
        END DO
        ovrb(:) = 0.0_8
      ELSE
        ovdydb(:) = 0.0_8
        ovrb(:) = 0.0_8
        ovrrb(:) = 0.0_8
        GOTO 100
      END IF
      ovdydb(:) = 0.0_8
    END IF
 100 DO nd=1,nbdirs
      wake_diameterb(nd) = ovrrb(nd)/2.0_dp
      rotor_diameterb(nd) = rotor_diameterb(nd) + ovrb(nd)/2.0_dp
    END DO
    CALL POPCONTROL2B(branch)
    IF (branch .LT. 2) THEN
      IF (branch .EQ. 0) THEN
        DO nd=1,nbdirs
          IF ((wake_center_y-turbine_y)**2_dp + (wake_center_z-turbine_z&
&             )**2_dp .EQ. 0.0) THEN
            tempb(nd) = 0.0_8
          ELSE
            tempb(nd) = ovdydb(nd)/(2.0*SQRT((wake_center_y-turbine_y)**&
&             2_dp+(wake_center_z-turbine_z)**2_dp))
          END IF
          turbine_yb(nd) = -(2_dp*(wake_center_y-turbine_y)*tempb(nd))
          tempb0(nd) = 2_dp*(wake_center_z-turbine_z)*tempb(nd)
          wake_center_zb(nd) = wake_center_zb(nd) + tempb0(nd)
          turbine_zb(nd) = turbine_zb(nd) - tempb0(nd)
        END DO
      ELSE
        DO nd=1,nbdirs
          turbine_yb(nd) = -ovdydb(nd)
        END DO
      END IF
    ELSE IF (branch .EQ. 2) THEN
      DO nd=1,nbdirs
        turbine_yb(nd) = ovdydb(nd)
      END DO
    ELSE
      turbine_yb(:) = 0.0_8
    END IF
  END IF
END SUBROUTINE OVERLAP_AREA_FUNC_BV

!  Differentiation of k_star_func in reverse (adjoint) mode:
!   gradient     of useful results: k_star_ust ti_ust
!   with respect to varying inputs: ti_ust
! compute wake spread parameter based on local turbulence intensity
SUBROUTINE K_STAR_FUNC_BV(ti_ust, ti_ustb, k_star_ust, k_star_ustb, &
& nbdirs)
  ! USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: ti_ust
  REAL(dp), DIMENSION(nbdirs) :: ti_ustb
! out  
  REAL(dp) :: k_star_ust
  REAL(dp), DIMENSION(nbdirs) :: k_star_ustb
! calculate wake spread parameter from Niayifar and Porte Agel (2015, 2016)
  INTEGER :: nd
  INTEGER :: nbdirs
  DO nd=1,nbdirs
    ti_ustb(nd) = ti_ustb(nd) + 0.3837*k_star_ustb(nd)
  END DO
END SUBROUTINE K_STAR_FUNC_BV

!  Differentiation of ct_to_axial_ind_func in reverse (adjoint) mode:
!   gradient     of useful results: axial_induction ct
!   with respect to varying inputs: ct
! calculate axial induction from Ct
SUBROUTINE CT_TO_AXIAL_IND_FUNC_BV(ct, ctb, axial_induction, &
& axial_inductionb, nbdirs)
  ! USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: ct
  REAL(dp), DIMENSION(nbdirs) :: ctb
! out
  REAL(dp) :: axial_induction
  REAL(dp), DIMENSION(nbdirs) :: axial_inductionb
  INTRINSIC SQRT
  INTEGER :: nd
  INTEGER :: nbdirs
! initialize axial induction to zero
! calculate axial induction
  IF (ct .GT. 0.96) THEN
    DO nd=1,nbdirs
      IF (.NOT.0.0203_dp - 0.6427_dp*(0.889_dp-ct) .EQ. 0.0) ctb(nd) = &
&         ctb(nd) + 0.6427_dp*axial_inductionb(nd)/(2.0*SQRT(0.0203_dp-&
&         0.6427_dp*(0.889_dp-ct)))
    END DO
  ELSE
    DO nd=1,nbdirs
      IF (.NOT.1.0_dp - ct .EQ. 0.0) ctb(nd) = ctb(nd) + 0.5_dp*&
&         axial_inductionb(nd)/(2.0*SQRT(1.0_dp-ct))
    END DO
  END IF
END SUBROUTINE CT_TO_AXIAL_IND_FUNC_BV

!  Differentiation of wind_shear_func in reverse (adjoint) mode:
!   gradient     of useful results: adjusted_wind_speed
!   with respect to varying inputs: point_z u_ref
! adjust wind speed for wind shear
SUBROUTINE WIND_SHEAR_FUNC_BV(point_z, point_zb, u_ref, u_refb, z_ref, &
& z_0, shear_exp, adjusted_wind_speed, adjusted_wind_speedb, nbdirs)
  ! USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: point_z, u_ref, z_ref, z_0, shear_exp
  REAL(dp), DIMENSION(nbdirs) :: point_zb, u_refb
! out
  REAL(dp) :: adjusted_wind_speed
  REAL(dp), DIMENSION(nbdirs) :: adjusted_wind_speedb
  INTEGER :: nd
  REAL(dp) :: temp
  INTEGER :: nbdirs
! initialize adjusted wind speed to zero
! check that the point of interest is above ground level
  IF (point_z .GE. z_0) THEN
    temp = (point_z-z_0)/(z_ref-z_0)
    DO nd=1,nbdirs
      u_refb(nd) = temp**shear_exp*adjusted_wind_speedb(nd)
      IF (temp .LE. 0.0 .AND. (shear_exp .EQ. 0.0 .OR. shear_exp .NE. &
&         INT(shear_exp))) THEN
        point_zb(nd) = 0.0_8
      ELSE
        point_zb(nd) = shear_exp*temp**(shear_exp-1)*u_ref*&
&         adjusted_wind_speedb(nd)/(z_ref-z_0)
      END IF
    END DO
  ELSE
    point_zb(:) = 0.0_8
    u_refb(:) = 0.0_8
  END IF
END SUBROUTINE WIND_SHEAR_FUNC_BV

!  Differentiation of discontinuity_point_func in reverse (adjoint) mode:
!   gradient     of useful results: yaw discontinuity_point ky
!                kz rotor_diameter x0 ct
!   with respect to varying inputs: yaw ky kz rotor_diameter x0
!                ct
! calculate the point where the Bastankhah and Porte Agel wake model becomes undefined
SUBROUTINE DISCONTINUITY_POINT_FUNC_BV(x0, x0b, rotor_diameter, &
& rotor_diameterb, ky, kyb, kz, kzb, yaw, yawb, ct, ctb, &
& discontinuity_point, discontinuity_pointb, nbdirs)
  ! USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: x0, rotor_diameter, ky, kz, yaw, ct
  REAL(dp), DIMENSION(nbdirs) :: x0b, rotor_diameterb, kyb, kzb, yawb&
& , ctb
! local
  REAL(dp) :: a, b, c
  REAL(dp), DIMENSION(nbdirs) :: ab, bb, cb
! out
  REAL(dp) :: discontinuity_point
  REAL(dp), DIMENSION(nbdirs) :: discontinuity_pointb
  INTRINSIC COS, SQRT
  INTEGER :: nd
  REAL(dp), DIMENSION(nbdirs) :: tempb
  REAL(dp) :: temp
  REAL(dp) :: temp0
  REAL(dp), DIMENSION(nbdirs) :: tempb0
  INTEGER :: nbdirs
! for clarity, break out the terms in the equation
  a = ky + kz*COS(yaw)
  b = 4.0_dp*ky*kz*COS(yaw)*(ct-1.0_dp)
  c = 2.0_dp*SQRT(8.0_dp)*ky*kz
! distance from rotor to the last point where the wake model is undefined
  temp = a*a - b
  temp0 = SQRT(temp)
  DO nd=1,nbdirs
    x0b(nd) = x0b(nd) + discontinuity_pointb(nd)
    tempb0(nd) = (a-temp0)*discontinuity_pointb(nd)/c
    rotor_diameterb(nd) = rotor_diameterb(nd) + tempb0(nd)
    cb(nd) = -(rotor_diameter*tempb0(nd)/c)
    IF (temp .EQ. 0.0) THEN
      ab(nd) = tempb(nd)
    ELSE
      ab(nd) = (1.0-2*a/(2.0*temp0))*tempb(nd)
    END IF
    IF (temp .EQ. 0.0) THEN
      bb(nd) = 0.0_8
    ELSE
      bb(nd) = tempb(nd)/(2.0*temp0)
    END IF
    tempb(nd) = 2.0_dp*SQRT(8.0_dp)*cb(nd)
    kyb(nd) = kyb(nd) + kz*tempb(nd)
    kzb(nd) = kzb(nd) + ky*tempb(nd)
    tempb(nd) = COS(yaw)*4.0_dp*bb(nd)
    yawb(nd) = yawb(nd) - SIN(yaw)*ky*kz*(ct-1.0_dp)*4.0_dp*bb(nd) - SIN&
&     (yaw)*kz*ab(nd)
    kyb(nd) = kyb(nd) + kz*(ct-1.0_dp)*tempb(nd) + ab(nd)
    kzb(nd) = kzb(nd) + ky*(ct-1.0_dp)*tempb(nd) + COS(yaw)*ab(nd)
    ctb(nd) = ctb(nd) + ky*kz*tempb(nd)
  END DO
END SUBROUTINE DISCONTINUITY_POINT_FUNC_BV

!  Differentiation of smooth_max in reverse (adjoint) mode:
!   gradient     of useful results: g
!   with respect to varying inputs: x y
SUBROUTINE SMOOTH_MAX_BV(s, x, xb, y, yb, g, gb, nbdirs)
  ! USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: s, x, y
  REAL(dp), DIMENSION(nbdirs) :: xb, yb
! local
  REAL(dp) :: max_val, min_val
  REAL(dp), DIMENSION(nbdirs) :: max_valb, min_valb
! out
  REAL(dp) :: g
  REAL(dp), DIMENSION(nbdirs) :: gb
  INTRINSIC LOG, EXP, MAX, MIN
  INTEGER :: nd
  REAL(dp), DIMENSION(nbdirs) :: tempb
  INTEGER :: branch
  INTEGER :: nbdirs
  IF (x .LT. y) THEN
    max_val = y
    CALL PUSHCONTROL1B(0)
  ELSE
    max_val = x
    CALL PUSHCONTROL1B(1)
  END IF
  IF (x .GT. y) THEN
    min_val = y
    CALL PUSHCONTROL1B(0)
  ELSE
    min_val = x
    CALL PUSHCONTROL1B(1)
  END IF
  DO nd=1,nbdirs
    tempb(nd) = EXP(s*(min_val-max_val))*gb(nd)/(EXP(s*(min_val-max_val)&
&     )+1.0_dp)
    max_valb(nd) = gb(nd) - tempb(nd)
    min_valb(nd) = tempb(nd)
  END DO
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    DO nd=1,nbdirs
      yb(nd) = min_valb(nd)
    END DO
    xb(:) = 0.0_8
  ELSE
    DO nd=1,nbdirs
      xb(nd) = min_valb(nd)
    END DO
    yb(:) = 0.0_8
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    DO nd=1,nbdirs
      yb(nd) = yb(nd) + max_valb(nd)
    END DO
  ELSE
    DO nd=1,nbdirs
      xb(nd) = xb(nd) + max_valb(nd)
    END DO
  END IF
END SUBROUTINE SMOOTH_MAX_BV

!  Differentiation of interpolation in reverse (adjoint) mode:
!   gradient     of useful results: yval xval
!   with respect to varying inputs: yval xval
SUBROUTINE INTERPOLATION_BV(npoints, interp_type, x, y, xval, xvalb, &
& yval, yvalb, dy0in, dy1in, usedyin, nbdirs)
  ! USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
!     print *, "yval = ", yval
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  INTEGER, INTENT(IN) :: npoints, interp_type
  REAL(dp), DIMENSION(npoints), INTENT(IN) :: x, y
  REAL(dp), INTENT(IN) :: xval
  REAL(dp), DIMENSION(nbdirs) :: xvalb
  REAL(dp), INTENT(IN) :: dy0in, dy1in
  LOGICAL :: usedyin
! local
  INTEGER :: idx
  REAL(dp) :: x0, x1, y0, dy0, y1, dy1
! out
  REAL(dp) :: yval
  REAL(dp), DIMENSION(nbdirs) :: yvalb
  INTEGER :: nd
  INTEGER :: branch
  INTEGER :: nbdirs
!     print *, "in interpolation"
! if ((xval < x(1)) .or. (xval > x(nPoints))) then
!         print *, "interpolation point is out of bounds"
! !         STOP 1
!     end if
  IF (usedyin .AND. interp_type .EQ. 1) THEN
    STOP
  ELSE IF (xval .LT. x(1)) THEN
    yvalb(:) = 0.0_8
  ELSE IF (xval .GT. x(npoints)) THEN
    yvalb(:) = 0.0_8
  ELSE
    idx = 1
    DO WHILE (xval .GT. x(idx) .AND. idx .LE. npoints)
      idx = idx + 1
    END DO
    idx = idx - 1
    x0 = x(idx)
    x1 = x(idx+1)
    y0 = y(idx)
    y1 = y(idx+1)
! Hermite cubic piecewise spline interpolation
    IF (interp_type .EQ. 0) THEN
! approximate derivative at left end of interval
      IF (idx .EQ. 1) THEN
        IF (usedyin) THEN
          CALL PUSHCONTROL1B(0)
          dy0 = dy0in
        ELSE
          CALL PUSHCONTROL1B(0)
          dy0 = 0.0_dp
        END IF
      ELSE
        CALL PUSHCONTROL1B(1)
        dy0 = (y(idx+1)-y(idx-1))/(x(idx+1)-x(idx-1))
      END IF
! approximate derivative at the right end of interval
      IF (idx .GE. npoints - 1) THEN
        IF (usedyin) THEN
          CALL PUSHCONTROL1B(0)
          dy1 = dy1in
        ELSE
          CALL PUSHCONTROL1B(0)
          dy1 = 0.0_dp
        END IF
      ELSE
        CALL PUSHCONTROL1B(1)
        dy1 = (y(idx+2)-y(idx))/(x(idx+2)-x(idx))
      END IF
      CALL HERMITE_SPLINE_BV(xval, xvalb, x0, x1, y0, dy0, y1, dy1, yval&
&                      , yvalb, nbdirs)
      CALL POPCONTROL1B(branch)
      CALL POPCONTROL1B(branch)
      yvalb(:) = 0.0_8
    ELSE IF (interp_type .EQ. 1) THEN
      DO nd=1,nbdirs
        xvalb(nd) = xvalb(nd) + (y1-y0)*yvalb(nd)/(x1-x0)
      END DO
      yvalb(:) = 0.0_8
    END IF
  END IF
END SUBROUTINE INTERPOLATION_BV

!  Differentiation of hermite_spline in reverse (adjoint) mode:
!   gradient     of useful results: x y
!   with respect to varying inputs: x
SUBROUTINE HERMITE_SPLINE_BV(x, xb, x0, x1, y0, dy0, y1, dy1, y, yb, &
& nbdirs)
  ! USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
!dy_dx = c3*3*x**2 + c2*2*x + c1
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: x, x0, x1, y0, dy0, y1, dy1
  REAL(dp), DIMENSION(nbdirs) :: xb
! out
!, dy_dx
  REAL(dp) :: y
  REAL(dp), DIMENSION(nbdirs) :: yb
! local
  REAL(dp) :: c3, c2, c1, c0
  INTEGER :: nd
  INTEGER :: nbdirs
! initialize coefficients for parametric cubic spline
  c3 = 2.0_dp*y1/(x0**3-3.0_dp*x0**2*x1+3.0_dp*x0*x1**2-x1**3) - 2.0_dp*&
&   y0/(x0**3-3.0_dp*x0**2*x1+3.0_dp*x0*x1**2-x1**3) + dy0/(x0**2-2.0_dp&
&   *x0*x1+x1**2) + dy1/(x0**2-2.0_dp*x0*x1+x1**2)
  c2 = 3.0_dp*y0*(x0+x1)/(x0**3-3.0_dp*x0**2*x1+3.0_dp*x0*x1**2-x1**3) -&
&   dy1*(2.0_dp*x0+x1)/(x0**2-2.0_dp*x0*x1+x1**2) - dy0*(x0+2.0_dp*x1)/(&
&   x0**2-2.0_dp*x0*x1+x1**2) - 3.0_dp*y1*(x0+x1)/(x0**3-3.0_dp*x0**2*x1&
&   +3.0_dp*x0*x1**2-x1**3)
  c1 = dy0*(x1**2+2.0_dp*x0*x1)/(x0**2-2.0_dp*x0*x1+x1**2) + dy1*(x0**2+&
&   2.0_dp*x1*x0)/(x0**2-2.0_dp*x0*x1+x1**2) - 6.0_dp*x0*x1*y0/(x0**3-&
&   3.0_dp*x0**2*x1+3.0_dp*x0*x1**2-x1**3) + 6.0_dp*x0*x1*y1/(x0**3-&
&   3.0_dp*x0**2*x1+3.0_dp*x0*x1**2-x1**3)
!    print *, 'c3 = ', c3
!    print *, 'c2 = ', c2
!    print *, 'c1 = ', c1
!    print *, 'c0 = ', c0
! Solve for y and dy values at the given point
  DO nd=1,nbdirs
    xb(nd) = xb(nd) + (3*x**2*c3+2*x*c2+c1)*yb(nd)
  END DO
END SUBROUTINE HERMITE_SPLINE_BV
!    yd, n = _checkIfFloat(yd)
! 
!     y1 = (1-pct_offset)*ymax
!     y2 = (1+pct_offset)*ymax
! 
!     dy1 = (1-pct_offset)
!     dy2 = (1+pct_offset)
! 
!     if (maxmin == 1) then
!         f1 = y1
!         f2 = ymax
!         g1 = 1.0_dp
!         g2 = 0.0_dp
!         if (yd .ge. y2) then
!             idx_constant = False
!         else
!             idx_constant = True
!         end if
! 
!         df1 = dy1
!         df2 = 1.0_dp
! 
! 
!     else if (maxmin == 0) then
!         f1 = ymax
!         f2 = y2
!         g1 = 0.0_dp
!         g2 = 1.0_dp
!         if (yd .ge. y1) then
!             idx_constant = False
!         else
!             idx_constant = True
!         end if
! 
!         df1 = 1.0_dp
!         df2 = dy2
!         
!     end if
! 
!     f = CubicSplineSegment(y1, y2, f1, f2, g1, g2)
! 
!     # main region
!     ya = np.copy(yd)
!     if dyd is None:
!         dya_dyd = np.ones_like(yd)
!     else:
!         dya_dyd = np.copy(dyd)
! 
!     dya_dymax = np.zeros_like(ya)
! 
!     # cubic spline region
!     idx = np.logical_and(yd > y1, yd < y2)
!     ya[idx] = f.eval(yd[idx])
!     dya_dyd[idx] = f.eval_deriv(yd[idx])
!     dya_dymax[idx] = f.eval_deriv_params(yd[idx], dy1, dy2, df1, df2, 0.0, 0.0)
! 
!     # constant region
!     ya[idx_constant] = ymax
!     dya_dyd[idx_constant] = 0.0
!     dya_dymax[idx_constant] = 1.0
! 
!     if n == 1:
!         ya = ya[0]
!         dya_dyd = dya_dyd[0]
!         dya_dymax = dya_dymax[0]
! 
! 
!     return ya, dya_dyd, dya_dymax
! 
! 
! def smooth_max(yd, ymax, pct_offset=0.01, dyd=None):
!     """array max, uses cubic spline to smoothly transition.  derivatives with respect to array and max value.
!     width of transition can be controlled, and chain rules for differentiation"""
!     return _smooth_maxmin(yd, ymax, 'max', pct_offset, dyd)
! 
! 
! def smooth_min(yd, ymin, pct_offset=0.01, dyd=None):
!     """array min, uses cubic spline to smoothly transition.  derivatives with respect to array and min value.
!     width of transition can be controlled, and chain rules for differentiation"""
!     return _smooth_maxmin(yd, ymin, 'min', pct_offset, dyd)
! 


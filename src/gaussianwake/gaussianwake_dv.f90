!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7260) - 18 Jan 2019 10:11
!
!  Differentiation of porteagel_analyze in forward (tangent) mode:
!   variations   of useful results: wtvelocity
!   with respect to varying inputs: rotordiameter turbinez turbinexw
!                turbineyw yawdeg ct
!   RW status of diff variables: rotordiameter:in turbinez:in turbinexw:in
!                wtvelocity:out turbineyw:in yawdeg:in ct:in
! Implementation of the Bastankhah and Porte Agel gaussian-shaped wind turbine wake 
! model (2016) with various farm modeling (TI and wake combination) methods included
! Created by Jared J. Thomas, 2017-2019.
! FLight Optimization and Wind Laboratory (FLOW Lab)
! Brigham Young University
! implementation of the Bastankhah and Porte Agel (BPA) wake model for analysis
SUBROUTINE PORTEAGEL_ANALYZE_DV(nturbines, nrotorpoints, nctpoints, &
& nfieldpoints, turbinexw, turbinexwd, sorted_x_idx, turbineyw, &
& turbineywd, turbinez, turbinezd, rotordiameter, rotordiameterd, ct, &
& ctd, wind_speed, yawdeg, yawdegd, ky, kz, alpha, beta, ti, &
& rotorpointsy, rotorpointsz, fieldpointsx, fieldpointsy, fieldpointsz, &
& z_ref, z_0, shear_exp, wake_combination_method, ti_calculation_method&
& , calc_k_star, wec_factor, print_ti, wake_model_version, interp_type, &
& use_ct_curve, ct_curve_wind_speed, ct_curve_ct, sm_smoothing, &
& expratemultiplier, calculateflowfield, wtvelocity, wtvelocityd, &
& fieldvelocity, nbdirs)
!  USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  INTEGER, INTENT(IN) :: nturbines, nrotorpoints, nctpoints, &
& nfieldpoints
  INTEGER, INTENT(IN) :: wake_combination_method, ti_calculation_method&
& , wake_model_version, interp_type
  LOGICAL, INTENT(IN) :: calc_k_star, print_ti, use_ct_curve, &
& calculateflowfield
  REAL(dp), DIMENSION(nturbines), INTENT(IN) :: turbinexw, turbineyw, &
& turbinez
  REAL(dp), DIMENSION(nbdirs, nturbines), INTENT(IN) :: turbinexwd, &
& turbineywd, turbinezd
  INTEGER, DIMENSION(nturbines), INTENT(IN) :: sorted_x_idx
  REAL(dp), DIMENSION(nturbines), INTENT(IN) :: rotordiameter, yawdeg
  REAL(dp), DIMENSION(nbdirs, nturbines), INTENT(IN) :: &
& rotordiameterd, yawdegd
  REAL(dp), DIMENSION(nturbines) :: ct
  REAL(dp), DIMENSION(nbdirs, nturbines) :: ctd
  REAL(dp), INTENT(IN) :: ky, kz, alpha, beta, ti, wind_speed, z_ref, &
& z_0, shear_exp, wec_factor
  REAL(dp), DIMENSION(nrotorpoints), INTENT(IN) :: rotorpointsy, &
& rotorpointsz
  REAL(dp), DIMENSION(nctpoints), INTENT(IN) :: ct_curve_wind_speed, &
& ct_curve_ct
  REAL(dp), INTENT(IN) :: sm_smoothing, expratemultiplier
  REAL(dp), DIMENSION(nfieldpoints), INTENT(IN) :: fieldpointsx, &
& fieldpointsy, fieldpointsz
! local (General)
  REAL(dp), DIMENSION(nturbines) :: yaw, titurbs, ct_local, ky_local, &
& kz_local
  REAL(dp), DIMENSION(nbdirs, nturbines) :: yawd, titurbsd, ct_locald&
& , ky_locald, kz_locald
  REAL(dp) :: k_star
  REAL(dp), DIMENSION(nbdirs) :: k_stard
  REAL(dp) :: tol, ti_area_ratio
  REAL(dp), DIMENSION(nbdirs) :: ti_area_ratiod
  REAL(dp) :: ti_area_ratio_tmp, ti_dst_tmp, ti_ust_tmp, rpts
  REAL(dp), DIMENSION(nbdirs) :: ti_area_ratio_tmpd, ti_dst_tmpd, &
& ti_ust_tmpd
  REAL(dp) :: localrotorpointy, localrotorpointz
  REAL(dp), DIMENSION(nbdirs) :: localrotorpointyd, localrotorpointzd
  REAL(dp) :: pointx, pointy, pointz, point_velocity_with_shear
  REAL(dp), DIMENSION(nbdirs) :: pointxd, pointyd, pointzd, &
& point_velocity_with_sheard
  REAL(dp) :: x, x0, theta_c_0, deltay, deltax0, sigmay, sigmaz, &
& wake_offset
  REAL(dp), DIMENSION(nbdirs) :: xd, x0d, theta_c_0d, deltayd, &
& sigmayd, sigmazd, wake_offsetd
  INTEGER :: d, u, turbi, p, turb
  REAL(dp), PARAMETER :: pi=3.141592653589793_dp
! model out
  REAL(dp), DIMENSION(nturbines), INTENT(OUT) :: wtvelocity
  REAL(dp), DIMENSION(nbdirs, nturbines), INTENT(OUT) :: wtvelocityd
  REAL(dp), DIMENSION(nfieldpoints), INTENT(OUT) :: fieldvelocity
! initialize intrinsic functions
  INTRINSIC SIN, COS, ATAN, MAX, SQRT, LOG
  INTRINSIC REAL
  INTEGER :: nd
  INTEGER :: nbdirs
  DO nd=1,nbdirs
! bastankhah and porte agel 2016 defines yaw to be positive clockwise, this is 
! reversed from the convention used in plant energy and from typical convention
    yawd(nd, :) = -(pi*yawdegd(nd, :)/180.0_dp)
  END DO
  yaw = -(yawdeg*pi/180.0_dp)
! set tolerance for location checks
  tol = 0.1_dp
! initialize wind turbine velocities to 0.0
  wtvelocity = 0.0_dp
! initialize local TI of all turbines to free-stream value
  titurbs(:) = ti
! initialize the local wake factors
  IF (calc_k_star .EQV. .true.) THEN
    CALL K_STAR_FUNC(ti, k_star)
    ky_local(:) = k_star
    kz_local(:) = k_star
  ELSE
    ky_local(:) = ky
    kz_local(:) = kz
  END IF
  DO nd=1,nbdirs
    ct_locald(nd, :) = ctd(nd, :)
  END DO
  ct_local(:) = ct
  wtvelocityd(:, :) = 0.0_8
  titurbsd(:, :) = 0.0_8
  kz_locald(:, :) = 0.0_8
  ky_locald(:, :) = 0.0_8
  DO d=1,nturbines
! get index of downstream turbine
    turbi = sorted_x_idx(d) + 1
    DO p=1,nrotorpoints
      localrotorpointy = rotorpointsy(p)*0.5_dp*rotordiameter(turbi)
      DO nd=1,nbdirs
! scale rotor sample point coordinate by rotor diameter (in rotor hub ref. frame)
        localrotorpointyd(nd) = rotorpointsy(p)*0.5_dp*rotordiameterd(nd&
&         , turbi)
        localrotorpointzd(nd) = rotorpointsz(p)*0.5_dp*rotordiameterd(nd&
&         , turbi)
        pointxd(nd) = turbinexwd(nd, turbi) + localrotorpointyd(nd)*SIN(&
&         yaw(turbi)) + localrotorpointy*yawd(nd, turbi)*COS(yaw(turbi))
        pointyd(nd) = turbineywd(nd, turbi) + localrotorpointyd(nd)*COS(&
&         yaw(turbi)) - localrotorpointy*yawd(nd, turbi)*SIN(yaw(turbi))
        pointzd(nd) = turbinezd(nd, turbi) + localrotorpointzd(nd)
      END DO
      localrotorpointz = rotorpointsz(p)*0.5_dp*rotordiameter(turbi)
      pointx = turbinexw(turbi) + localrotorpointy*SIN(yaw(turbi))
      pointy = turbineyw(turbi) + localrotorpointy*COS(yaw(turbi))
      pointz = turbinez(turbi) + localrotorpointz
! calculate the velocity at given point
      CALL POINT_VELOCITY_WITH_SHEAR_FUNC_DV(nturbines, turbi, &
&                                      wake_combination_method, &
&                                      wake_model_version, sorted_x_idx&
&                                      , pointx, pointxd, pointy, &
&                                      pointyd, pointz, pointzd, tol, &
&                                      alpha, beta, expratemultiplier, &
&                                      wec_factor, wind_speed, z_ref, &
&                                      z_0, shear_exp, turbinexw, &
&                                      turbinexwd, turbineyw, turbineywd&
&                                      , turbinez, turbinezd, &
&                                      rotordiameter, rotordiameterd, &
&                                      yaw, yawd, wtvelocity, &
&                                      wtvelocityd, ct_local, ct_locald&
&                                      , titurbs, titurbsd, ky_local, &
&                                      ky_locald, kz_local, kz_locald, &
&                                      point_velocity_with_shear, &
&                                      point_velocity_with_sheard, &
&                                      nbdirs)
      DO nd=1,nbdirs
! add sample point velocity to turbine velocity to be averaged later
        wtvelocityd(nd, turbi) = wtvelocityd(nd, turbi) + &
&         point_velocity_with_sheard(nd)
      END DO
      wtvelocity(turbi) = wtvelocity(turbi) + point_velocity_with_shear
    END DO
! final velocity calculation for turbine turbI (average equally across all points)
    rpts = REAL(nrotorpoints, dp)
    DO nd=1,nbdirs
      wtvelocityd(nd, turbi) = wtvelocityd(nd, turbi)/rpts
    END DO
    wtvelocity(turbi) = wtvelocity(turbi)/rpts
! update thrust coefficient for turbI
    IF (use_ct_curve) CALL INTERPOLATION_DV(nctpoints, interp_type, &
&                                     ct_curve_wind_speed, ct_curve_ct, &
&                                     wtvelocity(turbi), wtvelocityd(:, &
&                                     turbi), ct_local(turbi), ct_locald&
&                                     (:, turbi), 0.0_dp, 0.0_dp, &
&                                     .false., nbdirs)
! calculate local turbulence intensity at turbI
    IF (ti_calculation_method .GT. 0) THEN
! initialize the TI_area_ratio to 0.0 for each turbine
      ti_area_ratio = 0.0_dp
! initialize local ti tmp
      ti_dst_tmp = titurbs(turbi)
      ti_area_ratiod(:) = 0.0_8
! loop over upstream turbines
      DO u=1,nturbines
! get index of upstream turbine
        turb = sorted_x_idx(u) + 1
! skip turbine's influence on itself
        IF (turb .NE. turbi) THEN
          DO nd=1,nbdirs
! calculate downstream distance between wind turbines
            xd(nd) = turbinexwd(nd, turbi) - turbinexwd(nd, turb)
          END DO
          x = turbinexw(turbi) - turbinexw(turb)
          IF (x .GT. tol) THEN
! determine the far-wake onset location 
            CALL X0_FUNC_DV(rotordiameter(turb), rotordiameterd(:, turb)&
&                     , yaw(turb), yawd(:, turb), ct_local(turb), &
&                     ct_locald(:, turb), alpha, titurbs(turb), titurbsd&
&                     (:, turb), beta, x0, x0d, nbdirs)
! calculate the distance from the onset of far-wake
            deltax0 = x - x0
! horizontal spread 
            CALL SIGMAY_FUNC_DV(x, xd, x0, x0d, ky_local(turb), &
&                         ky_locald(:, turb), rotordiameter(turb), &
&                         rotordiameterd(:, turb), yaw(turb), yawd(:, &
&                         turb), sigmay, sigmayd, nbdirs)
! vertical spread 
            CALL SIGMAZ_FUNC_DV(x, xd, x0, x0d, kz_local(turb), &
&                         kz_locald(:, turb), rotordiameter(turb), &
&                         rotordiameterd(:, turb), sigmaz, sigmazd, &
&                         nbdirs)
! determine the initial wake angle at the onset of far wake
            CALL THETA_C_0_FUNC_DV(yaw(turb), yawd(:, turb), ct_local(&
&                            turb), ct_locald(:, turb), theta_c_0, &
&                            theta_c_0d, nbdirs)
! horizontal cross-wind wake displacement from hub
            CALL WAKE_OFFSET_FUNC_DV(x, xd, rotordiameter(turb), &
&                              rotordiameterd(:, turb), theta_c_0, &
&                              theta_c_0d, x0, x0d, yaw(turb), yawd(:, &
&                              turb), ky_local(turb), ky_locald(:, turb)&
&                              , kz_local(turb), kz_locald(:, turb), &
&                              ct_local(turb), ct_locald(:, turb), &
&                              sigmay, sigmayd, sigmaz, sigmazd, &
&                              wake_offset, wake_offsetd, nbdirs)
            DO nd=1,nbdirs
! cross wind distance from point location to upstream turbine wake center
              deltayd(nd) = turbineywd(nd, turbi) - turbineywd(nd, turb)&
&               - wake_offsetd(nd)
! save ti_area_ratio and ti_dst to new memory locations to avoid 
! aliasing during differentiation
              ti_area_ratio_tmpd(nd) = ti_area_ratiod(nd)
              ti_dst_tmpd(nd) = titurbsd(nd, turbi)
              ti_ust_tmpd(nd) = titurbsd(nd, turb)
            END DO
            deltay = turbineyw(turbi) - (turbineyw(turb)+wake_offset)
            ti_area_ratio_tmp = ti_area_ratio
            ti_dst_tmp = titurbs(turbi)
            ti_ust_tmp = titurbs(turb)
! update local turbulence intensity
            CALL ADDED_TI_FUNC_DV(ti, ct_local(turb), ct_locald(:, turb)&
&                           , x, xd, ky_local(turb), ky_locald(:, turb)&
&                           , rotordiameter(turb), rotordiameterd(:, &
&                           turb), rotordiameter(turbi), rotordiameterd(&
&                           :, turbi), deltay, deltayd, turbinez(turb), &
&                           turbinezd(:, turb), turbinez(turbi), &
&                           turbinezd(:, turbi), sm_smoothing, &
&                           ti_ust_tmp, ti_ust_tmpd, &
&                           ti_calculation_method, ti_area_ratio_tmp, &
&                           ti_area_ratio_tmpd, ti_dst_tmp, ti_dst_tmpd&
&                           , ti_area_ratio, ti_area_ratiod, titurbs(&
&                           turbi), titurbsd(:, turbi), nbdirs)
          END IF
        END IF
      END DO
! calculate wake spreading parameter at turbI based on local turbulence intensity
      IF (calc_k_star .EQV. .true.) THEN
        CALL K_STAR_FUNC_DV(titurbs(turbi), titurbsd(:, turbi), k_star, &
&                     k_stard, nbdirs)
        DO nd=1,nbdirs
          ky_locald(nd, turbi) = k_stard(nd)
          kz_locald(nd, turbi) = k_stard(nd)
        END DO
        ky_local(turbi) = k_star
        kz_local(turbi) = k_star
      END IF
    END IF
  END DO
! calculate flow field
  IF (calculateflowfield) THEN
    DO p=1,nfieldpoints
! calculate the velocity at given point
      CALL POINT_VELOCITY_WITH_SHEAR_FUNC(nturbines, turbi, &
&                                   wake_combination_method, &
&                                   wake_model_version, sorted_x_idx, &
&                                   fieldpointsx(p), fieldpointsy(p), &
&                                   fieldpointsz(p), tol, alpha, beta, &
&                                   expratemultiplier, wec_factor, &
&                                   wind_speed, z_ref, z_0, shear_exp, &
&                                   turbinexw, turbineyw, turbinez, &
&                                   rotordiameter, yaw, wtvelocity, &
&                                   ct_local, titurbs, ky_local, &
&                                   kz_local, fieldvelocity(p))
    END DO
  END IF
END SUBROUTINE PORTEAGEL_ANALYZE_DV

!  Differentiation of point_velocity_with_shear_func in forward (tangent) mode:
!   variations   of useful results: point_velocity_with_shear
!   with respect to varying inputs: yaw rotordiameter turbinez
!                turbinexw pointx pointy pointz wtvelocity titurbs
!                turbineyw kz_local ct_local ky_local
SUBROUTINE POINT_VELOCITY_WITH_SHEAR_FUNC_DV(nturbines, turbi, &
& wake_combination_method, wake_model_version, sorted_x_idx, pointx, &
& pointxd, pointy, pointyd, pointz, pointzd, tol, alpha, beta, &
& expratemultiplier, wec_factor, wind_speed, z_ref, z_0, shear_exp, &
& turbinexw, turbinexwd, turbineyw, turbineywd, turbinez, turbinezd, &
& rotordiameter, rotordiameterd, yaw, yawd, wtvelocity, wtvelocityd, &
& ct_local, ct_locald, titurbs, titurbsd, ky_local, ky_locald, kz_local&
& , kz_locald, point_velocity_with_shear, point_velocity_with_sheard, &
& nbdirs)
!  USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  INTEGER, INTENT(IN) :: nturbines, turbi, wake_combination_method, &
& wake_model_version
  INTEGER, DIMENSION(nturbines), INTENT(IN) :: sorted_x_idx
  REAL(dp), INTENT(IN) :: pointx, pointy, pointz
  REAL(dp), DIMENSION(nbdirs), INTENT(IN) :: pointxd, pointyd, &
& pointzd
  REAL(dp), INTENT(IN) :: tol, alpha, beta, expratemultiplier, &
& wec_factor
  REAL(dp), INTENT(IN) :: wind_speed
  REAL(dp), INTENT(IN) :: z_ref, z_0, shear_exp
  REAL(dp), DIMENSION(nturbines), INTENT(IN) :: turbinexw, turbineyw, &
& turbinez
  REAL(dp), DIMENSION(nbdirs, nturbines), INTENT(IN) :: turbinexwd, &
& turbineywd, turbinezd
  REAL(dp), DIMENSION(nturbines), INTENT(IN) :: rotordiameter, yaw, &
& wtvelocity
  REAL(dp), DIMENSION(nbdirs, nturbines), INTENT(IN) :: &
& rotordiameterd, yawd, wtvelocityd
  REAL(dp), DIMENSION(nturbines), INTENT(IN) :: ct_local, titurbs, &
& ky_local, kz_local
  REAL(dp), DIMENSION(nbdirs, nturbines), INTENT(IN) :: ct_locald, &
& titurbsd, ky_locald, kz_locald
! out
  REAL(dp), INTENT(OUT) :: point_velocity_with_shear
  REAL(dp), DIMENSION(nbdirs), INTENT(OUT) :: &
& point_velocity_with_sheard
  REAL(dp) :: wake_offset
  REAL(dp), DIMENSION(nbdirs) :: wake_offsetd
! local
  REAL(dp) :: old_deficit_sum, deficit_sum
  REAL(dp), DIMENSION(nbdirs) :: old_deficit_sumd, deficit_sumd
  REAL(dp) :: x, deltav, x0, theta_c_0, sigmay, sigmaz
  REAL(dp), DIMENSION(nbdirs) :: xd, deltavd, x0d, theta_c_0d, &
& sigmayd, sigmazd
  REAL(dp) :: discontinuity_point, sigmay_d, sigmaz_d
  REAL(dp), DIMENSION(nbdirs) :: discontinuity_pointd, sigmay_dd, &
& sigmaz_dd
  REAL(dp) :: sigmay_0, sigmaz_0, deltay, deltaz, point_velocity
  REAL(dp), DIMENSION(nbdirs) :: sigmay_0d, sigmaz_0d, deltayd, &
& deltazd, point_velocityd
  REAL(dp) :: sigmay_spread, sigmaz_spread
  REAL(dp), DIMENSION(nbdirs) :: sigmay_spreadd, sigmaz_spreadd
  INTEGER :: u, turb
  INTEGER :: nd
  INTEGER :: nbdirs
! initialize deficit summation term to zero
  deficit_sum = 0.0_dp
  deficit_sumd(:) = 0.0_8
! loop through all turbines
! at turbineX-locations
  DO u=1,nturbines
! get index of upstream turbine
    turb = sorted_x_idx(u) + 1
! skip this loop if turb = turbI (turbines impact on itself)
    IF (turb .NE. turbi) THEN
      DO nd=1,nbdirs
! downstream distance between upstream turbine and point
        xd(nd) = pointxd(nd) - turbinexwd(nd, turb)
      END DO
      x = pointx - turbinexw(turb)
! set this iterations velocity deficit to 0
      deltav = 0.0_dp
! check turbine relative locations
      IF (x .GT. tol) THEN
! determine the onset location of far wake
        CALL X0_FUNC_DV(rotordiameter(turb), rotordiameterd(:, turb), &
&                 yaw(turb), yawd(:, turb), ct_local(turb), ct_locald(:&
&                 , turb), alpha, titurbs(turb), titurbsd(:, turb), beta&
&                 , x0, x0d, nbdirs)
! find the final point where the original model is undefined
        CALL DISCONTINUITY_POINT_FUNC_DV(x0, x0d, rotordiameter(turb), &
&                                  rotordiameterd(:, turb), ky_local(&
&                                  turb), ky_locald(:, turb), kz_local(&
&                                  turb), kz_locald(:, turb), yaw(turb)&
&                                  , yawd(:, turb), ct_local(turb), &
&                                  ct_locald(:, turb), &
&                                  discontinuity_point, &
&                                  discontinuity_pointd, nbdirs)
! horizontal spread at discontinuity point
        CALL SIGMAY_FUNC_DV(discontinuity_point, discontinuity_pointd, &
&                     x0, x0d, ky_local(turb), ky_locald(:, turb), &
&                     rotordiameter(turb), rotordiameterd(:, turb), yaw(&
&                     turb), yawd(:, turb), sigmay_d, sigmay_dd, nbdirs)
! vertical spread at discontinuity point
        CALL SIGMAZ_FUNC_DV(discontinuity_point, discontinuity_pointd, &
&                     x0, x0d, kz_local(turb), kz_locald(:, turb), &
&                     rotordiameter(turb), rotordiameterd(:, turb), &
&                     sigmaz_d, sigmaz_dd, nbdirs)
! horizontal spread at far wake onset point
        CALL SIGMAY_FUNC_DV(x0, x0d, x0, x0d, ky_local(turb), ky_locald(&
&                     :, turb), rotordiameter(turb), rotordiameterd(:, &
&                     turb), yaw(turb), yawd(:, turb), sigmay_0, &
&                     sigmay_0d, nbdirs)
! vertical spread at at far wake onset point
        CALL SIGMAZ_FUNC_DV(x0, x0d, x0, x0d, kz_local(turb), kz_locald(&
&                     :, turb), rotordiameter(turb), rotordiameterd(:, &
&                     turb), sigmaz_0, sigmaz_0d, nbdirs)
! calculate wake spread in horizontal at point of interest
        CALL SIGMA_SPREAD_FUNC_DV(x, xd, x0, x0d, ky_local(turb), &
&                           ky_locald(:, turb), sigmay_0, sigmay_0d, &
&                           sigmay_d, sigmay_dd, 1.0_dp, 1.0_dp, sigmay&
&                           , sigmayd, nbdirs)
! calculate wake spread in vertical at point of interest
        CALL SIGMA_SPREAD_FUNC_DV(x, xd, x0, x0d, kz_local(turb), &
&                           kz_locald(:, turb), sigmaz_0, sigmaz_0d, &
&                           sigmaz_d, sigmaz_dd, 1.0_dp, 1.0_dp, sigmaz&
&                           , sigmazd, nbdirs)
! calculate new spread for WEC in y (horizontal)
        CALL SIGMA_SPREAD_FUNC_DV(x, xd, x0, x0d, ky_local(turb), &
&                           ky_locald(:, turb), sigmay_0, sigmay_0d, &
&                           sigmay_d, sigmay_dd, expratemultiplier, &
&                           wec_factor, sigmay_spread, sigmay_spreadd, &
&                           nbdirs)
! calculate new spread for WEC in z (horizontal)
        CALL SIGMA_SPREAD_FUNC_DV(x, xd, x0, x0d, kz_local(turb), &
&                           kz_locald(:, turb), sigmaz_0, sigmaz_0d, &
&                           sigmaz_d, sigmaz_dd, expratemultiplier, &
&                           wec_factor, sigmaz_spread, sigmaz_spreadd, &
&                           nbdirs)
! determine the initial wake angle at the onset of far wake
        CALL THETA_C_0_FUNC_DV(yaw(turb), yawd(:, turb), ct_local(turb)&
&                        , ct_locald(:, turb), theta_c_0, theta_c_0d, &
&                        nbdirs)
! horizontal cross-wind wake displacement from hub
        CALL WAKE_OFFSET_FUNC_DV(x, xd, rotordiameter(turb), &
&                          rotordiameterd(:, turb), theta_c_0, &
&                          theta_c_0d, x0, x0d, yaw(turb), yawd(:, turb)&
&                          , ky_local(turb), ky_locald(:, turb), &
&                          kz_local(turb), kz_locald(:, turb), ct_local(&
&                          turb), ct_locald(:, turb), sigmay, sigmayd, &
&                          sigmaz, sigmazd, wake_offset, wake_offsetd, &
&                          nbdirs)
        DO nd=1,nbdirs
! print *, x
! cross wind distance from point location to upstream turbine wake center
          deltayd(nd) = pointyd(nd) - turbineywd(nd, turb) - &
&           wake_offsetd(nd)
! vertical distance from upstream hub height to height of point of interest
          deltazd(nd) = pointzd(nd) - turbinezd(nd, turb)
        END DO
        deltay = pointy - (turbineyw(turb)+wake_offset)
        deltaz = pointz - turbinez(turb)
        IF (x .GT. x0) THEN
! velocity difference in the wake
          CALL DELTAV_FUNC_DV(deltay, deltayd, deltaz, deltazd, ct_local&
&                       (turb), ct_locald(:, turb), yaw(turb), yawd(:, &
&                       turb), sigmay, sigmayd, sigmaz, sigmazd, &
&                       rotordiameter(turb), rotordiameterd(:, turb), &
&                       wake_model_version, kz_local(turb), kz_locald(:&
&                       , turb), x, xd, wec_factor, sigmay_spread, &
&                       sigmay_spreadd, sigmaz_spread, sigmaz_spreadd, &
&                       deltav, deltavd, nbdirs)
        ELSE
! velocity deficit in the nearwake (linear model)
          CALL DELTAV_NEAR_WAKE_LIN_FUNC_DV(deltay, deltayd, deltaz, &
&                                     deltazd, ct_local(turb), ct_locald&
&                                     (:, turb), yaw(turb), yawd(:, turb&
&                                     ), sigmay_0, sigmay_0d, sigmaz_0, &
&                                     sigmaz_0d, x0, x0d, rotordiameter(&
&                                     turb), rotordiameterd(:, turb), x&
&                                     , xd, discontinuity_point, &
&                                     discontinuity_pointd, sigmay_d, &
&                                     sigmay_dd, sigmaz_d, sigmaz_dd, &
&                                     wake_model_version, kz_local(turb)&
&                                     , kz_locald(:, turb), x0, &
&                                     sigmay_spread, sigmay_spreadd, &
&                                     sigmaz_spread, sigmaz_spreadd, &
&                                     wec_factor, deltav, deltavd, &
&                                     nbdirs)
        END IF
        DO nd=1,nbdirs
! save deficit sum in holder for AD purposes
          old_deficit_sumd(nd) = deficit_sumd(nd)
        END DO
        old_deficit_sum = deficit_sum
! combine deficits according to selected wake combination method
        CALL WAKE_COMBINATION_FUNC_DV(wind_speed, wtvelocity(turb), &
&                               wtvelocityd(:, turb), deltav, deltavd, &
&                               wake_combination_method, old_deficit_sum&
&                               , old_deficit_sumd, deficit_sum, &
&                               deficit_sumd, nbdirs)
      END IF
    END IF
  END DO
  DO nd=1,nbdirs
! find velocity at point without shear
    point_velocityd(nd) = -deficit_sumd(nd)
  END DO
  point_velocity = wind_speed - deficit_sum
! adjust sample point velocity for shear
  CALL WIND_SHEAR_FUNC_DV(pointz, pointzd, point_velocity, &
&                   point_velocityd, z_ref, z_0, shear_exp, &
&                   point_velocity_with_shear, &
&                   point_velocity_with_sheard, nbdirs)
END SUBROUTINE POINT_VELOCITY_WITH_SHEAR_FUNC_DV

!  Differentiation of x0_func in forward (tangent) mode:
!   variations   of useful results: x0
!   with respect to varying inputs: ti yaw rotor_diameter ct
! calculates the onset of far-wake conditions
SUBROUTINE X0_FUNC_DV(rotor_diameter, rotor_diameterd, yaw, yawd, ct, &
& ctd, alpha, ti, tid, beta, x0, x0d, nbdirs)
!  USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: rotor_diameter, yaw, ct, alpha, ti, beta
  REAL(dp), DIMENSION(nbdirs), INTENT(IN) :: rotor_diameterd, yawd, &
& ctd, tid
! out
  REAL(dp), INTENT(OUT) :: x0
  REAL(dp), DIMENSION(nbdirs), INTENT(OUT) :: x0d
  INTRINSIC COS, SQRT
  REAL(dp) :: result1
  REAL(dp), DIMENSION(nbdirs) :: result1d
  REAL(dp) :: result2
  REAL(dp) :: result3
  REAL(dp), DIMENSION(nbdirs) :: result3d
  INTEGER :: nd
  INTEGER :: nbdirs
  result1 = SQRT(1.0_dp - ct)
  result2 = SQRT(2.0_dp)
  result3 = SQRT(1.0_dp - ct)
  DO nd=1,nbdirs
! determine the onset location of far wake
    result1d(nd) = -(ctd(nd)/(2.0*SQRT(1.0_dp-ct)))
    result3d(nd) = -(ctd(nd)/(2.0*SQRT(1.0_dp-ct)))
    x0d(nd) = rotor_diameterd(nd)*COS(yaw)*(1.0_dp+result1)/(result2*(&
&     alpha*ti+beta*(1.0_dp-result3))) + rotor_diameter*((COS(yaw)*&
&     result1d(nd)-yawd(nd)*SIN(yaw)*(1.0_dp+result1))*result2*(alpha*ti&
&     +beta*(1.0_dp-result3))-COS(yaw)*(1.0_dp+result1)*result2*(alpha*&
&     tid(nd)-beta*result3d(nd)))/(result2**2*(alpha*ti+beta*(1.0_dp-&
&     result3))**2)
  END DO
  x0 = rotor_diameter*(COS(yaw)*(1.0_dp+result1)/(result2*(alpha*ti+beta&
&   *(1.0_dp-result3))))
END SUBROUTINE X0_FUNC_DV

!  Differentiation of theta_c_0_func in forward (tangent) mode:
!   variations   of useful results: theta_c_0
!   with respect to varying inputs: yaw ct
! calculates the wake angle at the onset of far wake conditions
SUBROUTINE THETA_C_0_FUNC_DV(yaw, yawd, ct, ctd, theta_c_0, theta_c_0d, &
& nbdirs)
!  USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: yaw, ct
  REAL(dp), DIMENSION(nbdirs), INTENT(IN) :: yawd, ctd
! out
  REAL(dp), INTENT(OUT) :: theta_c_0
  REAL(dp), DIMENSION(nbdirs), INTENT(OUT) :: theta_c_0d
  INTRINSIC COS, SQRT
  REAL(dp) :: arg1
  REAL(dp), DIMENSION(nbdirs) :: arg1d
  REAL(dp) :: result1
  REAL(dp), DIMENSION(nbdirs) :: result1d
  INTEGER :: nd
  INTEGER :: nbdirs
  arg1 = 1.0_dp - ct*COS(yaw)
  result1 = SQRT(arg1)
  DO nd=1,nbdirs
! determine the initial wake angle at the onset of far wake
    arg1d(nd) = ct*yawd(nd)*SIN(yaw) - ctd(nd)*COS(yaw)
    IF (arg1 .EQ. 0.0) THEN
      result1d(nd) = 0.0_8
    ELSE
      result1d(nd) = arg1d(nd)/(2.0*SQRT(arg1))
    END IF
    theta_c_0d(nd) = (0.3_dp*(yawd(nd)*(1.0_dp-result1)-yaw*result1d(nd)&
&     )*COS(yaw)+0.3_dp*yaw*(1.0_dp-result1)*yawd(nd)*SIN(yaw))/COS(yaw)&
&     **2
  END DO
  theta_c_0 = 0.3_dp*yaw*(1.0_dp-result1)/COS(yaw)
END SUBROUTINE THETA_C_0_FUNC_DV

!  Differentiation of sigmay_func in forward (tangent) mode:
!   variations   of useful results: sigmay
!   with respect to varying inputs: yaw x ky rotor_diameter x0
! calculates the horizontal spread of the wake at a given distance from the onset of far 
! wake condition
SUBROUTINE SIGMAY_FUNC_DV(x, xd, x0, x0d, ky, kyd, rotor_diameter, &
& rotor_diameterd, yaw, yawd, sigmay, sigmayd, nbdirs)
!  USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: ky, x, x0, rotor_diameter, yaw
  REAL(dp), DIMENSION(nbdirs), INTENT(IN) :: kyd, xd, x0d, &
& rotor_diameterd, yawd
! out
  REAL(dp), INTENT(OUT) :: sigmay
  REAL(dp), DIMENSION(nbdirs), INTENT(OUT) :: sigmayd
  INTRINSIC COS, SQRT
  REAL(dp) :: result1
  INTEGER :: nd
  INTEGER :: nbdirs
! horizontal spread
  result1 = SQRT(8.0_dp)
  DO nd=1,nbdirs
    sigmayd(nd) = kyd(nd)*(x-x0) + ky*(xd(nd)-x0d(nd)) + (&
&     rotor_diameterd(nd)*COS(yaw)-rotor_diameter*yawd(nd)*SIN(yaw))/&
&     result1
  END DO
  sigmay = ky*(x-x0) + rotor_diameter*COS(yaw)/result1
END SUBROUTINE SIGMAY_FUNC_DV

!  Differentiation of sigmaz_func in forward (tangent) mode:
!   variations   of useful results: sigmaz
!   with respect to varying inputs: x kz rotor_diameter x0
! calculates the vertical spread of the wake at a given distance from the onset of far 
! wake condition
SUBROUTINE SIGMAZ_FUNC_DV(x, xd, x0, x0d, kz, kzd, rotor_diameter, &
& rotor_diameterd, sigmaz, sigmazd, nbdirs)
!  USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: kz, x, x0, rotor_diameter
  REAL(dp), DIMENSION(nbdirs), INTENT(IN) :: kzd, xd, x0d, &
& rotor_diameterd
! out
  REAL(dp), INTENT(OUT) :: sigmaz
  REAL(dp), DIMENSION(nbdirs), INTENT(OUT) :: sigmazd
! load necessary intrinsic functions
  INTRINSIC SQRT
  REAL(dp) :: result1
  INTEGER :: nd
  INTEGER :: nbdirs
! vertical spread
  result1 = SQRT(8.0_dp)
  DO nd=1,nbdirs
    sigmazd(nd) = kzd(nd)*(x-x0) + kz*(xd(nd)-x0d(nd)) + rotor_diameterd&
&     (nd)/result1
  END DO
  sigmaz = kz*(x-x0) + rotor_diameter/result1
END SUBROUTINE SIGMAZ_FUNC_DV

!  Differentiation of sigma_spread_func in forward (tangent) mode:
!   variations   of useful results: sigma_spread
!   with respect to varying inputs: k sigma_d x sigma_0 x0
SUBROUTINE SIGMA_SPREAD_FUNC_DV(x, xd, x0, x0d, k, kd, sigma_0, sigma_0d&
& , sigma_d, sigma_dd, expratemultiplier, wec_factor, sigma_spread, &
& sigma_spreadd, nbdirs)
!  USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
!! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: x, x0, k, sigma_0, sigma_d, expratemultiplier&
& , wec_factor
  REAL(dp), DIMENSION(nbdirs), INTENT(IN) :: xd, x0d, kd, sigma_0d, &
& sigma_dd
! out
  REAL(dp), INTENT(OUT) :: sigma_spread
  REAL(dp), DIMENSION(nbdirs), INTENT(OUT) :: sigma_spreadd
! local
  REAL(dp) :: k_near_wake, sigma_0_new, k_spread
  REAL(dp), DIMENSION(nbdirs) :: k_near_waked, sigma_0_newd
  REAL(dp), PARAMETER :: pi=3.141592653589793_dp
  INTRINSIC TAN, ATAN
  REAL(dp) :: arg1
  INTEGER :: nd
  INTEGER :: nbdirs
! check if spreading angle is too high
  IF (expratemultiplier*pi/180.0_dp .GE. pi/2.0_dp) THEN
    PRINT*, 'WEC angle factor is too high, must be less than 90 deg '
    STOP
  ELSE
    DO nd=1,nbdirs
! get slope of wake expansion in the near wake
      k_near_waked(nd) = ((sigma_0d(nd)-sigma_dd(nd))*x0-(sigma_0-&
&       sigma_d)*x0d(nd))/x0**2
    END DO
    k_near_wake = (sigma_0-sigma_d)/x0
    arg1 = expratemultiplier*pi/180.0_dp
    k_spread = TAN(arg1)
    IF (k_spread .GT. k_near_wake) THEN
      k_near_wake = k_spread
      k_near_waked(:) = 0.0_8
    END IF
    DO nd=1,nbdirs
! get new value for wake spread at the point of far wake onset
      sigma_0_newd(nd) = k_near_waked(nd)*x0 + k_near_wake*x0d(nd) + &
&       sigma_dd(nd)
    END DO
    sigma_0_new = k_near_wake*x0 + sigma_d
! get the wake spread at the point of interest
    IF (x .GE. x0 .AND. k .GT. k_near_wake) THEN
      DO nd=1,nbdirs
! for points further downstream than the point of far wake onset and low spreading angles
        sigma_spreadd(nd) = wec_factor*(kd(nd)*(x-x0)+k*(xd(nd)-x0d(nd))&
&         +sigma_0_newd(nd))
      END DO
      sigma_spread = wec_factor*(k*(x-x0)+sigma_0_new)
    ELSE IF (x .GE. 0.0_dp) THEN
      DO nd=1,nbdirs
! for points in the near wake and/or with high spreading angles
        sigma_spreadd(nd) = wec_factor*(k_near_waked(nd)*x+k_near_wake*&
&         xd(nd)+sigma_dd(nd))
      END DO
      sigma_spread = wec_factor*(k_near_wake*x+sigma_d)
    ELSE
! for when the point is not in a wake
      sigma_spread = 0.0_dp
      sigma_spreadd(:) = 0.0_8
    END IF
  END IF
END SUBROUTINE SIGMA_SPREAD_FUNC_DV

!  Differentiation of wake_offset_func in forward (tangent) mode:
!   variations   of useful results: wake_offset
!   with respect to varying inputs: theta_c_0 yaw x sigmay sigmaz
!                ky kz rotor_diameter x0 ct
! calculates the horizontal distance from the wake center to the hub of the turbine making
! the wake
SUBROUTINE WAKE_OFFSET_FUNC_DV(x, xd, rotor_diameter, rotor_diameterd, &
& theta_c_0, theta_c_0d, x0, x0d, yaw, yawd, ky, kyd, kz, kzd, ct, ctd, &
& sigmay, sigmayd, sigmaz, sigmazd, wake_offset, wake_offsetd, nbdirs)
!  USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: x, rotor_diameter, theta_c_0, x0, yaw, ky, kz&
& , ct, sigmay
  REAL(dp), DIMENSION(nbdirs), INTENT(IN) :: xd, rotor_diameterd, &
& theta_c_0d, x0d, yawd, kyd, kzd, ctd, sigmayd
  REAL(dp), INTENT(IN) :: sigmaz
  REAL(dp), DIMENSION(nbdirs), INTENT(IN) :: sigmazd
! local
  REAL(dp) :: a, b, c, d, e, f, g
  REAL(dp), DIMENSION(nbdirs) :: ad, bd, cd, dd, ed, fd, gd
! out
  REAL(dp), INTENT(OUT) :: wake_offset
  REAL(dp), DIMENSION(nbdirs), INTENT(OUT) :: wake_offsetd
  INTRINSIC COS, SQRT, LOG
  REAL(dp) :: arg1
  REAL(dp), DIMENSION(nbdirs) :: arg1d
  REAL(dp) :: result1
  REAL(dp), DIMENSION(nbdirs) :: result1d
  REAL(dp) :: result2
  REAL(dp), DIMENSION(nbdirs) :: result2d
  INTEGER :: nd
  INTEGER :: nbdirs
  IF (x .LT. x0) THEN
    DO nd=1,nbdirs
      wake_offsetd(nd) = theta_c_0d(nd)*x + theta_c_0*xd(nd)
    END DO
    wake_offset = theta_c_0*x
  ELSE
    arg1 = COS(yaw)/(ky*kz*ct)
    DO nd=1,nbdirs
      ad(nd) = theta_c_0d(nd)*x0 + theta_c_0*x0d(nd)
      bd(nd) = (rotor_diameterd(nd)*theta_c_0+rotor_diameter*theta_c_0d(&
&       nd))/14.7_dp
      arg1d(nd) = (-(yawd(nd)*SIN(yaw)*ky*kz*ct)-COS(yaw)*((kyd(nd)*kz+&
&       ky*kzd(nd))*ct+ky*kz*ctd(nd)))/(ky*kz*ct)**2
      IF (arg1 .EQ. 0.0) THEN
        cd(nd) = 0.0_8
      ELSE
        cd(nd) = arg1d(nd)/(2.0*SQRT(arg1))
      END IF
      result1d(nd) = -(ctd(nd)/(2.0*SQRT(1.0_dp-ct)))
      dd(nd) = 1.3_dp*result1d(nd) - ctd(nd)
      arg1d(nd) = (8.0_dp*(sigmayd(nd)*sigmaz+sigmay*sigmazd(nd))*&
&       rotor_diameter**2*COS(yaw)-8.0_dp*sigmay*sigmaz*(2*&
&       rotor_diameter*rotor_diameterd(nd)*COS(yaw)-rotor_diameter**2*&
&       yawd(nd)*SIN(yaw)))/(rotor_diameter**2*COS(yaw))**2
      IF (ct .EQ. 0.0) THEN
        result2d(nd) = 0.0_8
      ELSE
        result2d(nd) = ctd(nd)/(2.0*SQRT(ct))
      END IF
    END DO
    a = theta_c_0*x0
    b = rotor_diameter*theta_c_0/14.7_dp
    c = SQRT(arg1)
    result1 = SQRT(1.0_dp - ct)
    d = 2.9_dp + 1.3_dp*result1 - ct
    arg1 = 8.0_dp*sigmay*sigmaz/(rotor_diameter**2*COS(yaw))
    result1 = SQRT(arg1)
    e = 1.6_dp*result1
    result1 = SQRT(ct)
    result2 = SQRT(ct)
    DO nd=1,nbdirs
      IF (arg1 .EQ. 0.0) THEN
        result1d(nd) = 0.0_8
      ELSE
        result1d(nd) = arg1d(nd)/(2.0*SQRT(arg1))
      END IF
      ed(nd) = 1.6_dp*result1d(nd)
      IF (ct .EQ. 0.0) THEN
        result1d(nd) = 0.0_8
      ELSE
        result1d(nd) = ctd(nd)/(2.0*SQRT(ct))
      END IF
      fd(nd) = result1d(nd)*(e-result2) + (1.6_dp+result1)*(ed(nd)-&
&       result2d(nd))
      IF (ct .EQ. 0.0) THEN
        result1d(nd) = 0.0_8
      ELSE
        result1d(nd) = ctd(nd)/(2.0*SQRT(ct))
      END IF
      IF (ct .EQ. 0.0) THEN
        result2d(nd) = 0.0_8
      ELSE
        result2d(nd) = ctd(nd)/(2.0*SQRT(ct))
      END IF
    END DO
    f = (1.6_dp+result1)*(e-result2)
    result1 = SQRT(ct)
    result2 = SQRT(ct)
    g = (1.6_dp-result1)*(e+result2)
    arg1 = f/g
    DO nd=1,nbdirs
      gd(nd) = (1.6_dp-result1)*(ed(nd)+result2d(nd)) - result1d(nd)*(e+&
&       result2)
      arg1d(nd) = (fd(nd)*g-f*gd(nd))/g**2
      wake_offsetd(nd) = ad(nd) + ((bd(nd)*c+b*cd(nd))*d+b*c*dd(nd))*LOG&
&       (arg1) + b*c*d*arg1d(nd)/arg1
    END DO
    wake_offset = a + b*c*d*LOG(arg1)
  END IF
END SUBROUTINE WAKE_OFFSET_FUNC_DV

!  Differentiation of deltav_func in forward (tangent) mode:
!   variations   of useful results: deltav
!   with respect to varying inputs: k yaw rotor_diameter_ust sigmay
!                sigmaz sigmay_spread deltax deltay deltaz sigmaz_spread
!                ct
! calculates the velocity difference between hub velocity and free stream for a given wake
! for use in the far wake region
SUBROUTINE DELTAV_FUNC_DV(deltay, deltayd, deltaz, deltazd, ct, ctd, yaw&
& , yawd, sigmay, sigmayd, sigmaz, sigmazd, rotor_diameter_ust, &
& rotor_diameter_ustd, version, k, kd, deltax, deltaxd, wec_factor, &
& sigmay_spread, sigmay_spreadd, sigmaz_spread, sigmaz_spreadd, deltav, &
& deltavd, nbdirs)
!  USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
!print *, "rotor_diameter in deltav exit", rotor_diameter_ust
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: deltay, deltaz, ct, yaw, sigmay
  REAL(dp), DIMENSION(nbdirs), INTENT(IN) :: deltayd, deltazd, ctd, &
& yawd, sigmayd
  REAL(dp), INTENT(IN) :: sigmaz, rotor_diameter_ust, wec_factor, &
& sigmay_spread, sigmaz_spread
  REAL(dp), DIMENSION(nbdirs), INTENT(IN) :: sigmazd, &
& rotor_diameter_ustd, sigmay_spreadd, sigmaz_spreadd
! only for 2014 version
  REAL(dp), INTENT(IN) :: k, deltax
  REAL(dp), DIMENSION(nbdirs), INTENT(IN) :: kd, deltaxd
  INTEGER, INTENT(IN) :: version
! local
! only for 2014 version
  REAL(dp) :: beta_2014, epsilon_2014
  REAL(dp), DIMENSION(nbdirs) :: beta_2014d, epsilon_2014d
! out
  REAL(dp), INTENT(OUT) :: deltav
  REAL(dp), DIMENSION(nbdirs), INTENT(OUT) :: deltavd
! load intrinsic functions
  INTRINSIC COS, SQRT, EXP
  REAL(dp) :: result1
  REAL(dp), DIMENSION(nbdirs) :: result1d
  REAL(dp) :: result2
  REAL(dp), DIMENSION(nbdirs) :: result2d
  REAL(dp) :: arg1
  REAL(dp), DIMENSION(nbdirs) :: arg1d
  REAL(dp) :: arg2
  REAL(dp), DIMENSION(nbdirs) :: arg2d
  REAL(dp) :: arg3
  REAL(dp), DIMENSION(nbdirs) :: arg3d
  INTEGER :: nd
  INTEGER :: nbdirs
!print *, "rotor_diameter in deltav entry", rotor_diameter_ust
!     print *, 'wake model version in deltav: ', version
  IF (version .EQ. 2014) THEN
    result1 = SQRT(1.0_dp - ct)
    result2 = SQRT(1.0_dp - ct)
    beta_2014 = 0.5_dp*(1.0_dp+result1)/result2
    DO nd=1,nbdirs
!print *, "in 2014 version"
      result1d(nd) = -(ctd(nd)/(2.0*SQRT(1.0_dp-ct)))
      result2d(nd) = -(ctd(nd)/(2.0*SQRT(1.0_dp-ct)))
      beta_2014d(nd) = (0.5_dp*result1d(nd)*result2-0.5_dp*(1.0_dp+&
&       result1)*result2d(nd))/result2**2
      IF (beta_2014 .EQ. 0.0) THEN
        result1d(nd) = 0.0_8
      ELSE
        result1d(nd) = beta_2014d(nd)/(2.0*SQRT(beta_2014))
      END IF
      epsilon_2014d(nd) = 0.2_dp*result1d(nd)
    END DO
    result1 = SQRT(beta_2014)
    epsilon_2014 = 0.2_dp*result1
    arg1 = 1.0_dp - ct/(8.0_dp*(k*deltax/rotor_diameter_ust+epsilon_2014&
&     )**2)
    result1 = SQRT(arg1)
    arg2 = (-(1.0_dp/(2.0_dp*(k*deltax/rotor_diameter_ust+epsilon_2014)&
&     **2)))*((deltaz/(wec_factor*rotor_diameter_ust))**2+(deltay/(&
&     wec_factor*rotor_diameter_ust))**2)
    DO nd=1,nbdirs
! print *, "beta = ", beta_2014, "epsilon = ", epsilon_2014
! print *, "k, deltax: ", k, deltax
! print *, "term: ", Ct                                                   &
!                            / (8.0_dp * (k*deltax/rotor_diameter_ust+epsilon_2014)**2)
      arg1d(nd) = -((ctd(nd)*8.0_dp*(k*deltax/rotor_diameter_ust+&
&       epsilon_2014)**2-ct*8.0_dp*2*(k*deltax/rotor_diameter_ust+&
&       epsilon_2014)*(((kd(nd)*deltax+k*deltaxd(nd))*rotor_diameter_ust&
&       -k*deltax*rotor_diameter_ustd(nd))/rotor_diameter_ust**2+&
&       epsilon_2014d(nd)))/(8.0_dp*(k*deltax/rotor_diameter_ust+&
&       epsilon_2014)**2)**2)
      IF (arg1 .EQ. 0.0) THEN
        result1d(nd) = 0.0_8
      ELSE
        result1d(nd) = arg1d(nd)/(2.0*SQRT(arg1))
      END IF
      arg2d(nd) = 2*(((kd(nd)*deltax+k*deltaxd(nd))*rotor_diameter_ust-k&
&       *deltax*rotor_diameter_ustd(nd))/rotor_diameter_ust**2+&
&       epsilon_2014d(nd))*((deltaz/(wec_factor*rotor_diameter_ust))**2+&
&       (deltay/(wec_factor*rotor_diameter_ust))**2)/(2.0_dp*(k*deltax/&
&       rotor_diameter_ust+epsilon_2014)**3) - (2*deltaz*(deltazd(nd)*&
&       wec_factor*rotor_diameter_ust-deltaz*wec_factor*&
&       rotor_diameter_ustd(nd))/(wec_factor**3*rotor_diameter_ust**3)+2&
&       *deltay*(deltayd(nd)*wec_factor*rotor_diameter_ust-deltay*&
&       wec_factor*rotor_diameter_ustd(nd))/(wec_factor**3*&
&       rotor_diameter_ust**3))/(2.0_dp*(k*deltax/rotor_diameter_ust+&
&       epsilon_2014)**2)
      deltavd(nd) = (1.0_dp-result1)*arg2d(nd)*EXP(arg2) - result1d(nd)*&
&       EXP(arg2)
    END DO
    deltav = (1.0_dp-result1)*EXP(arg2)
! print *, "deltav 2014 = ", deltav
  ELSE IF (version .EQ. 2016) THEN
    arg1 = 1.0_dp - ct*COS(yaw)/(8.0_dp*sigmay*sigmaz/rotor_diameter_ust&
&     **2)
    result1 = SQRT(arg1)
    arg2 = -(0.5_dp*(deltay/sigmay_spread)**2)
    arg3 = -(0.5_dp*(deltaz/sigmaz_spread)**2)
    DO nd=1,nbdirs
! velocity difference in the wake at each sample point
      arg1d(nd) = -(((ctd(nd)*COS(yaw)-ct*yawd(nd)*SIN(yaw))*8.0_dp*&
&       sigmay*sigmaz/rotor_diameter_ust**2-ct*COS(yaw)*(8.0_dp*(sigmayd&
&       (nd)*sigmaz+sigmay*sigmazd(nd))*rotor_diameter_ust**2-8.0_dp*&
&       sigmay*sigmaz*2*rotor_diameter_ust*rotor_diameter_ustd(nd))/&
&       rotor_diameter_ust**4)/(8.0_dp*sigmay*sigmaz/rotor_diameter_ust&
&       **2)**2)
      IF (arg1 .EQ. 0.0) THEN
        result1d(nd) = 0.0_8
      ELSE
        result1d(nd) = arg1d(nd)/(2.0*SQRT(arg1))
      END IF
      arg2d(nd) = -(0.5_dp*2*deltay*(deltayd(nd)*sigmay_spread-deltay*&
&       sigmay_spreadd(nd))/sigmay_spread**3)
      arg3d(nd) = -(0.5_dp*2*deltaz*(deltazd(nd)*sigmaz_spread-deltaz*&
&       sigmaz_spreadd(nd))/sigmaz_spread**3)
      deltavd(nd) = ((1.0_dp-result1)*arg2d(nd)*EXP(arg2)-result1d(nd)*&
&       EXP(arg2))*EXP(arg3) + (1.0_dp-result1)*EXP(arg2)*arg3d(nd)*EXP(&
&       arg3)
    END DO
    deltav = (1.0_dp-result1)*EXP(arg2)*EXP(arg3)
  ELSE
    PRINT*, 'Invalid Bastankhah and Porte Agel model version. Must be 20&
&14 or 2016. ', version, ' was given.'
    STOP
  END IF
END SUBROUTINE DELTAV_FUNC_DV

!  Differentiation of deltav_near_wake_lin_func in forward (tangent) mode:
!   variations   of useful results: deltav
!   with respect to varying inputs: sigmay_d k_2014 yaw sigmaz_0
!                discontinuity_point x rotor_diameter_ust sigmay_0
!                sigmay_spread deltay deltaz sigmaz_d x0 sigmaz_spread
!                ct
! calculates the velocity difference between hub velocity and free stream for a given wake
! for use in the near wake region only
SUBROUTINE DELTAV_NEAR_WAKE_LIN_FUNC_DV(deltay, deltayd, deltaz, deltazd&
& , ct, ctd, yaw, yawd, sigmay_0, sigmay_0d, sigmaz_0, sigmaz_0d, x0, &
& x0d, rotor_diameter_ust, rotor_diameter_ustd, x, xd, &
& discontinuity_point, discontinuity_pointd, sigmay_d, sigmay_dd, &
& sigmaz_d, sigmaz_dd, version, k_2014, k_2014d, deltaxd_2014, &
& sigmay_spread, sigmay_spreadd, sigmaz_spread, sigmaz_spreadd, &
& wec_factor_2014, deltav, deltavd, nbdirs)
!  USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: deltay, deltaz, ct, yaw, sigmay_0, sigmaz_0, &
& x0
  REAL(dp), DIMENSION(nbdirs), INTENT(IN) :: deltayd, deltazd, ctd, &
& yawd, sigmay_0d, sigmaz_0d, x0d
  REAL(dp), INTENT(IN) :: rotor_diameter_ust, sigmay_spread, &
& sigmaz_spread
  REAL(dp), DIMENSION(nbdirs), INTENT(IN) :: rotor_diameter_ustd, &
& sigmay_spreadd, sigmaz_spreadd
  REAL(dp), INTENT(IN) :: x, discontinuity_point, sigmay_d, sigmaz_d
  REAL(dp), DIMENSION(nbdirs), INTENT(IN) :: xd, discontinuity_pointd&
& , sigmay_dd, sigmaz_dd
! only for 2014 version
  REAL(dp), INTENT(IN) :: k_2014, deltaxd_2014, wec_factor_2014
  REAL(dp), DIMENSION(nbdirs), INTENT(IN) :: k_2014d
  INTEGER, INTENT(IN) :: version
! local
  REAL(dp) :: deltav0m, deltavdm
  REAL(dp), DIMENSION(nbdirs) :: deltav0md, deltavdmd
! only for 2014 version
  REAL(dp) :: beta_2014, epsilon_2014
  REAL(dp), DIMENSION(nbdirs) :: beta_2014d, epsilon_2014d
! out
  REAL(dp), INTENT(OUT) :: deltav
  REAL(dp), DIMENSION(nbdirs), INTENT(OUT) :: deltavd
! load intrinsic functions
  INTRINSIC COS, SQRT, EXP
  REAL(dp) :: result1
  REAL(dp), DIMENSION(nbdirs) :: result1d
  REAL(dp) :: result2
  REAL(dp), DIMENSION(nbdirs) :: result2d
  REAL(dp) :: arg1
  REAL(dp), DIMENSION(nbdirs) :: arg1d
  REAL(dp) :: arg2
  REAL(dp), DIMENSION(nbdirs) :: arg2d
  INTEGER :: nd
  INTEGER :: nbdirs
  IF (version .EQ. 2014) THEN
!TODO fix 2014 version
    IF (yaw .GT. 0.0_dp) THEN
      PRINT*, 'model version 2014 may only be used when yaw=0'
      STOP
    ELSE
      result1 = SQRT(1.0_dp - ct)
      result2 = SQRT(1.0_dp - ct)
      beta_2014 = 0.5_dp*(1.0_dp+result1)/result2
      DO nd=1,nbdirs
        result1d(nd) = -(ctd(nd)/(2.0*SQRT(1.0_dp-ct)))
        result2d(nd) = -(ctd(nd)/(2.0*SQRT(1.0_dp-ct)))
        beta_2014d(nd) = (0.5_dp*result1d(nd)*result2-0.5_dp*(1.0_dp+&
&         result1)*result2d(nd))/result2**2
        IF (beta_2014 .EQ. 0.0) THEN
          result1d(nd) = 0.0_8
        ELSE
          result1d(nd) = beta_2014d(nd)/(2.0*SQRT(beta_2014))
        END IF
        epsilon_2014d(nd) = 0.2_dp*result1d(nd)
      END DO
      result1 = SQRT(beta_2014)
      epsilon_2014 = 0.2_dp*result1
      arg1 = 1.0_dp - ct/(8.0_dp*(k_2014*x0/rotor_diameter_ust+&
&       epsilon_2014)**2)
      DO nd=1,nbdirs
! magnitude term of gaussian at x0
        arg1d(nd) = -((ctd(nd)*8.0_dp*(k_2014*x0/rotor_diameter_ust+&
&         epsilon_2014)**2-ct*8.0_dp*2*(k_2014*x0/rotor_diameter_ust+&
&         epsilon_2014)*(((k_2014d(nd)*x0+k_2014*x0d(nd))*&
&         rotor_diameter_ust-k_2014*x0*rotor_diameter_ustd(nd))/&
&         rotor_diameter_ust**2+epsilon_2014d(nd)))/(8.0_dp*(k_2014*x0/&
&         rotor_diameter_ust+epsilon_2014)**2)**2)
        IF (arg1 .EQ. 0.0) THEN
          result1d(nd) = 0.0_8
        ELSE
          result1d(nd) = arg1d(nd)/(2.0*SQRT(arg1))
        END IF
        deltav0md(nd) = -result1d(nd)
! initialize the gaussian magnitude term at the rotor for the linear interpolation
        arg1d(nd) = -((ctd(nd)*8.0_dp*(k_2014*discontinuity_point/&
&         rotor_diameter_ust+epsilon_2014)**2-ct*8.0_dp*2*(k_2014*&
&         discontinuity_point/rotor_diameter_ust+epsilon_2014)*(((&
&         k_2014d(nd)*discontinuity_point+k_2014*discontinuity_pointd(nd&
&         ))*rotor_diameter_ust-k_2014*discontinuity_point*&
&         rotor_diameter_ustd(nd))/rotor_diameter_ust**2+epsilon_2014d(&
&         nd)))/(8.0_dp*(k_2014*discontinuity_point/rotor_diameter_ust+&
&         epsilon_2014)**2)**2)
      END DO
      result1 = SQRT(arg1)
      deltav0m = 1.0_dp - result1
      arg1 = 1.0_dp - ct/(8.0_dp*(k_2014*discontinuity_point/&
&       rotor_diameter_ust+epsilon_2014)**2)
      DO nd=1,nbdirs
        IF (arg1 .EQ. 0.0) THEN
          result1d(nd) = 0.0_8
        ELSE
          result1d(nd) = arg1d(nd)/(2.0*SQRT(arg1))
        END IF
        deltavdmd(nd) = -result1d(nd)
! linearized gaussian magnitude term for near wake
        arg1d(nd) = 2*(((k_2014d(nd)*x+k_2014*xd(nd))*rotor_diameter_ust&
&         -k_2014*x*rotor_diameter_ustd(nd))/rotor_diameter_ust**2+&
&         epsilon_2014d(nd))*((deltaz/(wec_factor_2014*&
&         rotor_diameter_ust))**2+(deltay/(wec_factor_2014*&
&         rotor_diameter_ust))**2)/(2.0_dp*(k_2014*x/rotor_diameter_ust+&
&         epsilon_2014)**3) - (2*deltaz*(deltazd(nd)*wec_factor_2014*&
&         rotor_diameter_ust-deltaz*wec_factor_2014*rotor_diameter_ustd(&
&         nd))/(wec_factor_2014**3*rotor_diameter_ust**3)+2*deltay*(&
&         deltayd(nd)*wec_factor_2014*rotor_diameter_ust-deltay*&
&         wec_factor_2014*rotor_diameter_ustd(nd))/(wec_factor_2014**3*&
&         rotor_diameter_ust**3))/(2.0_dp*(k_2014*x/rotor_diameter_ust+&
&         epsilon_2014)**2)
      END DO
      result1 = SQRT(arg1)
      deltavdm = 1.0_dp - result1
      arg1 = (-(1.0_dp/(2.0_dp*(k_2014*x/rotor_diameter_ust+epsilon_2014&
&       )**2)))*((deltaz/(wec_factor_2014*rotor_diameter_ust))**2+(&
&       deltay/(wec_factor_2014*rotor_diameter_ust))**2)
      DO nd=1,nbdirs
        deltavd(nd) = (((deltav0md(nd)-deltavdmd(nd))*x0-(deltav0m-&
&         deltavdm)*x0d(nd))*x/x0**2+(deltav0m-deltavdm)*xd(nd)/x0+&
&         deltavdmd(nd))*EXP(arg1) + ((deltav0m-deltavdm)/x0*x+deltavdm)&
&         *arg1d(nd)*EXP(arg1)
      END DO
      deltav = ((deltav0m-deltavdm)/x0*x+deltavdm)*EXP(arg1)
    END IF
  ELSE IF (version .EQ. 2016) THEN
    arg1 = 1.0_dp - ct*COS(yaw)/(8.0_dp*sigmay_0*sigmaz_0/&
&     rotor_diameter_ust**2)
    DO nd=1,nbdirs
! magnitude term of gaussian at x0
      arg1d(nd) = -(((ctd(nd)*COS(yaw)-ct*yawd(nd)*SIN(yaw))*8.0_dp*&
&       sigmay_0*sigmaz_0/rotor_diameter_ust**2-ct*COS(yaw)*(8.0_dp*(&
&       sigmay_0d(nd)*sigmaz_0+sigmay_0*sigmaz_0d(nd))*&
&       rotor_diameter_ust**2-8.0_dp*sigmay_0*sigmaz_0*2*&
&       rotor_diameter_ust*rotor_diameter_ustd(nd))/rotor_diameter_ust**&
&       4)/(8.0_dp*sigmay_0*sigmaz_0/rotor_diameter_ust**2)**2)
      IF (arg1 .EQ. 0.0) THEN
        result1d(nd) = 0.0_8
      ELSE
        result1d(nd) = arg1d(nd)/(2.0*SQRT(arg1))
      END IF
      deltav0md(nd) = -result1d(nd)
! initialize the gaussian magnitude term at the rotor for the linear interpolation
      arg1d(nd) = -(((ctd(nd)*COS(yaw)-ct*yawd(nd)*SIN(yaw))*8.0_dp*&
&       sigmay_d*sigmaz_d/rotor_diameter_ust**2-ct*COS(yaw)*(8.0_dp*(&
&       sigmay_dd(nd)*sigmaz_d+sigmay_d*sigmaz_dd(nd))*&
&       rotor_diameter_ust**2-8.0_dp*sigmay_d*sigmaz_d*2*&
&       rotor_diameter_ust*rotor_diameter_ustd(nd))/rotor_diameter_ust**&
&       4)/(8.0_dp*sigmay_d*sigmaz_d/rotor_diameter_ust**2)**2)
      arg2d(nd) = -(0.5_dp*2*deltaz*(deltazd(nd)*sigmaz_spread-deltaz*&
&       sigmaz_spreadd(nd))/sigmaz_spread**3)
    END DO
    result1 = SQRT(arg1)
    deltav0m = 1.0_dp - result1
    arg1 = 1.0_dp - ct*COS(yaw)/(8.0_dp*sigmay_d*sigmaz_d/&
&     rotor_diameter_ust**2)
    DO nd=1,nbdirs
      IF (arg1 .EQ. 0.0) THEN
        result1d(nd) = 0.0_8
      ELSE
        result1d(nd) = arg1d(nd)/(2.0*SQRT(arg1))
      END IF
      deltavdmd(nd) = -result1d(nd)
! linearized gaussian magnitude term for near wake
      arg1d(nd) = -(0.5_dp*2*deltay*(deltayd(nd)*sigmay_spread-deltay*&
&       sigmay_spreadd(nd))/sigmay_spread**3)
    END DO
    result1 = SQRT(arg1)
    deltavdm = 1.0_dp - result1
    arg1 = -(0.5_dp*(deltay/sigmay_spread)**2)
    arg2 = -(0.5_dp*(deltaz/sigmaz_spread)**2)
    DO nd=1,nbdirs
      deltavd(nd) = ((((deltav0md(nd)-deltavdmd(nd))*x0-(deltav0m-&
&       deltavdm)*x0d(nd))*x/x0**2+(deltav0m-deltavdm)*xd(nd)/x0+&
&       deltavdmd(nd))*EXP(arg1)+((deltav0m-deltavdm)/x0*x+deltavdm)*&
&       arg1d(nd)*EXP(arg1))*EXP(arg2) + ((deltav0m-deltavdm)/x0*x+&
&       deltavdm)*EXP(arg1)*arg2d(nd)*EXP(arg2)
    END DO
    deltav = ((deltav0m-deltavdm)/x0*x+deltavdm)*EXP(arg1)*EXP(arg2)
  ELSE
    PRINT*, 'Invalid Bastankhah and Porte Agel model version. Must be 20&
&14 or 2016. ', version, ' was given.'
    STOP
  END IF
END SUBROUTINE DELTAV_NEAR_WAKE_LIN_FUNC_DV

!  Differentiation of wake_combination_func in forward (tangent) mode:
!   variations   of useful results: new_deficit_sum
!   with respect to varying inputs: turb_inflow old_deficit_sum
!                deltav
! combines wakes using various methods
SUBROUTINE WAKE_COMBINATION_FUNC_DV(wind_speed, turb_inflow, &
& turb_inflowd, deltav, deltavd, wake_combination_method, &
& old_deficit_sum, old_deficit_sumd, new_deficit_sum, new_deficit_sumd, &
& nbdirs)
!  USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: wind_speed, turb_inflow, deltav, &
& old_deficit_sum
  REAL(dp), DIMENSION(nbdirs), INTENT(IN) :: turb_inflowd, deltavd, &
& old_deficit_sumd
  INTEGER, INTENT(IN) :: wake_combination_method
! out    
  REAL(dp), INTENT(OUT) :: new_deficit_sum
  REAL(dp), DIMENSION(nbdirs), INTENT(OUT) :: new_deficit_sumd
! intrinsic functions
  INTRINSIC SQRT
  REAL(dp) :: arg1
  REAL(dp), DIMENSION(nbdirs) :: arg1d
  INTEGER :: nd
  INTEGER :: nbdirs
! freestream linear superposition (Lissaman 1979)
  IF (wake_combination_method .EQ. 0) THEN
    DO nd=1,nbdirs
      new_deficit_sumd(nd) = old_deficit_sumd(nd) + wind_speed*deltavd(&
&       nd)
    END DO
    new_deficit_sum = old_deficit_sum + wind_speed*deltav
! local velocity linear superposition (Niayifar and Porte Agel 2015, 2016)
  ELSE IF (wake_combination_method .EQ. 1) THEN
    DO nd=1,nbdirs
      new_deficit_sumd(nd) = old_deficit_sumd(nd) + turb_inflowd(nd)*&
&       deltav + turb_inflow*deltavd(nd)
    END DO
    new_deficit_sum = old_deficit_sum + turb_inflow*deltav
!print *, "here"
! sum of squares freestream superposition (Katic et al. 1986)
  ELSE IF (wake_combination_method .EQ. 2) THEN
    arg1 = old_deficit_sum**2 + (wind_speed*deltav)**2
    DO nd=1,nbdirs
      arg1d(nd) = 2*old_deficit_sum*old_deficit_sumd(nd) + 2*wind_speed&
&       **2*deltav*deltavd(nd)
      IF (arg1 .EQ. 0.0) THEN
        new_deficit_sumd(nd) = 0.0_8
      ELSE
        new_deficit_sumd(nd) = arg1d(nd)/(2.0*SQRT(arg1))
      END IF
    END DO
    new_deficit_sum = SQRT(arg1)
! sum of squares local velocity superposition (Voutsinas 1990)
  ELSE IF (wake_combination_method .EQ. 3) THEN
    arg1 = old_deficit_sum**2 + (turb_inflow*deltav)**2
    DO nd=1,nbdirs
      arg1d(nd) = 2*old_deficit_sum*old_deficit_sumd(nd) + 2*turb_inflow&
&       *deltav*(turb_inflowd(nd)*deltav+turb_inflow*deltavd(nd))
      IF (arg1 .EQ. 0.0) THEN
        new_deficit_sumd(nd) = 0.0_8
      ELSE
        new_deficit_sumd(nd) = arg1d(nd)/(2.0*SQRT(arg1))
      END IF
    END DO
    new_deficit_sum = SQRT(arg1)
! wake combination method error
  ELSE
    PRINT*, 'Invalid wake combination method. Must be one of [0,1,2,3].'
    STOP
  END IF
END SUBROUTINE WAKE_COMBINATION_FUNC_DV

!  Differentiation of added_ti_func in forward (tangent) mode:
!   variations   of useful results: ti_dst ti_area_ratio
!   with respect to varying inputs: k_star_ust x rotor_diameter_ust
!                wake_height turbine_height ti_dst_in ct_ust deltay
!                ti_area_ratio_in rotor_diameter_dst ti_ust
! combines wakes using various methods
SUBROUTINE ADDED_TI_FUNC_DV(ti, ct_ust, ct_ustd, x, xd, k_star_ust, &
& k_star_ustd, rotor_diameter_ust, rotor_diameter_ustd, &
& rotor_diameter_dst, rotor_diameter_dstd, deltay, deltayd, wake_height&
& , wake_heightd, turbine_height, turbine_heightd, sm_smoothing, ti_ust&
& , ti_ustd, ti_calculation_method, ti_area_ratio_in, ti_area_ratio_ind&
& , ti_dst_in, ti_dst_ind, ti_area_ratio, ti_area_ratiod, ti_dst, &
& ti_dstd, nbdirs)
!  USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
!print *, "ratio: ", wake_overlap/rotor_area_dst
!print *, "Dr, Dw: ", rotor_diameter_dst, wake_diameter
!print *, "Ar, Aol: ", rotor_area_dst, wake_overlap          
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: ct_ust, x, k_star_ust, rotor_diameter_ust, &
& rotor_diameter_dst
  REAL(dp), DIMENSION(nbdirs), INTENT(IN) :: ct_ustd, xd, k_star_ustd&
& , rotor_diameter_ustd, rotor_diameter_dstd
  REAL(dp), INTENT(IN) :: deltay, wake_height, turbine_height, &
& sm_smoothing
  REAL(dp), DIMENSION(nbdirs), INTENT(IN) :: deltayd, wake_heightd, &
& turbine_heightd
  REAL(dp), INTENT(IN) :: ti_ust, ti, ti_area_ratio_in, ti_dst_in
  REAL(dp), DIMENSION(nbdirs), INTENT(IN) :: ti_ustd, &
& ti_area_ratio_ind, ti_dst_ind
  INTEGER, INTENT(IN) :: ti_calculation_method
! local
  REAL(dp) :: axial_induction_ust, beta, epsilon, sigma, wake_diameter, &
& wake_overlap
  REAL(dp), DIMENSION(nbdirs) :: axial_induction_ustd, betad, &
& epsilond, sigmad, wake_diameterd, wake_overlapd
  REAL(dp) :: ti_added, ti_tmp, rotor_area_dst, ti_area_ratio_tmp
  REAL(dp), DIMENSION(nbdirs) :: ti_addedd, ti_tmpd, rotor_area_dstd&
& , ti_area_ratio_tmpd
  REAL(dp), PARAMETER :: pi=3.141592653589793_dp
! out  
  REAL(dp), INTENT(OUT) :: ti_dst, ti_area_ratio
  REAL(dp), DIMENSION(nbdirs), INTENT(OUT) :: ti_dstd, ti_area_ratiod
! intrinsic functions
  INTRINSIC SQRT
  REAL(dp) :: result1
  REAL(dp), DIMENSION(nbdirs) :: result1d
  REAL(dp) :: result2
  REAL(dp), DIMENSION(nbdirs) :: result2d
  REAL(dp) :: pwx1
  REAL(dp), DIMENSION(nbdirs) :: pwx1d
  REAL(dp) :: pwr1
  REAL(dp), DIMENSION(nbdirs) :: pwr1d
  REAL(dp) :: arg1
  REAL(dp), DIMENSION(nbdirs) :: arg1d
  INTEGER :: nd
  INTEGER :: nbdirs
  DO nd=1,nbdirs
! initialize output variables
    ti_area_ratiod(nd) = ti_area_ratio_ind(nd)
    ti_dstd(nd) = ti_dst_ind(nd)
  END DO
  ti_area_ratio = ti_area_ratio_in
  ti_dst = ti_dst_in
! initialize wake overlap to zero
  wake_overlap = 0.0_dp
!print *, "TI_dst in: ", TI_dst
! Niayifar and Porte Agel 2015, 2016 (adjusted by Annoni and Thomas for SOWFA match 
! and optimization)
  IF (ti_calculation_method .EQ. 1) THEN
! calculate axial induction based on the Ct value
    CALL CT_TO_AXIAL_IND_FUNC_DV(ct_ust, ct_ustd, axial_induction_ust, &
&                          axial_induction_ustd, nbdirs)
    result1 = SQRT(1.0_dp - ct_ust)
    result2 = SQRT(1.0_dp - ct_ust)
    beta = 0.5_dp*((1.0_dp+result1)/result2)
    pwx1 = x/rotor_diameter_ust
    pwr1 = pwx1**(-0.32_dp)
    DO nd=1,nbdirs
! calculate BPA spread parameters Bastankhah and Porte Agel 2014
      result1d(nd) = -(ct_ustd(nd)/(2.0*SQRT(1.0_dp-ct_ust)))
      result2d(nd) = -(ct_ustd(nd)/(2.0*SQRT(1.0_dp-ct_ust)))
      betad(nd) = 0.5_dp*(result1d(nd)*result2-(1.0_dp+result1)*result2d&
&       (nd))/result2**2
      IF (beta .EQ. 0.0) THEN
        result1d(nd) = 0.0_8
      ELSE
        result1d(nd) = betad(nd)/(2.0*SQRT(beta))
      END IF
      epsilond(nd) = 0.2_dp*result1d(nd)
!print *, "wake_overlap = ", wake_overlap   
! Calculate the turbulence added to the inflow of the downstream turbine by the 
! wake of the upstream turbine
      pwx1d(nd) = (xd(nd)*rotor_diameter_ust-x*rotor_diameter_ustd(nd))/&
&       rotor_diameter_ust**2
      IF (pwx1 .GT. 0.0) THEN
        pwr1d(nd) = -(0.32_dp*pwx1**(-1.32)*pwx1d(nd))
      ELSE
        pwr1d(nd) = 0.0
      END IF
      ti_addedd(nd) = 0.73_dp*((0.8325_dp*axial_induction_ust**(-0.1675)&
&       *axial_induction_ustd(nd)*pwr1+axial_induction_ust**0.8325_dp*&
&       pwr1d(nd))*ti_ust**0.0325_dp+axial_induction_ust**0.8325_dp*pwr1&
&       *0.0325_dp*ti_ust**(-0.9675)*ti_ustd(nd))
!print *, "TI_added = ", TI_added
      rotor_area_dstd(nd) = 0.25_dp*pi*2_dp*rotor_diameter_dst*&
&       rotor_diameter_dstd(nd)
    END DO
    result1 = SQRT(beta)
    epsilon = 0.2_dp*result1
    DO nd=1,nbdirs
!print *, "epsilon = ", epsilon
! calculate wake spread for TI calcs
      sigmad(nd) = k_star_ustd(nd)*x + k_star_ust*xd(nd) + &
&       rotor_diameter_ustd(nd)*epsilon + rotor_diameter_ust*epsilond(nd&
&       )
      wake_diameterd(nd) = 4.0_dp*sigmad(nd)
    END DO
    sigma = k_star_ust*x + rotor_diameter_ust*epsilon
    wake_diameter = 4.0_dp*sigma
!print *, "sigma = ", sigma
! calculate wake overlap ratio
    CALL OVERLAP_AREA_FUNC_DV(deltay, deltayd, turbine_height, &
&                       turbine_heightd, rotor_diameter_dst, &
&                       rotor_diameter_dstd, 0.0_dp, wake_height, &
&                       wake_heightd, wake_diameter, wake_diameterd, &
&                       wake_overlap, wake_overlapd, nbdirs)
    ti_added = 0.73_dp*axial_induction_ust**0.8325_dp*ti_ust**0.0325_dp*&
&     pwr1
    rotor_area_dst = 0.25_dp*pi*rotor_diameter_dst**2_dp
    arg1 = ti_dst_in**2.0_dp + (ti_added*wake_overlap/rotor_area_dst)**&
&     2.0_dp
    DO nd=1,nbdirs
! Calculate the total turbulence intensity at the downstream turbine
!sum_of_squares = TI_dst**2 + (TI_added*wake_overlap)**2
! print *, "sum of squares = ", sum_of_squares
!         TI_dst = sqrt(sum_of_squares)
!         !print *, "TI_dst = ", TI_dst
      arg1d(nd) = 2.0_dp*ti_dst_in*ti_dst_ind(nd) + 2.0_dp*ti_added*&
&       wake_overlap*((ti_addedd(nd)*wake_overlap+ti_added*wake_overlapd&
&       (nd))*rotor_area_dst-ti_added*wake_overlap*rotor_area_dstd(nd))/&
&       rotor_area_dst**3
      IF (arg1 .EQ. 0.0) THEN
        ti_dstd(nd) = 0.0_8
      ELSE
        ti_dstd(nd) = arg1d(nd)/(2.0*SQRT(arg1))
      END IF
    END DO
    ti_dst = SQRT(arg1)
! Niayifar and Porte Agel 2015, 2016
  ELSE IF (ti_calculation_method .EQ. 2) THEN
! calculate axial induction based on the Ct value
    CALL CT_TO_AXIAL_IND_FUNC_DV(ct_ust, ct_ustd, axial_induction_ust, &
&                          axial_induction_ustd, nbdirs)
    result1 = SQRT(1.0_dp - ct_ust)
    result2 = SQRT(1.0_dp - ct_ust)
    beta = 0.5_dp*((1.0_dp+result1)/result2)
    pwx1 = x/rotor_diameter_ust
    pwr1 = pwx1**(-0.32_dp)
    DO nd=1,nbdirs
! calculate BPA spread parameters Bastankhah and Porte Agel 2014
      result1d(nd) = -(ct_ustd(nd)/(2.0*SQRT(1.0_dp-ct_ust)))
      result2d(nd) = -(ct_ustd(nd)/(2.0*SQRT(1.0_dp-ct_ust)))
      betad(nd) = 0.5_dp*(result1d(nd)*result2-(1.0_dp+result1)*result2d&
&       (nd))/result2**2
      IF (beta .EQ. 0.0) THEN
        result1d(nd) = 0.0_8
      ELSE
        result1d(nd) = betad(nd)/(2.0*SQRT(beta))
      END IF
      epsilond(nd) = 0.2_dp*result1d(nd)
! Calculate the turbulence added to the inflow of the downstream turbine by the 
! wake of the upstream turbine
      pwx1d(nd) = (xd(nd)*rotor_diameter_ust-x*rotor_diameter_ustd(nd))/&
&       rotor_diameter_ust**2
      IF (pwx1 .GT. 0.0) THEN
        pwr1d(nd) = -(0.32_dp*pwx1**(-1.32)*pwx1d(nd))
      ELSE
        pwr1d(nd) = 0.0
      END IF
      ti_addedd(nd) = 0.73_dp*((0.8325_dp*axial_induction_ust**(-0.1675)&
&       *axial_induction_ustd(nd)*pwr1+axial_induction_ust**0.8325_dp*&
&       pwr1d(nd))*ti_ust**0.0325_dp+axial_induction_ust**0.8325_dp*pwr1&
&       *0.0325_dp*ti_ust**(-0.9675)*ti_ustd(nd))
! Calculate the total turbulence intensity at the downstream turbine based on 
! current upstream turbine
      rotor_area_dstd(nd) = 0.25_dp*pi*2_dp*rotor_diameter_dst*&
&       rotor_diameter_dstd(nd)
    END DO
    result1 = SQRT(beta)
    epsilon = 0.2_dp*result1
    DO nd=1,nbdirs
! calculate wake spread for TI calcs
      sigmad(nd) = k_star_ustd(nd)*x + k_star_ust*xd(nd) + &
&       rotor_diameter_ustd(nd)*epsilon + rotor_diameter_ust*epsilond(nd&
&       )
      wake_diameterd(nd) = 4.0_dp*sigmad(nd)
    END DO
    sigma = k_star_ust*x + rotor_diameter_ust*epsilon
    wake_diameter = 4.0_dp*sigma
! calculate wake overlap ratio
    CALL OVERLAP_AREA_FUNC_DV(deltay, deltayd, turbine_height, &
&                       turbine_heightd, rotor_diameter_dst, &
&                       rotor_diameter_dstd, 0.0_dp, wake_height, &
&                       wake_heightd, wake_diameter, wake_diameterd, &
&                       wake_overlap, wake_overlapd, nbdirs)
    ti_added = 0.73_dp*axial_induction_ust**0.8325_dp*ti_ust**0.0325_dp*&
&     pwr1
    rotor_area_dst = 0.25_dp*pi*rotor_diameter_dst**2_dp
    arg1 = ti**2.0_dp + (ti_added*(wake_overlap/rotor_area_dst))**2.0_dp
    DO nd=1,nbdirs
      arg1d(nd) = 2.0_dp*ti_added*wake_overlap*(ti_addedd(nd)*&
&       wake_overlap/rotor_area_dst+ti_added*(wake_overlapd(nd)*&
&       rotor_area_dst-wake_overlap*rotor_area_dstd(nd))/rotor_area_dst&
&       **2)/rotor_area_dst
      IF (arg1 .EQ. 0.0) THEN
        ti_tmpd(nd) = 0.0_8
      ELSE
        ti_tmpd(nd) = arg1d(nd)/(2.0*SQRT(arg1))
      END IF
    END DO
    ti_tmp = SQRT(arg1)
! Check if this is the max and use it if it is
    IF (ti_tmp .GT. ti_dst_in) THEN
      DO nd=1,nbdirs
!            print *, "TI_tmp > TI_dst"
        ti_dstd(nd) = ti_tmpd(nd)
      END DO
      ti_dst = ti_tmp
    END IF
  ELSE IF (ti_calculation_method .EQ. 3) THEN
! Niayifar and Porte Agel 2015, 2016 with smooth max
! calculate axial induction based on the Ct value
    CALL CT_TO_AXIAL_IND_FUNC_DV(ct_ust, ct_ustd, axial_induction_ust, &
&                          axial_induction_ustd, nbdirs)
    result1 = SQRT(1.0_dp - ct_ust)
    result2 = SQRT(1.0_dp - ct_ust)
    beta = 0.5_dp*((1.0_dp+result1)/result2)
    pwx1 = x/rotor_diameter_ust
    pwr1 = pwx1**(-0.32_dp)
    DO nd=1,nbdirs
! calculate BPA spread parameters Bastankhah and Porte Agel 2014
      result1d(nd) = -(ct_ustd(nd)/(2.0*SQRT(1.0_dp-ct_ust)))
      result2d(nd) = -(ct_ustd(nd)/(2.0*SQRT(1.0_dp-ct_ust)))
      betad(nd) = 0.5_dp*(result1d(nd)*result2-(1.0_dp+result1)*result2d&
&       (nd))/result2**2
      IF (beta .EQ. 0.0) THEN
        result1d(nd) = 0.0_8
      ELSE
        result1d(nd) = betad(nd)/(2.0*SQRT(beta))
      END IF
      epsilond(nd) = 0.2_dp*result1d(nd)
! Calculate the turbulence added to the inflow of the downstream turbine by the 
! wake of the upstream turbine
      pwx1d(nd) = (xd(nd)*rotor_diameter_ust-x*rotor_diameter_ustd(nd))/&
&       rotor_diameter_ust**2
      IF (pwx1 .GT. 0.0) THEN
        pwr1d(nd) = -(0.32_dp*pwx1**(-1.32)*pwx1d(nd))
      ELSE
        pwr1d(nd) = 0.0
      END IF
      ti_addedd(nd) = 0.73_dp*((0.8325_dp*axial_induction_ust**(-0.1675)&
&       *axial_induction_ustd(nd)*pwr1+axial_induction_ust**0.8325_dp*&
&       pwr1d(nd))*ti_ust**0.0325_dp+axial_induction_ust**0.8325_dp*pwr1&
&       *0.0325_dp*ti_ust**(-0.9675)*ti_ustd(nd))
! Calculate the total turbulence intensity at the downstream turbine based on 
! current upstream turbine
      rotor_area_dstd(nd) = 0.25_dp*pi*2_dp*rotor_diameter_dst*&
&       rotor_diameter_dstd(nd)
    END DO
    result1 = SQRT(beta)
    epsilon = 0.2_dp*result1
    DO nd=1,nbdirs
! calculate wake spread for TI calcs
      sigmad(nd) = k_star_ustd(nd)*x + k_star_ust*xd(nd) + &
&       rotor_diameter_ustd(nd)*epsilon + rotor_diameter_ust*epsilond(nd&
&       )
      wake_diameterd(nd) = 4.0_dp*sigmad(nd)
    END DO
    sigma = k_star_ust*x + rotor_diameter_ust*epsilon
    wake_diameter = 4.0_dp*sigma
!         print *, "sigma, k_star_ust, x, rotor_diameter_ust, epsilon ", sigma, k_star_ust, x, rotor_diameter_ust, epsilon
! print *, "deltay, turbine_height, rotor_diameter_dst, wake_height, wake_diameter", &
!                 & deltay, turbine_height, rotor_diameter_dst, &
!                             wake_height, wake_diameter
! calculate wake overlap ratio
    CALL OVERLAP_AREA_FUNC_DV(deltay, deltayd, turbine_height, &
&                       turbine_heightd, rotor_diameter_dst, &
&                       rotor_diameter_dstd, 0.0_dp, wake_height, &
&                       wake_heightd, wake_diameter, wake_diameterd, &
&                       wake_overlap, wake_overlapd, nbdirs)
    ti_added = 0.73_dp*axial_induction_ust**0.8325_dp*ti_ust**0.0325_dp*&
&     pwr1
    rotor_area_dst = 0.25_dp*pi*rotor_diameter_dst**2_dp
    arg1 = ti**2.0_dp + (ti_added*(wake_overlap/rotor_area_dst))**2.0_dp
    DO nd=1,nbdirs
      arg1d(nd) = 2.0_dp*ti_added*wake_overlap*(ti_addedd(nd)*&
&       wake_overlap/rotor_area_dst+ti_added*(wake_overlapd(nd)*&
&       rotor_area_dst-wake_overlap*rotor_area_dstd(nd))/rotor_area_dst&
&       **2)/rotor_area_dst
      IF (arg1 .EQ. 0.0) THEN
        ti_tmpd(nd) = 0.0_8
      ELSE
        ti_tmpd(nd) = arg1d(nd)/(2.0*SQRT(arg1))
      END IF
    END DO
    ti_tmp = SQRT(arg1)
!print *, "TI, TI_added, wake_overlap, rotor_area_dst: ", TI, TI_added, wake_overlap, rotor_area_dst
! Check if this is the max and use it if it is
!if (TI_tmp > TI_dst) then
!    TI_dst = TI_tmp
!end if
!         print *, "before: ", TI_dst, TI_tmp
!         TI_dst_in = TI_dst
    CALL SMOOTH_MAX_DV(sm_smoothing, ti_dst_in, ti_dst_ind, ti_tmp, &
&                ti_tmpd, ti_dst, ti_dstd, nbdirs)
!         print *, "after:: ", TI_dst, TI_tmp
! Niayifar and Porte Agel 2015, 2016 using max on area TI ratio
  ELSE IF (ti_calculation_method .EQ. 4) THEN
! calculate axial induction based on the Ct value
    CALL CT_TO_AXIAL_IND_FUNC_DV(ct_ust, ct_ustd, axial_induction_ust, &
&                          axial_induction_ustd, nbdirs)
    result1 = SQRT(1.0_dp - ct_ust)
    result2 = SQRT(1.0_dp - ct_ust)
    beta = 0.5_dp*((1.0_dp+result1)/result2)
    pwx1 = x/rotor_diameter_ust
    pwr1 = pwx1**(-0.32_dp)
    DO nd=1,nbdirs
! calculate BPA spread parameters Bastankhah and Porte Agel 2014
      result1d(nd) = -(ct_ustd(nd)/(2.0*SQRT(1.0_dp-ct_ust)))
      result2d(nd) = -(ct_ustd(nd)/(2.0*SQRT(1.0_dp-ct_ust)))
      betad(nd) = 0.5_dp*(result1d(nd)*result2-(1.0_dp+result1)*result2d&
&       (nd))/result2**2
      IF (beta .EQ. 0.0) THEN
        result1d(nd) = 0.0_8
      ELSE
        result1d(nd) = betad(nd)/(2.0*SQRT(beta))
      END IF
      epsilond(nd) = 0.2_dp*result1d(nd)
! Calculate the turbulence added to the inflow of the downstream turbine by the 
! wake of the upstream turbine
      pwx1d(nd) = (xd(nd)*rotor_diameter_ust-x*rotor_diameter_ustd(nd))/&
&       rotor_diameter_ust**2
      IF (pwx1 .GT. 0.0) THEN
        pwr1d(nd) = -(0.32_dp*pwx1**(-1.32)*pwx1d(nd))
      ELSE
        pwr1d(nd) = 0.0
      END IF
      ti_addedd(nd) = 0.73_dp*((0.8325_dp*axial_induction_ust**(-0.1675)&
&       *axial_induction_ustd(nd)*pwr1+axial_induction_ust**0.8325_dp*&
&       pwr1d(nd))*ti_ust**0.0325_dp+axial_induction_ust**0.8325_dp*pwr1&
&       *0.0325_dp*ti_ust**(-0.9675)*ti_ustd(nd))
! Calculate the total turbulence intensity at the downstream turbine based on 
! current upstream turbine
      rotor_area_dstd(nd) = 0.25_dp*pi*2_dp*rotor_diameter_dst*&
&       rotor_diameter_dstd(nd)
    END DO
    result1 = SQRT(beta)
    epsilon = 0.2_dp*result1
    DO nd=1,nbdirs
! calculate wake spread for TI calcs
      sigmad(nd) = k_star_ustd(nd)*x + k_star_ust*xd(nd) + &
&       rotor_diameter_ustd(nd)*epsilon + rotor_diameter_ust*epsilond(nd&
&       )
      wake_diameterd(nd) = 4.0_dp*sigmad(nd)
    END DO
    sigma = k_star_ust*x + rotor_diameter_ust*epsilon
    wake_diameter = 4.0_dp*sigma
! calculate wake overlap ratio
    CALL OVERLAP_AREA_FUNC_DV(deltay, deltayd, turbine_height, &
&                       turbine_heightd, rotor_diameter_dst, &
&                       rotor_diameter_dstd, 0.0_dp, wake_height, &
&                       wake_heightd, wake_diameter, wake_diameterd, &
&                       wake_overlap, wake_overlapd, nbdirs)
    ti_added = 0.73_dp*axial_induction_ust**0.8325_dp*ti_ust**0.0325_dp*&
&     pwr1
    rotor_area_dst = 0.25_dp*pi*rotor_diameter_dst**2_dp
    DO nd=1,nbdirs
      ti_area_ratio_tmpd(nd) = ti_addedd(nd)*wake_overlap/rotor_area_dst&
&       + ti_added*(wake_overlapd(nd)*rotor_area_dst-wake_overlap*&
&       rotor_area_dstd(nd))/rotor_area_dst**2
    END DO
    ti_area_ratio_tmp = ti_added*(wake_overlap/rotor_area_dst)
! Check if this is the max and use it if it is
    IF (ti_area_ratio_tmp .GT. ti_area_ratio_in) THEN
      ti_area_ratio = ti_area_ratio_tmp
      arg1 = ti**2.0_dp + ti_area_ratio**2.0_dp
      DO nd=1,nbdirs
!            print *, "ti_area_ratio_tmp > ti_area_ratio"
!TI_dst = TI_tmp
        ti_area_ratiod(nd) = ti_area_ratio_tmpd(nd)
        arg1d(nd) = 2.0_dp*ti_area_ratio*ti_area_ratiod(nd)
        IF (arg1 .EQ. 0.0) THEN
          ti_dstd(nd) = 0.0_8
        ELSE
          ti_dstd(nd) = arg1d(nd)/(2.0*SQRT(arg1))
        END IF
      END DO
      ti_dst = SQRT(arg1)
    END IF
  ELSE IF (ti_calculation_method .EQ. 5) THEN
! Niayifar and Porte Agel 2015, 2016 using smooth max on area TI ratio
! calculate axial induction based on the Ct value
    CALL CT_TO_AXIAL_IND_FUNC_DV(ct_ust, ct_ustd, axial_induction_ust, &
&                          axial_induction_ustd, nbdirs)
    result1 = SQRT(1.0_dp - ct_ust)
    result2 = SQRT(1.0_dp - ct_ust)
    beta = 0.5_dp*((1.0_dp+result1)/result2)
    DO nd=1,nbdirs
! calculate BPA spread parameters Bastankhah and Porte Agel 2014
      result1d(nd) = -(ct_ustd(nd)/(2.0*SQRT(1.0_dp-ct_ust)))
      result2d(nd) = -(ct_ustd(nd)/(2.0*SQRT(1.0_dp-ct_ust)))
      betad(nd) = 0.5_dp*(result1d(nd)*result2-(1.0_dp+result1)*result2d&
&       (nd))/result2**2
      IF (beta .EQ. 0.0) THEN
        result1d(nd) = 0.0_8
      ELSE
        result1d(nd) = betad(nd)/(2.0*SQRT(beta))
      END IF
      epsilond(nd) = 0.2_dp*result1d(nd)
    END DO
    result1 = SQRT(beta)
    epsilon = 0.2_dp*result1
    DO nd=1,nbdirs
! calculate wake spread for TI calcs
      sigmad(nd) = k_star_ustd(nd)*x + k_star_ust*xd(nd) + &
&       rotor_diameter_ustd(nd)*epsilon + rotor_diameter_ust*epsilond(nd&
&       )
      wake_diameterd(nd) = 4.0_dp*sigmad(nd)
    END DO
    sigma = k_star_ust*x + rotor_diameter_ust*epsilon
    wake_diameter = 4.0_dp*sigma
! calculate wake overlap ratio
    CALL OVERLAP_AREA_FUNC_DV(deltay, deltayd, turbine_height, &
&                       turbine_heightd, rotor_diameter_dst, &
&                       rotor_diameter_dstd, 0.0_dp, wake_height, &
&                       wake_heightd, wake_diameter, wake_diameterd, &
&                       wake_overlap, wake_overlapd, nbdirs)
! only include turbines with area overlap in the softmax
    IF (wake_overlap .GT. 0.0_dp) THEN
      pwx1 = x/rotor_diameter_ust
      pwr1 = pwx1**(-0.32_dp)
      ti_added = 0.73_dp*axial_induction_ust**0.8325_dp*ti_ust**&
&       0.0325_dp*pwr1
      rotor_area_dst = 0.25_dp*pi*rotor_diameter_dst**2_dp
      DO nd=1,nbdirs
! Calculate the turbulence added to the inflow of the downstream turbine by the 
! wake of the upstream turbine
        pwx1d(nd) = (xd(nd)*rotor_diameter_ust-x*rotor_diameter_ustd(nd)&
&         )/rotor_diameter_ust**2
        IF (pwx1 .GT. 0.0) THEN
          pwr1d(nd) = -(0.32_dp*pwx1**(-1.32)*pwx1d(nd))
        ELSE
          pwr1d(nd) = 0.0
        END IF
        ti_addedd(nd) = 0.73_dp*((0.8325_dp*axial_induction_ust**(&
&         -0.1675)*axial_induction_ustd(nd)*pwr1+axial_induction_ust**&
&         0.8325_dp*pwr1d(nd))*ti_ust**0.0325_dp+axial_induction_ust**&
&         0.8325_dp*pwr1*0.0325_dp*ti_ust**(-0.9675)*ti_ustd(nd))
        rotor_area_dstd(nd) = 0.25_dp*pi*2_dp*rotor_diameter_dst*&
&         rotor_diameter_dstd(nd)
        ti_area_ratio_tmpd(nd) = ti_addedd(nd)*wake_overlap/&
&         rotor_area_dst + ti_added*(wake_overlapd(nd)*rotor_area_dst-&
&         wake_overlap*rotor_area_dstd(nd))/rotor_area_dst**2
      END DO
      ti_area_ratio_tmp = ti_added*(wake_overlap/rotor_area_dst)
!TI_tmp = sqrt(TI**2.0_dp + (TI_added*(wake_overlap/rotor_area_dst))**2.0_dp)
! Run through the smooth max to get an approximation of the true max TI area ratio
      CALL SMOOTH_MAX_DV(sm_smoothing, ti_area_ratio_in, &
&                  ti_area_ratio_ind, ti_area_ratio_tmp, &
&                  ti_area_ratio_tmpd, ti_area_ratio, ti_area_ratiod, &
&                  nbdirs)
      arg1 = ti**2.0_dp + ti_area_ratio**2.0_dp
      DO nd=1,nbdirs
! Calculate the total turbulence intensity at the downstream turbine based on 
! the result of the smooth max function
        arg1d(nd) = 2.0_dp*ti_area_ratio*ti_area_ratiod(nd)
        IF (arg1 .EQ. 0.0) THEN
          ti_dstd(nd) = 0.0_8
        ELSE
          ti_dstd(nd) = arg1d(nd)/(2.0*SQRT(arg1))
        END IF
      END DO
      ti_dst = SQRT(arg1)
    END IF
  ELSE
! wake combination method error 
    PRINT*, &
&   'Invalid added TI calculation method. Must be one of [0,1,2,3,4,5].'
    STOP
  END IF
END SUBROUTINE ADDED_TI_FUNC_DV

!  Differentiation of overlap_area_func in forward (tangent) mode:
!   variations   of useful results: wake_overlap
!   with respect to varying inputs: wake_diameter rotor_diameter
!                turbine_y turbine_z wake_center_z
! calculates the overlap area between a given wake and a rotor area
SUBROUTINE OVERLAP_AREA_FUNC_DV(turbine_y, turbine_yd, turbine_z, &
& turbine_zd, rotor_diameter, rotor_diameterd, wake_center_y, &
& wake_center_z, wake_center_zd, wake_diameter, wake_diameterd, &
& wake_overlap, wake_overlapd, nbdirs)
!  USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: turbine_y, turbine_z, rotor_diameter
  REAL(dp), DIMENSION(nbdirs), INTENT(IN) :: turbine_yd, turbine_zd, &
& rotor_diameterd
  REAL(dp), INTENT(IN) :: wake_center_y, wake_center_z, wake_diameter
  REAL(dp), DIMENSION(nbdirs), INTENT(IN) :: wake_center_zd, &
& wake_diameterd
! out    
  REAL(dp), INTENT(OUT) :: wake_overlap
  REAL(dp), DIMENSION(nbdirs), INTENT(OUT) :: wake_overlapd
! local
  REAL(dp), PARAMETER :: pi=3.141592653589793_dp, tol=0.000001_dp
  REAL(dp) :: ovdyd, ovr, ovrr, ovl, ovz, ovz2
  REAL(dp), DIMENSION(nbdirs) :: ovdydd, ovrd, ovrrd, ovld, ovzd, &
& ovz2d
! load intrinsic functions
  INTRINSIC ACOS, SQRT
  REAL(dp) :: arg1
  REAL(dp), DIMENSION(nbdirs) :: arg1d
  REAL(dp) :: result1
  REAL(dp), DIMENSION(nbdirs) :: result1d
  REAL(dp) :: arg2
  REAL(dp), DIMENSION(nbdirs) :: arg2d
  REAL(dp) :: result2
  REAL(dp), DIMENSION(nbdirs) :: result2d
  INTEGER :: nd
  INTEGER :: nbdirs
!     print *, turbine_y, turbine_z, rotor_diameter, &
!                             wake_center_y, wake_center_z, wake_diameter, &
!                             wake_overlap
! distance between wake center and rotor center
  IF (wake_center_z .GT. turbine_z + tol .OR. wake_center_z .LT. &
&     turbine_z - tol) THEN
    arg1 = (wake_center_y-turbine_y)**2_dp + (wake_center_z-turbine_z)**&
&     2_dp
    DO nd=1,nbdirs
      arg1d(nd) = 2_dp*(wake_center_z-turbine_z)*(wake_center_zd(nd)-&
&       turbine_zd(nd)) - 2_dp*(wake_center_y-turbine_y)*turbine_yd(nd)
      IF (arg1 .EQ. 0.0) THEN
        ovdydd(nd) = 0.0_8
      ELSE
        ovdydd(nd) = arg1d(nd)/(2.0*SQRT(arg1))
      END IF
    END DO
    ovdyd = SQRT(arg1)
  ELSE IF (wake_center_y .GT. turbine_y + tol) THEN
    DO nd=1,nbdirs
! potential source of gradient issues, abs() did not cause a problem in FLORIS
      ovdydd(nd) = -turbine_yd(nd)
    END DO
    ovdyd = wake_center_y - turbine_y
  ELSE IF (turbine_y .GT. wake_center_y + tol) THEN
    DO nd=1,nbdirs
      ovdydd(nd) = turbine_yd(nd)
    END DO
    ovdyd = turbine_y - wake_center_y
  ELSE
    ovdyd = 0.0_dp
    ovdydd(:) = 0.0_8
  END IF
  DO nd=1,nbdirs
!print *, "OVdYd: ", OVdYd
! find rotor radius
    ovrd(nd) = rotor_diameterd(nd)/2.0_dp
!print *, "OVr: ", OVr
! find wake radius
    ovrrd(nd) = wake_diameterd(nd)/2.0_dp
  END DO
  ovr = rotor_diameter/2.0_dp
  ovrr = wake_diameter/2.0_dp
!print *, "OVRR: ", OVRR
! make sure the distance from wake center to turbine hub is positive
! OVdYd = abs(OVdYd) !!! commented out since change to 2D distance (y,z) will always be positive
! calculate the distance from the wake center to the line perpendicular to the 
! line between the two circle intersection points
!if (OVdYd >= 0.0_dp + tol) then ! check case to avoid division by zero
!     print *, "OVdYd ", OVdYd
! if (OVdYd >= 0.0_dp + tol) then ! check case to avoid division by zero
!         OVL = (-OVr*OVr+OVRR*OVRR+OVdYd*OVdYd)/(2.0_dp*OVdYd)
! !         print *, "OVdYd, OVL: ", OVdYd, OVL
!     else
!         OVL = 0.0_dp
!     end if
! 
!     OVz = OVRR*OVRR-OVL*OVL
! 
!     ! Finish calculating the distance from the intersection line to the outer edge of the wake
!     !if (OVz > 0.0_dp + tol) then
!     if (OVz > 0.0_dp + tol) then
!         OVz = sqrt(OVz)
!     else
!         OVz = 0.0_dp
!     end if
!print *, "OVRR, OVL, OVRR, OVr, OVdYd, OVz ", OVRR, OVL, OVRR, OVr, OVdYd, OVz
! if (OVdYd < (OVr+OVRR)) then ! if the rotor overlaps the wake
!         !print *, "OVL: ", OVL
!         if (OVL < OVRR .and. (OVdYd-OVL) < OVr) then
! !         if (OVdYd > 0.0_dp + tol) then
! !         if ((OVdYd > 0.0_dp) .and. (OVdYd > (OVRR - OVr))) then
!             ! print *, "acos(OVL/OVRR), acos((OVdYd-OVL)/OVr), OVRR, OVL, OVr, OVdYd, OVL/OVRR, (OVdYd-OVL)/OVr ", &
! !     & acos(OVL/OVRR), acos((OVdYd-OVL)/OVr), OVRR, OVL, OVr, OVdYd, OVL/OVRR, (OVdYd-OVL)/OVr
!             wake_overlap = OVRR*OVRR*acos(OVL/OVRR) + OVr*OVr*acos((OVdYd-OVL)/OVr) - OVdYd*OVz
!         else if (OVRR > OVr) then
!             wake_overlap = pi*OVr*OVr
!             !print *, "wake ovl: ", wake_overlap
!         else
!             wake_overlap = pi*OVRR*OVRR
!         end if
!     else
!         wake_overlap = 0.0_dp
!     end if
! determine if there is overlap
  IF (ovdyd .LT. ovr + ovrr) THEN
! if the rotor overlaps the wake zone
! check that turbine and wake centers are not perfectly aligned
    IF (ovdyd .GT. 0.0_dp + tol) THEN
! check if the rotor is wholly contained in the wake
      IF (ovdyd + ovr .LT. ovrr + tol) THEN
        DO nd=1,nbdirs
          wake_overlapd(nd) = pi*(ovrd(nd)*ovr+ovr*ovrd(nd))
        END DO
        wake_overlap = pi*ovr*ovr
!                 print *, "1"
! check if the wake is wholly contained in the rotor swept area
      ELSE IF (ovdyd + ovrr .LT. ovr + tol) THEN
        DO nd=1,nbdirs
          wake_overlapd(nd) = pi*(ovrrd(nd)*ovrr+ovrr*ovrrd(nd))
        END DO
        wake_overlap = pi*ovrr*ovrr
!                 print *, "2"
      ELSE
        ovl = (-(ovr*ovr)+ovrr*ovrr+ovdyd*ovdyd)/(2.0_dp*ovdyd)
        arg1 = ovrr*ovrr - ovl*ovl
        arg2 = (ovdyd-ovl)/ovr
        DO nd=1,nbdirs
! calculate the distance from the wake center to the chord connecting the lens
! cusps
          ovld(nd) = ((ovrrd(nd)*ovrr-ovr*ovrd(nd)-ovrd(nd)*ovr+ovrr*&
&           ovrrd(nd)+ovdydd(nd)*ovdyd+ovdyd*ovdydd(nd))*2.0_dp*ovdyd-(-&
&           (ovr*ovr)+ovrr*ovrr+ovdyd*ovdyd)*2.0_dp*ovdydd(nd))/(2.0_dp*&
&           ovdyd)**2
          arg1d(nd) = ovrrd(nd)*ovrr + ovrr*ovrrd(nd) - ovld(nd)*ovl - &
&           ovl*ovld(nd)
          IF (arg1 .EQ. 0.0) THEN
            ovzd(nd) = 0.0_8
          ELSE
            ovzd(nd) = arg1d(nd)/(2.0*SQRT(arg1))
          END IF
          arg1d(nd) = ovrd(nd)*ovr + ovr*ovrd(nd) - (ovdydd(nd)-ovld(nd)&
&           )*(ovdyd-ovl) - (ovdyd-ovl)*(ovdydd(nd)-ovld(nd))
          arg2d(nd) = ((ovdydd(nd)-ovld(nd))*ovr-(ovdyd-ovl)*ovrd(nd))/&
&           ovr**2
          IF (arg2 .EQ. 1.0 .OR. arg2 .EQ. (-1.0)) THEN
            result2d(nd) = 0.0_8
          ELSE
            result2d(nd) = -(arg2d(nd)/SQRT(1.0-arg2**2))
          END IF
        END DO
        ovz = SQRT(arg1)
        arg1 = ovr*ovr - (ovdyd-ovl)*(ovdyd-ovl)
        DO nd=1,nbdirs
          IF (arg1 .EQ. 0.0) THEN
            ovz2d(nd) = 0.0_8
          ELSE
            ovz2d(nd) = arg1d(nd)/(2.0*SQRT(arg1))
          END IF
          arg1d(nd) = (ovld(nd)*ovrr-ovl*ovrrd(nd))/ovrr**2
        END DO
        ovz2 = SQRT(arg1)
        arg1 = ovl/ovrr
        result1 = ACOS(arg1)
        result2 = ACOS(arg2)
        DO nd=1,nbdirs
          IF (arg1 .EQ. 1.0 .OR. arg1 .EQ. (-1.0)) THEN
            result1d(nd) = 0.0_8
          ELSE
            result1d(nd) = -(arg1d(nd)/SQRT(1.0-arg1**2))
          END IF
          wake_overlapd(nd) = (ovrrd(nd)*ovrr+ovrr*ovrrd(nd))*result1 + &
&           ovrr**2*result1d(nd) + (ovrd(nd)*ovr+ovr*ovrd(nd))*result2 +&
&           ovr**2*result2d(nd) - ovld(nd)*ovz - ovl*ovzd(nd) - (ovdydd(&
&           nd)-ovld(nd))*ovz2 - (ovdyd-ovl)*ovz2d(nd)
        END DO
        wake_overlap = ovrr*ovrr*result1 + ovr*ovr*result2 - ovl*ovz - (&
&         ovdyd-ovl)*ovz2
!                 print *, OVRR, OVr, OVdYd, OVL, OVz, OVz2
!                 print *, "3"
      END IF
    ELSE IF (ovrr .GT. ovr) THEN
! perfect overlap case where the wake is larger than the rotor
      DO nd=1,nbdirs
        wake_overlapd(nd) = pi*(ovrd(nd)*ovr+ovr*ovrd(nd))
      END DO
      wake_overlap = pi*ovr*ovr
!             print *, "4"
! perfect overlap case where the rotor is larger than the wake
    ELSE
      DO nd=1,nbdirs
        wake_overlapd(nd) = pi*(ovrrd(nd)*ovrr+ovrr*ovrrd(nd))
      END DO
      wake_overlap = pi*ovrr*ovrr
!             print *, "5"
    END IF
  ELSE
! case with no overlap
    wake_overlap = 0.0_dp
    wake_overlapd(:) = 0.0_8
  END IF
!     print *, "wake overlap in func: ", wake_overlap/(pi*OVr**2)
!     print *, "wake overlap in func: ", wake_overlap/(pi*OVRR**2)
  IF (wake_overlap/(pi*ovr*ovr) .GT. 1.0_dp + tol .OR. wake_overlap/(pi*&
&     ovrr*ovrr) .GT. 1.0_dp + tol) THEN
    PRINT*, 'wake overlap in func: ', wake_overlap/(pi*ovr*ovr)
    PRINT*, 'wake overlap in func: ', wake_overlap/(pi*ovrr*ovrr)
    STOP
  END IF
END SUBROUTINE OVERLAP_AREA_FUNC_DV

!  Differentiation of k_star_func in forward (tangent) mode:
!   variations   of useful results: k_star_ust
!   with respect to varying inputs: ti_ust
! compute wake spread parameter based on local turbulence intensity
SUBROUTINE K_STAR_FUNC_DV(ti_ust, ti_ustd, k_star_ust, k_star_ustd, &
& nbdirs)
!  USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: ti_ust
  REAL(dp), DIMENSION(nbdirs), INTENT(IN) :: ti_ustd
! out  
  REAL(dp), INTENT(OUT) :: k_star_ust
  REAL(dp), DIMENSION(nbdirs), INTENT(OUT) :: k_star_ustd
  INTEGER :: nd
  INTEGER :: nbdirs
  DO nd=1,nbdirs
! calculate wake spread parameter from Niayifar and Porte Agel (2015, 2016)
    k_star_ustd(nd) = 0.3837*ti_ustd(nd)
  END DO
  k_star_ust = 0.3837*ti_ust + 0.003678
END SUBROUTINE K_STAR_FUNC_DV

!  Differentiation of ct_to_axial_ind_func in forward (tangent) mode:
!   variations   of useful results: axial_induction
!   with respect to varying inputs: ct
! calculate axial induction from Ct
SUBROUTINE CT_TO_AXIAL_IND_FUNC_DV(ct, ctd, axial_induction, &
& axial_inductiond, nbdirs)
!  USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: ct
  REAL(dp), DIMENSION(nbdirs), INTENT(IN) :: ctd
! out
  REAL(dp), INTENT(OUT) :: axial_induction
  REAL(dp), DIMENSION(nbdirs), INTENT(OUT) :: axial_inductiond
  INTRINSIC SQRT
  REAL(dp) :: arg1
  REAL(dp), DIMENSION(nbdirs) :: arg1d
  REAL(dp) :: result1
  REAL(dp), DIMENSION(nbdirs) :: result1d
  INTEGER :: nd
  INTEGER :: nbdirs
! initialize axial induction to zero
  axial_induction = 0.0_dp
! calculate axial induction
  IF (ct .GT. 0.96) THEN
    arg1 = 0.0203_dp - 0.6427_dp*(0.889_dp-ct)
    DO nd=1,nbdirs
! Glauert condition
      arg1d(nd) = 0.6427_dp*ctd(nd)
      IF (arg1 .EQ. 0.0) THEN
        result1d(nd) = 0.0_8
      ELSE
        result1d(nd) = arg1d(nd)/(2.0*SQRT(arg1))
      END IF
      axial_inductiond(nd) = result1d(nd)
    END DO
    result1 = SQRT(arg1)
    axial_induction = 0.143_dp + result1
  ELSE
    DO nd=1,nbdirs
      result1d(nd) = -(ctd(nd)/(2.0*SQRT(1.0_dp-ct)))
      axial_inductiond(nd) = -(0.5_dp*result1d(nd))
    END DO
    result1 = SQRT(1.0_dp - ct)
    axial_induction = 0.5_dp*(1.0_dp-result1)
  END IF
END SUBROUTINE CT_TO_AXIAL_IND_FUNC_DV

!  Differentiation of wind_shear_func in forward (tangent) mode:
!   variations   of useful results: adjusted_wind_speed
!   with respect to varying inputs: point_z u_ref
! adjust wind speed for wind shear
SUBROUTINE WIND_SHEAR_FUNC_DV(point_z, point_zd, u_ref, u_refd, z_ref, &
& z_0, shear_exp, adjusted_wind_speed, adjusted_wind_speedd, nbdirs)
!  USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: point_z, u_ref, z_ref, z_0, shear_exp
  REAL(dp), DIMENSION(nbdirs), INTENT(IN) :: point_zd, u_refd
! out
  REAL(dp), INTENT(OUT) :: adjusted_wind_speed
  REAL(dp), DIMENSION(nbdirs), INTENT(OUT) :: adjusted_wind_speedd
  REAL(dp) :: pwx1
  REAL(dp), DIMENSION(nbdirs) :: pwx1d
  REAL(dp) :: pwr1
  REAL(dp), DIMENSION(nbdirs) :: pwr1d
  INTEGER :: nd
  INTEGER :: nbdirs
! initialize adjusted wind speed to zero
  adjusted_wind_speed = 0.0_dp
! check that the point of interest is above ground level
  IF (point_z .GE. z_0) THEN
    pwx1 = (point_z-z_0)/(z_ref-z_0)
    pwr1 = pwx1**shear_exp
    DO nd=1,nbdirs
! adjusted wind speed for wind shear if point is above ground
      pwx1d(nd) = point_zd(nd)/(z_ref-z_0)
      IF (pwx1 .GT. 0.0 .OR. (pwx1 .LT. 0.0 .AND. shear_exp .EQ. INT(&
&         shear_exp))) THEN
        pwr1d(nd) = shear_exp*pwx1**(shear_exp-1)*pwx1d(nd)
      ELSE IF (pwx1 .EQ. 0.0 .AND. shear_exp .EQ. 1.0) THEN
        pwr1d(nd) = pwx1d(nd)
      ELSE
        pwr1d(nd) = 0.0
      END IF
      adjusted_wind_speedd(nd) = u_refd(nd)*pwr1 + u_ref*pwr1d(nd)
    END DO
    adjusted_wind_speed = u_ref*pwr1
  ELSE
! if the point of interest is below ground, set the wind speed to 0.0
    adjusted_wind_speed = 0.0_dp
    adjusted_wind_speedd(:) = 0.0_8
  END IF
END SUBROUTINE WIND_SHEAR_FUNC_DV

!  Differentiation of discontinuity_point_func in forward (tangent) mode:
!   variations   of useful results: discontinuity_point
!   with respect to varying inputs: yaw ky kz rotor_diameter x0
!                ct
! calculate the point where the Bastankhah and Porte Agel wake model becomes undefined
SUBROUTINE DISCONTINUITY_POINT_FUNC_DV(x0, x0d, rotor_diameter, &
& rotor_diameterd, ky, kyd, kz, kzd, yaw, yawd, ct, ctd, &
& discontinuity_point, discontinuity_pointd, nbdirs)
!  USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: x0, rotor_diameter, ky, kz, yaw, ct
  REAL(dp), DIMENSION(nbdirs), INTENT(IN) :: x0d, rotor_diameterd, &
& kyd, kzd, yawd, ctd
! local
  REAL(dp) :: a, b, c
  REAL(dp), DIMENSION(nbdirs) :: ad, bd, cd
! out
  REAL(dp), INTENT(OUT) :: discontinuity_point
  REAL(dp), DIMENSION(nbdirs), INTENT(OUT) :: discontinuity_pointd
  INTRINSIC COS, SQRT
  REAL(dp) :: result1
  REAL(dp), DIMENSION(nbdirs) :: result1d
  REAL(dp) :: arg1
  REAL(dp), DIMENSION(nbdirs) :: arg1d
  INTEGER :: nd
  INTEGER :: nbdirs
  a = ky + kz*COS(yaw)
  b = 4.0_dp*ky*kz*COS(yaw)*(ct-1.0_dp)
  result1 = SQRT(8.0_dp)
  arg1 = a**2 - b
  DO nd=1,nbdirs
! for clarity, break out the terms in the equation
    ad(nd) = kyd(nd) + kzd(nd)*COS(yaw) - kz*yawd(nd)*SIN(yaw)
    bd(nd) = 4.0_dp*(((kyd(nd)*kz+ky*kzd(nd))*(ct-1.0_dp)+ky*kz*ctd(nd))&
&     *COS(yaw)-ky*kz*(ct-1.0_dp)*yawd(nd)*SIN(yaw))
    cd(nd) = 2.0_dp*result1*(kyd(nd)*kz+ky*kzd(nd))
! distance from rotor to the last point where the wake model is undefined
    arg1d(nd) = 2*a*ad(nd) - bd(nd)
    IF (arg1 .EQ. 0.0) THEN
      result1d(nd) = 0.0_8
    ELSE
      result1d(nd) = arg1d(nd)/(2.0*SQRT(arg1))
    END IF
  END DO
  c = 2.0_dp*result1*ky*kz
  result1 = SQRT(arg1)
  DO nd=1,nbdirs
    discontinuity_pointd(nd) = x0d(nd) + ((rotor_diameterd(nd)*(a-&
&     result1)+rotor_diameter*(ad(nd)-result1d(nd)))*c-rotor_diameter*(a&
&     -result1)*cd(nd))/c**2
  END DO
  discontinuity_point = x0 + rotor_diameter*(a-result1)/c
END SUBROUTINE DISCONTINUITY_POINT_FUNC_DV

!  Differentiation of smooth_max in forward (tangent) mode:
!   variations   of useful results: g
!   with respect to varying inputs: x y
SUBROUTINE SMOOTH_MAX_DV(s, x, xd, y, yd, g, gd, nbdirs)
!  USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: s, x, y
  REAL(dp), DIMENSION(nbdirs), INTENT(IN) :: xd, yd
! local
  REAL(dp) :: max_val, min_val
  REAL(dp), DIMENSION(nbdirs) :: max_vald, min_vald
! out
  REAL(dp), INTENT(OUT) :: g
  REAL(dp), DIMENSION(nbdirs), INTENT(OUT) :: gd
  INTRINSIC LOG, EXP, MAX, MIN
  REAL(dp) :: arg1
  REAL(dp), DIMENSION(nbdirs) :: arg1d
  REAL(dp) :: arg2
  REAL(dp), DIMENSION(nbdirs) :: arg2d
  INTEGER :: nd
  INTEGER :: nbdirs
  IF (x .LT. y) THEN
    DO nd=1,nbdirs
      max_vald(nd) = yd(nd)
    END DO
    max_val = y
  ELSE
    DO nd=1,nbdirs
      max_vald(nd) = xd(nd)
    END DO
    max_val = x
  END IF
  IF (x .GT. y) THEN
    DO nd=1,nbdirs
      min_vald(nd) = yd(nd)
    END DO
    min_val = y
  ELSE
    DO nd=1,nbdirs
      min_vald(nd) = xd(nd)
    END DO
    min_val = x
  END IF
  arg1 = s*(min_val-max_val)
  arg2 = 1.0_dp + EXP(arg1)
  DO nd=1,nbdirs
    arg1d(nd) = s*(min_vald(nd)-max_vald(nd))
    arg2d(nd) = arg1d(nd)*EXP(arg1)
    gd(nd) = (arg2d(nd)/arg2+s*max_vald(nd))/s
  END DO
  g = (LOG(arg2)+s*max_val)/s
END SUBROUTINE SMOOTH_MAX_DV

!  Differentiation of interpolation in forward (tangent) mode:
!   variations   of useful results: yval
!   with respect to varying inputs: yval xval
SUBROUTINE INTERPOLATION_DV(npoints, interp_type, x, y, xval, xvald, &
& yval, yvald, dy0in, dy1in, usedyin, nbdirs)
!  USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
!     print *, "yval = ", yval
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  INTEGER, INTENT(IN) :: npoints, interp_type
  REAL(dp), DIMENSION(npoints), INTENT(IN) :: x, y
  REAL(dp), INTENT(IN) :: xval
  REAL(dp), DIMENSION(nbdirs), INTENT(IN) :: xvald
  REAL(dp), INTENT(IN) :: dy0in, dy1in
  LOGICAL :: usedyin
! local
  INTEGER :: idx
  REAL(dp) :: x0, x1, y0, dy0, y1, dy1
! out
  REAL(dp), INTENT(OUT) :: yval
  REAL(dp), DIMENSION(nbdirs), INTENT(OUT) :: yvald
  INTEGER :: nd
  INTEGER :: nbdirs
!     print *, "in interpolation"
! if ((xval < x(1)) .or. (xval > x(nPoints))) then
!         print *, "interpolation point is out of bounds"
! !         STOP 1
!     end if
  IF (usedyin .AND. interp_type .EQ. 1) THEN
    PRINT*, &
&  'end point derivatives may not be specified for linear interpolation'
    STOP
  ELSE IF (xval .LT. x(1)) THEN
    yval = y(1)
    yvald(:) = 0.0_8
  ELSE IF (xval .GT. x(npoints)) THEN
    yval = y(npoints)
    yvald(:) = 0.0_8
  ELSE
    idx = 1
    DO WHILE (xval .GT. x(idx) .AND. idx .LE. npoints)
      idx = idx + 1
    END DO
    idx = idx - 1
    x0 = x(idx)
    x1 = x(idx+1)
    y0 = y(idx)
    y1 = y(idx+1)
! Hermite cubic piecewise spline interpolation
    IF (interp_type .EQ. 0) THEN
! approximate derivative at left end of interval
      IF (idx .EQ. 1) THEN
        IF (usedyin) THEN
          dy0 = dy0in
        ELSE
          dy0 = 0.0_dp
        END IF
      ELSE
        dy0 = (y(idx+1)-y(idx-1))/(x(idx+1)-x(idx-1))
      END IF
! approximate derivative at the right end of interval
      IF (idx .GE. npoints - 1) THEN
        IF (usedyin) THEN
          dy1 = dy1in
        ELSE
          dy1 = 0.0_dp
        END IF
      ELSE
        dy1 = (y(idx+2)-y(idx))/(x(idx+2)-x(idx))
      END IF
! call Hermite spline routine
      CALL HERMITE_SPLINE_DV(xval, xvald, x0, x1, y0, dy0, y1, dy1, yval&
&                      , yvald, nbdirs)
! linear interpolation
    ELSE IF (interp_type .EQ. 1) THEN
      DO nd=1,nbdirs
        yvald(nd) = (y1-y0)*xvald(nd)/(x1-x0)
      END DO
      yval = (xval-x0)*(y1-y0)/(x1-x0) + y0
    END IF
  END IF
END SUBROUTINE INTERPOLATION_DV

!  Differentiation of hermite_spline in forward (tangent) mode:
!   variations   of useful results: y
!   with respect to varying inputs: x
SUBROUTINE HERMITE_SPLINE_DV(x, xd, x0, x1, y0, dy0, y1, dy1, y, yd, &
& nbdirs)
!  USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
!dy_dx = c3*3*x**2 + c2*2*x + c1
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: x, x0, x1, y0, dy0, y1, dy1
  REAL(dp), DIMENSION(nbdirs), INTENT(IN) :: xd
! out
!, dy_dx
  REAL(dp), INTENT(OUT) :: y
  REAL(dp), DIMENSION(nbdirs), INTENT(OUT) :: yd
! local
  REAL(dp) :: c3, c2, c1, c0
  INTEGER :: nd
  INTEGER :: nbdirs
! initialize coefficients for parametric cubic spline
  c3 = 2.0_dp*y1/(x0**3-3.0_dp*x0**2*x1+3.0_dp*x0*x1**2-x1**3) - 2.0_dp*&
&   y0/(x0**3-3.0_dp*x0**2*x1+3.0_dp*x0*x1**2-x1**3) + dy0/(x0**2-2.0_dp&
&   *x0*x1+x1**2) + dy1/(x0**2-2.0_dp*x0*x1+x1**2)
  c2 = 3.0_dp*y0*(x0+x1)/(x0**3-3.0_dp*x0**2*x1+3.0_dp*x0*x1**2-x1**3) -&
&   dy1*(2.0_dp*x0+x1)/(x0**2-2.0_dp*x0*x1+x1**2) - dy0*(x0+2.0_dp*x1)/(&
&   x0**2-2.0_dp*x0*x1+x1**2) - 3.0_dp*y1*(x0+x1)/(x0**3-3.0_dp*x0**2*x1&
&   +3.0_dp*x0*x1**2-x1**3)
  c1 = dy0*(x1**2+2.0_dp*x0*x1)/(x0**2-2.0_dp*x0*x1+x1**2) + dy1*(x0**2+&
&   2.0_dp*x1*x0)/(x0**2-2.0_dp*x0*x1+x1**2) - 6.0_dp*x0*x1*y0/(x0**3-&
&   3.0_dp*x0**2*x1+3.0_dp*x0*x1**2-x1**3) + 6.0_dp*x0*x1*y1/(x0**3-&
&   3.0_dp*x0**2*x1+3.0_dp*x0*x1**2-x1**3)
  c0 = y0*(-(x1**3)+3.0_dp*x0*x1**2)/(x0**3-3.0_dp*x0**2*x1+3.0_dp*x0*x1&
&   **2-x1**3) - y1*(-(x0**3)+3.0_dp*x1*x0**2)/(x0**3-3.0_dp*x0**2*x1+&
&   3.0_dp*x0*x1**2-x1**3) - x0*x1**2*dy0/(x0**2-2.0_dp*x0*x1+x1**2) - &
&   x0**2*x1*dy1/(x0**2-2.0_dp*x0*x1+x1**2)
  DO nd=1,nbdirs
!    print *, 'c3 = ', c3
!    print *, 'c2 = ', c2
!    print *, 'c1 = ', c1
!    print *, 'c0 = ', c0
! Solve for y and dy values at the given point
    yd(nd) = c3*3*x**2*xd(nd) + c2*2*x*xd(nd) + c1*xd(nd)
  END DO
  y = c3*x**3 + c2*x**2 + c1*x + c0
END SUBROUTINE HERMITE_SPLINE_DV
!    yd, n = _checkIfFloat(yd)
! 
!     y1 = (1-pct_offset)*ymax
!     y2 = (1+pct_offset)*ymax
! 
!     dy1 = (1-pct_offset)
!     dy2 = (1+pct_offset)
! 
!     if (maxmin == 1) then
!         f1 = y1
!         f2 = ymax
!         g1 = 1.0_dp
!         g2 = 0.0_dp
!         if (yd .ge. y2) then
!             idx_constant = False
!         else
!             idx_constant = True
!         end if
! 
!         df1 = dy1
!         df2 = 1.0_dp
! 
! 
!     else if (maxmin == 0) then
!         f1 = ymax
!         f2 = y2
!         g1 = 0.0_dp
!         g2 = 1.0_dp
!         if (yd .ge. y1) then
!             idx_constant = False
!         else
!             idx_constant = True
!         end if
! 
!         df1 = 1.0_dp
!         df2 = dy2
!         
!     end if
! 
!     f = CubicSplineSegment(y1, y2, f1, f2, g1, g2)
! 
!     # main region
!     ya = np.copy(yd)
!     if dyd is None:
!         dya_dyd = np.ones_like(yd)
!     else:
!         dya_dyd = np.copy(dyd)
! 
!     dya_dymax = np.zeros_like(ya)
! 
!     # cubic spline region
!     idx = np.logical_and(yd > y1, yd < y2)
!     ya[idx] = f.eval(yd[idx])
!     dya_dyd[idx] = f.eval_deriv(yd[idx])
!     dya_dymax[idx] = f.eval_deriv_params(yd[idx], dy1, dy2, df1, df2, 0.0, 0.0)
! 
!     # constant region
!     ya[idx_constant] = ymax
!     dya_dyd[idx_constant] = 0.0
!     dya_dymax[idx_constant] = 1.0
! 
!     if n == 1:
!         ya = ya[0]
!         dya_dyd = dya_dyd[0]
!         dya_dymax = dya_dymax[0]
! 
! 
!     return ya, dya_dyd, dya_dymax
! 
! 
! def smooth_max(yd, ymax, pct_offset=0.01, dyd=None):
!     """array max, uses cubic spline to smoothly transition.  derivatives with respect to array and max value.
!     width of transition can be controlled, and chain rules for differentiation"""
!     return _smooth_maxmin(yd, ymax, 'max', pct_offset, dyd)
! 
! 
! def smooth_min(yd, ymin, pct_offset=0.01, dyd=None):
!     """array min, uses cubic spline to smoothly transition.  derivatives with respect to array and min value.
!     width of transition can be controlled, and chain rules for differentiation"""
!     return _smooth_maxmin(yd, ymin, 'min', pct_offset, dyd)
! 